<?php
/*
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2006 Bharat Mediratta
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id$
 */

/**
 * This class contains method for creating plugin descriptors.
 *
 * @author Jozef Selesi <selesi at gmail dot com>
 *
 * @version $Revision$ $Date$
 * @package RepositoryTools
 * @subpackage Classes
 * @module RepositoryDescriptor
 */
class RepositoryDescriptor extends RepositoryObject {

    /**
     * Plugin version.
     *
     * @var string
     * @access private
     */
    var $_pluginVersion;

    /**
     * Plugin ID.
     *
     * @var string
     * @access private
     */
    var $_pluginId;

    /**
     * Absolute path to the plugin directory.
     *
     * @var string
     * @access private
     */
    var $_pluginDir;

    /**
     * All data contained in a descriptor.
     *
     * @var array
     * @access private
     */
    var $_data;

   /**
     * Initializes the descriptor object and gets all plugin
     * meta data required for a complete descriptor definition.
     *
     * @param object GalleryPlugin plugin to create descriptor for
     * @param string directory to write the descriptor to
     * @return object GalleryStatus a status code
     */
    function init($outputDir) {
	parent::init();

	/* Set output path. */
	$ret = $this->setOutputDir($outputDir);
	if ($ret) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	return null;
    }

    function generate($plugin) {
	global $gallery;

	/* Get basic plugin meta data. */
	$pluginType = $plugin->getPluginType();
	$this->_pluginId = $plugin->getId();
	$this->_pluginVersion = $plugin->getVersion();

	/* Create descriptor header. */
	$header['id'] = $this->_pluginId;
	$header['version'] = $this->_pluginVersion;
	$header['requiredCoreApi'] = $plugin->getRequiredCoreApi();
	$header['requiredPluginApi'] = $pluginType == 'module'
				     ? $plugin->getRequiredModuleApi()
				     : $plugin->getRequiredThemeApi();
	$this->_data['header'] = $header;

	/* Get raw strings for translation. */
	$descriptions['en_US']['name'] = $plugin->getName();
	$descriptions['en_US']['description'] = $plugin->getDescription();
	if ($pluginType == 'module') {
	    $groupData = $plugin->getGroup();
	    $descriptions['en_US']['groupLabel'] = $groupData['groupLabel'];
	}

	/*
	 * Get translated strings for all supported languages. All
	 * locales must be installed on the system for this to work.
	 */
	$translator = $gallery->getTranslator();
	list ($supportedLanguages, $defaultCountry) = $translator->getLanguageData();
	foreach ($supportedLanguages as $language => $countries) {
	    foreach ($countries as $country => $description) {
		$languageCode = $language . '_' . $country;

		/* We've already got the en_US strings. */
		if ($languageCode == 'en_US') {
		    continue;
		}

		/* Translate into current language. */
		$translator->init($languageCode);
		foreach ($descriptions['en_US'] as $stringId => $originalString) {
		    list ($ret, $translatedString) = $translator->translateDomain(
			sprintf('%ss_%s', $pluginType, $this->_pluginId),
			array('text' => $originalString));
		    if ($ret) {
			return $ret->wrap(__FILE__, __LINE__);
		    }
		    $descriptions[$languageCode][$stringId] = $translatedString;
		}
	    }
	}
	$this->_data['descriptions'] = $descriptions;

	/* Get file meta data. */
	$platform =& $gallery->getPlatform();
	$pluginBaseDir = GalleryCoreApi::getPluginBaseDir($pluginType, $this->_pluginId);
	$this->_pluginDir = $platform->realpath(
	    sprintf('%s%ss/%s', $pluginBaseDir, $pluginType, $this->_pluginId)) . '/';
	$ret = $this->getFileMetaData($this->_pluginDir, $this->_data, $this->_pluginDir);
	if ($ret) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	/* Get build timestamp. */
	list ($ret, $this->_data['header']['buildTimestamp']) =
	    $this->calculateBuildTimestamp($this->getPluginDir());
	if ($ret) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	/* Create available languages meta data. */
	foreach ($this->_data['files'] as $fileName => $fileMetaData) {
	    if (preg_match('/po\/(.._..)\.po$/U', $fileName, $languageCode)) {
		$languageCode = $languageCode[1];

		/* Get revision number from po file. */
		list ($ret, $tag) =
		    $this->_utilities->getFirstBytesFromFile($this->_pluginDir . $fileName, 128);
		if ($ret) {
		    return $ret->wrap(__FILE__, __LINE__);
		}

		list ($ret, $revision) = $this->_utilities->extractRevision($tag);
		if ($ret) {
		    return $ret->wrap(__FILE__, __LINE__);
		}

		$stringsRevision = $this->_data['header']['stringsRevision'];
		$this->_data['languages'][$stringsRevision][$languageCode] = $revision;
	    }
	}

	$this->setOutputFile(sprintf('%s-%s-%s.descriptor',
	    $this->_pluginId, $this->_pluginVersion, $this->getBuildTimestamp()));

	/* Put data into template. */
	$this->_template->setVariable('contents', serialize($this->_data));

	return null;
    }

    /**
     * Gets all file-related plugin meta data from the filesystem.
     *
     * @param string path to process
     * @param array array to write meta data to
     * @return object GalleryStatus a status code
     */
    function getFileMetaData($path, &$data, &$pluginDir) {
	global $gallery;
	$relativePath = substr($path, strlen($pluginDir));

	$platform =& $gallery->getPlatform();
	if ($platform->is_dir($path) && $dir = $platform->opendir($path)) {
	    /* Ignore plugin base directory */
	    if (strlen($relativePath)) {
		$data['directories'][$relativePath]['packages'] =
		    $this->getPackageNames($relativePath);
	    }

	    /* Get directory meta data and recurse into subdirectories. */
	    while (false !== ($file = $platform->readdir($dir))) {
		if (!preg_match('/^(\.|CVS)/', $file)) {
		    $ret = $this->getFileMetaData(
			$platform->realpath($path) . '/' . $file, $data, $pluginDir);
		    if ($ret) {
			return $ret->wrap(__FILE__, __LINE__);
		    }

		}
	    }
	} else if ($platform->is_file($path)) {
	    /* Get file contents for calculating hash. */
	    if (false === ($fileContents = $platform->file_get_contents($path))) {
		return GalleryCoreApi::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__, sprintf(
					    'Error reading [%s]', $path));
	    }

	    /* Get file meta data. */
	    $data['files'][$relativePath]['bytes'] = $platform->filesize($path);
	    $data['files'][$relativePath]['hash'] = md5($fileContents);
	    $data['files'][$relativePath]['packages'] = $this->getPackageNames($relativePath);

	    if (preg_match('/.*strings\.raw$/', $path)) {
		/* Get strings.raw revision. */
		list ($ret, $tag) = $this->_utilities->getFirstBytesFromFile($path, 128);
		if ($ret) {
		    return $ret->wrap(__FILE__, __LINE__);
		}

		list ($ret, $revision) = $this->_utilities->extractRevision($tag);
		if ($ret) {
		    return $ret->wrap(__FILE__, __LINE__);
		}
		$data['header']['stringsRevision'] = $revision;
	    }
	} else {
	    return GalleryCoreApi::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__,
					"Error reading path: $path");
	}

	return null;
    }

    /**
     * Determines which package(s) the specified file or directory should be in.
     *
     * @param string path relative to the plugin directory
     * @return array packages that apply to the specified file or directory.
     */
    function getPackageNames($path) {
	$packages = array();

	if (preg_match('/^test/', $path)) {
	    $packages[] = 'test';
	/* Match contents of locale and po directories except GNUmakefile and strings.raw */
	} else if (preg_match('/^(locale\/|po\/)[^G]/U', $path) && $path != 'po/strings.raw') {
	    if (preg_match('/locale\/(.._..)/U', $path, $localeId)) {
		$packages[] = 'lang-' . $localeId[1];
	    } else if (preg_match('/po\/(.._..)\.po/U', $path, $localeId)) {
		$packages[] = 'lang-' . $localeId[1];
	    }
	} else {
	    $packages[] = 'base';
	}

	return $packages;
    }

    /**
     * Gets a list of directories that are in the specified package.
     *
     * @param string package name
     * @return array directory list
     */
    function getDirectoriesInPackage($package) {
	$directories = array();

	foreach ($this->_data['directories'] as $dir => $directoryMetaData) {
	    if (in_array($package, $directoryMetaData['packages'])) {
		$directories[] = $dir;
	    }
	}
	return $directories;
    }

    /**
     * Gets a list of files that are in the specified package.
     *
     * @param string package name
     * @return array file list
     */
    function getFilesInPackage($package) {
	$files = array();
	foreach ($this->_data['files'] as $file => $fileMetaData) {
	    if (in_array($package, $fileMetaData['packages'])) {
		$files[] = $file;
	    }
	}
	return $files;
    }

    /**
     * Gets a list of packages that exist for this plugin.
     *
     * @return array package list
     */
    function getPackages() {
	$packageTypes = array();

	foreach ($this->_data['directories'] as $dir => $directoryMetaData) {
	    foreach ($this->_data['directories'][$dir]['packages'] as $package) {
		if (!in_array($package, $packageTypes)) {
		    $packageTypes[] = $package;
		}
	    }
	}

	return $packageTypes;
    }

    /**
     * Gets the timestamp of the last modified file under the specified directory.
     *
     * Runs the following CVS command in the plugin directory:
     * cvs log -N -r . | grep "^date: " | sort | tail -1 | cut -f2,3 -d' '
     *
     * @param string directory path
     * @return array object GalleryStatus a status code
     *		     string timestamp in 'yyyymmddhhmmss' format
     */
    function calculateBuildTimestamp($pluginDir) {
	global $gallery;

	$platform =& $gallery->getPlatform();
	if (!$platform->chdir($pluginDir)) {
	    return array(GalleryCoreApi::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__,
					      "Couldn't change to [$pluginDir]"),
			 null);
	}
	//$cvsOutput = `cvs log -N -r . | grep "^date: " | sort | tail -1 | cut -f2,3 -d' '`;
	$cvsOutput = "cvs log: Logging test/phpunit\n1970/04/11 13:13:00;";

	list ($ret, $buildTimestamp) = $this->_utilities->extractTimestamp($cvsOutput);
	if ($ret) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	return array(null, $buildTimestamp);
    }

    function getPluginVersion() {
	return $this->_pluginVersion;
    }

    function getPluginId() {
	return $this->_pluginId;
    }

    function getPluginDir() {
	return $this->_pluginDir;
    }

    function getStringsRevision() {
	return $this->_data['header']['stringsRevision'];
    }

    function getBuildTimestamp() {
	return $this->_data['header']['buildTimestamp'];
    }

    function getLanguageRevision($languageCode) {
	return $this->_data['languages'][$this->getStringsRevision()][$languageCode];
    }
}
?>
