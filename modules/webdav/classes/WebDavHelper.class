<?php
/*
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2007 Bharat Mediratta
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA  02110-1301, USA.
 */

GalleryCoreApi::requireOnce('modules/webdav/lib/HTTP/WebDAV/Server.php');

/* WebDAV status codes */
define('WEBDAV_STATUS_NO_XML_PARSER', 0x00000002);
define('WEBDAV_STATUS_METHOD_NOT_HANDLED', 0x00000004);
define('WEBDAV_STATUS_HTTPAUTH_MODULE_DISABLED', 0x00000008);
define('WEBDAV_STATUS_REWRITE_MODULE_DISABLED', 0x00000010);
define('WEBDAV_STATUS_CONNECT_RULE_DISABLED', 0x00000020);
define('WEBDAV_STATUS_MISSING_DAV_HEADERS', 0x00000040);
define('WEBDAV_STATUS_ALTERNATIVE_URL_HEADERS', 0x00000080);
define('WEBDAV_STATUS_BAD_REWRITE_PARSER', 0x00000100);
define('WEBDAV_STATUS_OPTIONS_RULE_DISABLED', 0x00000200);
define('WEBDAV_STATUS_ERROR_UNKNOWN', 0x80000000);

/* Gallery property namespace - RFC2518 18 */
define('WEBDAV_GALLERY_NAMESPACE', 'http://gallery2.org/dav/props/');

/**
 * WebDAV helper class.
 * @package WebDav
 * @subpackage Classes
 * @author Jack Bates <ms419@freezone.co.uk>
 * @version $Revision$
 * @static
 */
class WebDavHelper {

    /**
     * Check this module's configuration.
     * @return array object GalleryStatus a status code
     *               int WebDAV status code
     */
    function checkConfiguration() {
	global $gallery;
	$phpVm = $gallery->getPhpVm();
	$urlGenerator =& $gallery->getUrlGenerator();

	$code = 0x00000000;

	list ($ret, $moduleStatus) = GalleryCoreApi::fetchPluginList('module');
	if ($ret) {
	    return array($ret, null);
	}

	/*
	 * URL rewrite module must be enabled.  Check it regardless of missing DAV headers because
	 * it also implies the connect rule is disabled.  Check it before checking for missing DAV
	 * headers causes because it is a missing DAV headers cause.
	 */
	if (empty($moduleStatus['rewrite']['active'])) {
	    $code |= WEBDAV_STATUS_REWRITE_MODULE_DISABLED;
	} else {
	    list ($ret, $rewriteApi) = GalleryCoreApi::newFactoryInstance('RewriteApi');
	    if ($ret) {
		return array($ret, null);
	    }
	    if (!isset($rewriteApi)) {
		return array(GalleryCoreApi::error(ERROR_CONFIGURATION_REQUIRED), null);
	    }

	    list ($ret, $isCompatible) = $rewriteApi->isCompatibleWithApi(array(1, 1));
	    if ($ret) {
		return array($ret, null);
	    }
	    if (!$isCompatible) {
		return array(GalleryCoreApi::error(ERROR_CONFIGURATION_REQUIRED), null);
	    }

	    list ($ret, $activeRules) = $rewriteApi->fetchActiveRulesForModule('webdav');
	    if ($ret) {
		return array($ret, null);
	    }
	}

	/*
	 * Check for missing DAV headers causes first so we can show the error unknown warning if no
	 * causes are found.
	 */
	if (!WebDavHelper::checkDavHeaders($urlGenerator->generateUrl(
		array('controller' => 'webdav.WebDav'),
		array('forceFullUrl' => true,
		      'htmlEntities' => false)))) {

	    /* Already checked one cause: URL rewrite module disabled.  Check other causes. */
	    if (!WebDavHelper::checkDavHeaders($urlGenerator->generateUrl(
		    array('href' => 'modules/webdav/data/options/'),
		    array('forceDirect' => true,
			  'forceFullUrl' => true,
			  'htmlEntities' => false)))) {
		$code |= WEBDAV_STATUS_ALTERNATIVE_URL_HEADERS;
	    }

	    if (!empty($moduleStatus['rewrite']['active'])) {
		if ($rewriteApi->getParserType() != 'preGallery') {
		    $code |= WEBDAV_STATUS_BAD_REWRITE_PARSER;
		} else {
		    if (!in_array('options', $activeRules)) {
			$code |= WEBDAV_STATUS_OPTIONS_RULE_DISABLED;
		    }
		}
	    }

	    /* No causes found for missing DAV headers! */
	    if (!$code) {
		$code |= WEBDAV_STATUS_ERROR_UNKNOWN;
	    }

	    $code |= WEBDAV_STATUS_MISSING_DAV_HEADERS;
	}

	/*
	 * Must use short URL because most WebDAV clients don't support query strings.  Check it
	 * after checking for missing DAV headers causes so we can show the error unknown warning if
	 * no causes are found.
	 */
	if (!empty($moduleStatus['rewrite']['active'])) {
	    if (!in_array('connect', $activeRules)) {
		$code |= WEBDAV_STATUS_CONNECT_RULE_DISABLED;
	    }
	}

	/*
	 * HTTP auth module must be enabled to authenticate with WebDAV.  Check it after checking
	 * for missing DAV headers causes so we can show the error unknown warning if no causes are
	 * found.
	 */
	if (empty($moduleStatus['httpauth']['active'])) {
	    $code |= WEBDAV_STATUS_HTTPAUTH_MODULE_DISABLED;
	}

	/*
	 * Check that Gallery handles WebDAV request methods.  Check it after checking for missing
	 * DAV headers causes so we can show the error unknown warning if no causes are found.
	 */
	foreach (array('PROPFIND', 'PROPPATCH', 'MKCOL', 'DELETE', 'PUT', 'MOVE', 'LOCK', 'UNLOCK')
		as $requestMethod) {
	    if (!WebDavHelper::checkRequestMethod($requestMethod)) {
		if ($gallery->getDebug()) {
		    $gallery->debug('Error in WebDavHelper::checkConfiguration:'
			. ' this server doesn\'t pass ' . $requestMethod . ' requests to Gallery.');
		}
		$code |= WEBDAV_STATUS_METHOD_NOT_HANDLED;
	    }
	}

	/*
	 * The WebDAV library requires a PHP XML parser.  Check it after checking for missing DAV
	 * headers causes so we can show the error unknown warning if no causes are found.
	 */
	if (!$phpVm->extension_loaded('xml')) {
	    $code |= WEBDAV_STATUS_NO_XML_PARSER;
	}

	return array(null, $code);
    }

    /**
     * Check that Gallery handles WebDAV request methods.
     * @param string $requestMethod
     * @return boolean true if Gallery handles the request method
     */
    function checkRequestMethod($requestMethod) {
	global $gallery;
	$urlGenerator =& $gallery->getUrlGenerator();

	list ($status, $headers, $body) = GalleryCoreApi::requestWebPage(
	    $urlGenerator->generateUrl(array('view' => 'webdav.WebDavWorks'),
				       array('forceFullUrl' => true,
					     'htmlEntities' => false)), $requestMethod);
	if (!preg_match('/^HTTP\/[0-9]\.[0-9] 200/', $status)) {
	    return false;
	}
	if (trim($body) != 'PASS_WEBDAV') {
	    return false;
	}

	return true;
    }

    /**
     * Check that OPTIONS responses includes the DAV headers.
     * @param string $url
     * @return boolean true if OPTIONS responses include the DAV headers
     */
    function checkDavHeaders($url) {
	list ($status, $headers, $body) = GalleryCoreApi::requestWebPage($url, 'OPTIONS');
	if (!preg_match('/^HTTP\/[0-9]\.[0-9] 200/', $status)) {
	    return false;
	}
	if (empty($headers['Allow']) || $headers['Allow'] != 'OPTIONS,PROPFIND,PROPPATCH,MKCOL,GET'
		. ',HEAD,DELETE,PUT,MOVE,LOCK,UNLOCK') {
	    return false;
	}
	if (empty($headers['DAV']) || $headers['DAV'] != '1,2') {
	    return false;
	}
	if (empty($headers['MS-Author-Via']) || $headers['MS-Author-Via'] != 'DAV') {
	    return false;
	}

	return true;
    }

    /**
     * Returns a browser-specifc mount link for the given item.
     * @param int $itemId
     * @return array 'href' => string the mount URL
     *               'script' (optional) => string JavaScript to mount the item with WebDAV
     *               'attrs' => string additional link tag attributes
     */
    function getMountLink($itemId) {
	global $gallery;
	$urlGenerator =& $gallery->getUrlGenerator();

	$link = array();
	$params = array('view' => 'webdav.DownloadDavMount',
			   'itemId' => $itemId);
	$options = array();    

	$url = $urlGenerator->generateUrl(array('controller' => 'webdav.WebDav',
						'itemId' => $itemId),
					  array('forceFullUrl' => true,
						'forceSessionId' => false,
						'useAuthToken' => false));
	$link['attrs'] = 'style="behavior: url(#default#anchorClick)" folder="' . $url . '"';

	$userAgent = GalleryUtilities::getServerVar('HTTP_USER_AGENT');
	if (strpos($userAgent, 'MSIE') !== false) {
	    /*
	     * Mount with JavaScript only if using MSIE.  By default, dropdowns link to davmount
	     * resources.
	     */
	    $url = $urlGenerator->generateUrl(array('controller' => 'webdav.WebDav',
						    'itemId' => $itemId),
					      array('forceFullUrl' => true,
						    'htmlEntities' => false,
						    'forceSessionId' => false,
						    'useAuthToken' => false));
	    $link['script'] =
		"this.style.behavior = 'url(#default#httpFolder)'; this.navigate('$url')";
	}
	if (strpos($userAgent, 'Konqueror') !== false) {
	    /* Konqueror supports webdav:// URLs */
	    $params = array('controller' => 'webdav.WebDav',
			    'itemId' => $itemId);
	    $options = array('protocol' => 'webdav',
			     'forceSessionId' => false,
			     'useAuthToken' => false);
	}

	$link['href'] = $urlGenerator->generateUrl($params, $options);

	return $link;
    }

    /**
     * Get singleton WebDAV server library instance.
     *
     * If it didn't need path and baseUrl, we could eliminate and call library methods staticly.
     *
     * @return object WebDavServer instance
     */
    function &getWebDavServer() {
	static $webDavServer;
	if (!isset($webDavServer)) {
	    global $gallery;
	    $urlGenerator =& $gallery->getUrlGenerator();

	    $webDavServer = new WebDavServer();

	    /*
	     * Needed by HTTP_WebDAV_Server::copymove_request_helper and
	     * HTTP_WebDAV_Server::_check_if_header_conditions
	     */
	    $path = WebDavHelper::getRequestVariable('path', true, false);

	    $webDavServer->path = $path;
	    $webDavServer->baseUrl = parse_url(
		$urlGenerator->generateUrl(array('controller' => 'webdav.WebDav'),
					   array('forceFullUrl' => true,
						 'htmlEntities' => false,
						 'forceSessionId' => false,
						 'useAuthToken' => false)));
	}

	return $webDavServer;
    }

    /**
     * Version of GalleryUtilities::getRequestVariables which returns request variables from
     * WebDavHelper::_getRequestVariables instead of $_GET.  This is necessary because the values in
     * $_GET are URL decoded and once the value is URL decoded, it's impossible to distinguish '%2F'
     * from '/'.
     * @param string $key
     * @param boolean $addPrefix (optional) false to omit Gallery variable prefix
     * @param boolean $urlDecode (optional) false to not URL decode variable value
     * @return mixed value
     * @see GalleryUtilities::getRequestVariables
     */
    function getRequestVariable($key, $addPrefix=true, $urlDecode=true) {
	if ($addPrefix) {
	    $key = GALLERY_FORM_VARIABLE_PREFIX . $key;
	}

	$keyPath = preg_split('/[\[\]]/', $key, -1, PREG_SPLIT_NO_EMPTY);
	$value = GalleryUtilities::_internalGetRequestVariable(
	    $keyPath, WebDavHelper::_getRequestVariables());

	if (!isset($value)) {
	    return null;
	}

	/* Iterate over possibly structured value, recursively URL decoding */
	if ($urlDecode) {
	    $valueComponents = array();
	    $valueComponents[] =& $value;
	    while (count($valueComponents) > 0) {
		/* Get next value component by reference */
		$valueComponent =& $valueComponents[0];
		array_shift($valueComponents);

		if (is_array($valueComponent)) {
		    foreach ($valueComponent as $subKey => $subValue) {
			$valueComponents[] =& $valueComponent[$subKey];
		    }

		    continue;
		}

		$valueComponent = urldecode($valueComponent);
	    }
	}

	return $value;
    }

    /**
     * Return structured array of request variables parsed from the current request URL.  This is
     * necessary because the values in $_GET are URL decoded and once the value is URL decoded, it's
     * impossible to distinguish '%2F' from '/'.  Cache the array for multiple calls in the same
     * request.  Return by reference so it can be reset by unit tests.
     * @return array structured request variables
     * @access private
     */
    function &_getRequestVariables() {
	static $params;
	if (!isset($params)) {
	    $params = array();
	    if (empty($_SERVER['QUERY_STRING'])) {
		return $params;
	    }

	    /* Use $_SERVER instead of GalleryUtilities::getServerVar to avoid sanitizing */
	    $queryComponents = preg_split(
		'/&/', $_SERVER['QUERY_STRING'], -1, PREG_SPLIT_NO_EMPTY);
	    foreach ($queryComponents as $queryComponent) {
		list ($key, $value) = explode('=', $queryComponent, 2);
		$keyPath = preg_split('/[\[\]]/', urldecode($key), -1, PREG_SPLIT_NO_EMPTY);
		WebDavHelper::_setByKeyPath($params, $keyPath, $value);
	    }
	}

	return $params;
    }

    /**
     * Assign a value to an array where the key is an array of keys describing nested arrays.
     * @param array $array
     * @param array $keyPath array of keys
     * @param mixed $value
     * @access private
     * @todo Think of a better name for this function
     */
    function _setByKeyPath(&$array, $keyPath, $value) {
	while (count($keyPath) > 1) {
	    $key = array_shift($keyPath);

	    /* Ensure the next nested value is an array */
	    if (empty($array[$key]) || !is_array($array[$key])) {
		$array[$key] = array();
	    }

	    $array =& $array[$key];
	}

	$key = array_shift($keyPath);
	$array[$key] =& $value;
    }

    /**
     * Remove the last component of a WebDAV path.
     * @param string $path
     * @return string parent path
     */
    function getParentPath($path) {
	return preg_replace('/((?<=[^\/])\/*)?[^\/]+\/*$/', '', $path);
    }

    /**
     * Version of GalleryCoreApi::fetchItemIdByPath which looks up item ids by WebDAV paths.  This
     * will URL decode path components separated by '/'.
     * @param string $path
     * @return array object GalleryStatus a status code
     *               int item id
     * @see GalleryCoreApi::fetchItemIdByPath
     */
    function fetchItemIdByPath($path) {
	list ($ret, $itemId) = GalleryCoreApi::getDefaultAlbumId();
	if ($ret) {
	    return array($ret, null);
	}

	/* Iterate over path components */
	foreach (preg_split('/\//', $path, -1, PREG_SPLIT_NO_EMPTY) as $pathComponent) {
	    list ($ret, $itemId) = WebDavHelper::fetchChildIdByPathComponent(
		$itemId, urldecode($pathComponent));
	    if ($ret) {
		return array($ret, null);
	    }
	}

	return array(null, $itemId);
    }

    /**
     * Version of GalleryCoreApi::fetchChildIdByPathComponent which looks up child ids by WebDAV
     * path component.
     * @param int $parentId
     * @param string $pathComponent
     * @return array object GalleryStatus a status code
     *               int item id
     * @see GalleryCoreApi::fetchChildIdByPathComponent
     */
    function fetchChildIdByPathComponent($parentId, $pathComponent) {
	global $gallery;
	$platform =& $gallery->getPlatform();

	/* Look up child id by legal path component */
	$legalPathComponent = $platform->legalizePathComponent($pathComponent);
	list ($ret, $itemId) = GalleryCoreApi::fetchChildIdByPathComponent(
	    $parentId, $legalPathComponent);
	if ($ret) {
	    return array($ret, null);
	}

	/* Check if the item has a WebDAV path component */
	list ($ret, $webDavPathComponent) = GalleryCoreApi::getPluginParameter(
	    'module', 'webdav', 'pathComponent', $itemId);
	if ($ret) {
	    return array($ret, null);
	}
	if ((empty($webDavPathComponent) && $pathComponent != $legalPathComponent)
		|| (!empty($webDavPathComponent) && $pathComponent != $webDavPathComponent)) {
	    return array(GalleryCoreApi::error(ERROR_MISSING_OBJECT, __FILE__, __LINE__,
					       "Parent $parentId path $pathComponent"), null);
	}

	return array(null, $itemId);
    }

    /**
     * Get active WebDAV locks at specified path.
     * @param string $path
     * @param boolean $getDescendentsLocks (optional) also get locks at any descendant path
     * @return array object GalleryStatus a status code
     *               array active WebDAV locks (scope, type, depth, owner, expires, token, path)
     */
    function getLocks($path, $getDescendentsLocks=false) {
	global $gallery;

	/* We haven't done any database calls yet, so GallerySqlFragment isn't defined */
	GalleryCoreApi::requireOnce('modules/core/classes/GalleryStorage.class');

	/* Remove stale locks */
	$ret = GalleryCoreApi::removeMapEntry('WebDavLockMap',
	    array('expires' => new GallerySqlFragment('< ?', time())));
	if ($ret) {
	    return array($ret, null);
	}

	$data = array();
	$query = '
	    SELECT
	      [WebDavLockMap::depth],
	      [WebDavLockMap::owner],
	      [WebDavLockMap::expires],
	      [WebDavLockMap::token],
	      [WebDavLockMap::path]
	    FROM
	      [WebDavLockMap]
	    WHERE';

	/*
	 * Hacks to get ancestors' and descendants' locks will disappear with MPTT -
	 * http://codex.gallery2.org/index.php/Gallery2:Modified_Preorder_Tree_Traversal
	 */
	if ($getDescendentsLocks) {
	    $query .= '
		  [WebDavLockMap::path] LIKE ?';
	    $data[] = $path . '%';
	} else {
	    $query .= '
		  [WebDavLockMap::path] = ?';
	    $data[] = $path;
	}

	/* Get ancestors' locks */
	$ancestorPaths = array();
	$pathComponents = preg_split('/\//', $path, -1, PREG_SPLIT_NO_EMPTY);
	while (array_pop($pathComponents) !== null) {
	    $ancestorPaths[] = implode('/', $pathComponents);
	}

	if (!empty($ancestorPaths)) {
	    $query .= '
		OR
		  ([WebDavLockMap::path] IN (' . GalleryUtilities::makeMarkers($ancestorPaths)
		  . ') AND [WebDavLockMap::depth] = \'infinity\')';
	    $data = array_merge($data, $ancestorPaths);
	}

	list ($ret, $results) = $gallery->search($query, $data);
	if ($ret) {
	    return array($ret, null);
	}

	$locks = array();
	while (($result = $results->nextResult()) !== false) {
	    $locks[] = array('scope' => 'exclusive',
			     'type' => 'write',
			     'depth' => $result[0],
			     'owner' => $result[1],
			     'expires' => (int)$result[2],
			     'token' => $result[3],
			     'path' => $result[4]);
	}

	return array(null, $locks);
    }

    /**
     * Get active locks at specified path or any descendant path.
     * @see WebDavHelper::getLocks
     */
    function getDescendentsLocks($path) {
	return WebDavHelper::getLocks($path, true);
    }

    /**
     * Check if there are no active locks at the specified path, or the request matches the token of
     * the active lock.
     * @param string $path
     * @return boolean no active locks or the request matches the active lock
     */
    function checkLocks($path) {
	$webDavServer =& WebDavHelper::getWebDavServer();

        list ($ret, $locks) = WebDavHelper::getLocks($path);
	if ($ret) {
	    return $ret;
	}

	if (!empty($locks) && !$webDavServer->check_locks_helper($locks, $path)) {
	    WebDavServer::setResponseStatus('423 Locked');
	    return GalleryCoreApi::error(ERROR_LOCK_IN_USE);
	}
    }

    /**
     * OPTIONS handler.
     * @see HTTP_WebDAV_Server::options
     */
    function options() {
	/* TODO: COPY not implemented */
	GalleryUtilities::setResponseHeader(
	    'Allow: OPTIONS,PROPFIND,PROPPATCH,MKCOL,GET,HEAD,DELETE,PUT,MOVE,LOCK,UNLOCK');
	GalleryUtilities::setResponseHeader('DAV: 1,2');
	GalleryUtilities::setResponseHeader('Content-Length: 0');
	GalleryUtilities::setResponseHeader('MS-Author-Via: DAV');
    }

    /**
     * PROPFIND request helper.
     *
     * Wrapper around HTTP_WebDAV_Server::propfind_request_helper which prepares data-structures
     * from PROPFIND requests.
     *
     * @return array object GalleryStatus a status code
     *               array WebDAV library options
     *               int maximum depth of descendant paths
     * @see HTTP_WebDAV_Server::propfind_request_helper
     */
    function propfindRequestHelper() {
	$webDavServer =& WebDavHelper::getWebDavServer();

	if (!$webDavServer->propfind_request_helper($webDavOptions)) {
	    /* WebDAV library found error in the request */
	    return array(GalleryCoreApi::error(ERROR_UNKNOWN), null, null);
	}

	return array(null, $webDavOptions, $webDavOptions['depth']);
    }

    /**
     * PROPFIND response helper.
     *
     * Wrapper around HTTP_WebDAV_Server::propfind_response_helper which formats PROPFIND responses.
     *
     * @param array $webDavOptions WebDAV library options
     * @param array $files files for WebDAV response (path, props)
     * @param array $namespaces namespaces for WebDAV response (URI => prefix)
     * @see HTTP_WebDAV_Server::propfind_response_helper
     */
    function propfindResponseHelper($webDavOptions, $files, $namespaces) {
	$webDavServer =& WebDavHelper::getWebDavServer();
	$webDavOptions['namespaces'] = $namespaces;
	$webDavServer->propfind_response_helper($webDavOptions, $files);
    }

    /**
     * PROPFIND handler.
     * @return object GalleryStatus status code
     */
    function propfind() {
	/* Prepare data-structure from PROPFIND request */
	list ($ret, $webDavOptions, $depth) = WebDavHelper::propfindRequestHelper();
	if ($ret) {
	    return $ret;
	}

	$path = WebDavHelper::getRequestVariable('path', true, false);

	list ($ret, $itemId) = WebDavHelper::fetchItemIdByPath($path);
	if ($ret) {
	    return $ret;
	}

	list ($ret, $item) = GalleryCoreApi::loadEntitiesById($itemId);
	if ($ret) {
	    return $ret;
	}

	$files = array();
	$ret = WebDavHelper::_propfindFiles($item, $path, $depth, $files);
	if ($ret) {
	    return $ret;
	}

	$namespaces = array(WEBDAV_GALLERY_NAMESPACE => 'G');

	/* Format PROPFIND response */
	$ret = WebDavHelper::propfindResponseHelper($webDavOptions, $files, $namespaces);
	if ($ret) {
	    return $ret;
	}
    }

    /**
     * PROPFIND recursive function.
     *
     * Builds file arrays (path, props) from items until depth is exhausted.
     *
     * Could be done iteratively, but waiting for MPTT for the ultimate solution -
     * http://codex.gallery2.org/index.php/Gallery2:Modified_Preorder_Tree_Traversal
     *
     * @param object GalleryItem $item
     * @param string $path
     * @param int $depth maximum depth of descendant paths
     * @param array $files files for WebDAV response (path, props)
     * @return object GalleryStatus a status code
     * @access private
     */
    function _propfindFiles($item, $path, $depth, &$files) {
	/* Verify that the provided object implements the required methods */
	foreach (array('creationTimestamp', 'title', 'modificationTimestamp', 'pathComponent')
		as $memberName) {
	    if (!method_exists($item, 'get' . $memberName)) {
		return GalleryCoreApi::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__,
			"Item object does not implement a getter for '$memberName'");
	    }
	}

	$file = array();
	$file['path'] = $path;
	$file['props'] = array();

	/* Build standard DAV: properties */
	$file['props'][] = WebDavServer::mkprop('creationdate', $item->getCreationTimestamp());
	$displayName = $item->getTitle();
	if (empty($displayName)) {
	    $displayName = $item->getPathComponent();
	}
	$file['props'][] = WebDavServer::mkprop('displayname', $displayName);
	$file['props'][] = WebDavServer::mkprop(
	    'getlastmodified', $item->getModificationTimestamp());

	/*
	 * Support exclusive write locks.
	 *
	 * Any DAV compliant resource that supports the LOCK method MUST support the supportedlock
	 * property.
	 */
	$file['props'][] = WebDavServer::mkprop(
	    'supportedlock', array(array('scope' => 'exclusive', 'type' => 'write')));

	/*
	 * WebDavHelper::getLocks is potentially expensive.  Could optimize this if we knew
	 * $webDavOptions['props'] didn't contain 'lockdiscovery' or 'allprop'.
	 */
	list ($ret, $locks) = WebDavHelper::getLocks($path);
	if ($ret) {
	    return $ret;
	}

	$file['props'][] = WebDavServer::mkprop('lockdiscovery', $locks);

	if ($item->isContainer()) {
	    if (!empty($path)) {
		$file['path'] = '/' . trim($path, '/') . '/';
	    }

	    $file['props'][] = WebDavServer::mkprop('getcontentlength', 0);
	    $file['props'][] = WebDavServer::mkprop('getcontenttype', 'httpd/unix-directory');
	    $file['props'][] = WebDavServer::mkprop('resourcetype', 'collection');
	} else {
	    $size = 0;
	    if (method_exists($item, 'getSize')) {
		$size = $item->getSize();
	    }
	    $mimeType = 'application/unknown';
	    if (method_exists($item, 'getMimeType')) {
		$mimeType = $item->getMimeType();
	    }
	    $file['props'][] = WebDavServer::mkprop('getcontentlength', $size);
	    $file['props'][] = WebDavServer::mkprop('getcontenttype', $mimeType);
	    $file['props'][] = WebDavServer::mkprop('resourcetype', null);
	}

	/* Build Gallery properties */
	if (method_exists($item, 'getClassName')) {
	    list ($ret, $memberInfo) = GalleryCoreApi::getExternalAccessMemberList(
		$item->getClassName());
	    if ($ret) {
		return $ret;
	    }

	    /* Keep track of the properties that we add to prevent repetition */
	    $defaultMembers = array('pathComponent', 'creationTimestamp', 'title',
				    'modificationTimestamp', 'mimeType', 'size');
	    foreach ($memberInfo as $memberName => $accessInfo) {
		$getter = 'get' . $memberName;
		/* Only show properties that are not intended for internal use only */
		if ($accessInfo['read'] && !in_array($memberName, $defaultMembers)
			&& method_exists($item, $getter)) {
		    $value = $item->$getter();
		    /* Ignore array valued properties */
		    if (!is_array($value) && !is_object($value)) {
			$file['props'][] = WebDavServer::mkprop(WEBDAV_GALLERY_NAMESPACE,
								$memberName, $value);
		    }
		}
	    }
	}

	$files[] = $file;

	if ($depth <= 0) {
	    return;
	}

	list ($ret, $childIds) = GalleryCoreApi::fetchChildItemIds($item);
	if ($ret) {
	    return $ret;
	}

	if (empty($childIds)) {
	    return;
	}

	list ($ret, $childItems) = GalleryCoreApi::loadEntitiesById($childIds);
	if ($ret) {
	    return $ret;
	}

	foreach ($childItems as $childItem) {
	    list ($ret, $pathComponent) = GalleryCoreApi::getPluginParameter(
		'module', 'webdav', 'pathComponent', $childItem->getId());
	    if ($ret) {
		return $ret;
	    }
	    if (empty($pathComponent)) {
		$pathComponent = $childItem->getPathComponent();
	    }

	    /*
	     * URL encode because WebDAV paths may contain special characters, in which case it's
	     * impossible to distinguish '/' in path components from the path separator.  Use
	     * rawurlencode to encode ' ' as '%20' instead of '+'.
	     */
	    $childPath = rawurlencode($pathComponent);
	    if (!empty($path)) {
		$childPath = '/' . trim($path, '/') . '/' . $childPath;
	    }

	    $ret = WebDavHelper::_propfindFiles($childItem, $childPath, $depth - 1, $files);
	    if ($ret) {
		return $ret;
	    }
	}

	return null;
    }

    /**
     * PROPPATCH request helper.
     *
     * Wrapper around HTTP_WebDAV_Server::proppatch_request_helper which prepares data-structures
     * from PROPPATCH requests.
     *
     * @return array object GalleryStatus a status code
     *               array WebDAV library options
     *               array properties to set (ns => namespace, name => name, val => value)
     * @see HTTP_WebDAV_Server::proppatch_request_helper
     */
    function proppatchRequestHelper() {
	$webDavServer =& WebDavHelper::getWebDavServer();

	if (!$webDavServer->proppatch_request_helper($webDavOptions)) {
	    /* WebDAV library found error in the request */
	    return array(GalleryCoreApi::error(ERROR_UNKNOWN), null, null);
	}

	return array(null, $webDavOptions, $webDavOptions['props']);
    }

    /**
     * PROPPATCH response helper.
     *
     * Wrapper around HTTP_WebDAV_Server::proppatch_response_helper which formats PROPPATCH
     * responses.
     *
     * @param array $webDavOptions WebDAV library options
     * @param string $path
     * @param array $props properties set (ns => namespace,
     					   name => name,
					   val => value,
					   status => status)
     * @param array $namespace namespaces for WebDAV response (URI => prefix)
     * @see HTTP_WebDAV_Server::proppatch_response_helper
     */
    function proppatchResponseHelper($webDavOptions, $path, $props, $namespaces) {
	$webDavServer =& WebDavHelper::getWebDavServer();
	$webDavOptions['path'] = $path;
	$webDavOptions['props'] = $props;
	$webDavOptions['namespaces'] = $namespaces;
	$webDavServer->proppatch_response_helper($webDavOptions);
    }

    /**
     * PROPPATCH handler.
     * @return object GalleryStatus a status code
     */
    function proppatch() {
	$path = WebDavHelper::getRequestVariable('path', true, false);

	/* Check resource is not locked */
	$ret = WebDavHelper::checkLocks($path);
	if ($ret) {
	    return $ret;
	}

	list ($ret, $itemId) = WebDavHelper::fetchItemIdByPath($path);
	if ($ret) {
	    return $ret;
	}

	list ($ret, $item) = GalleryCoreApi::loadEntitiesById($itemId);
	if ($ret) {
	    return $ret;
	}

	/* Prepare data-structure from PROPPATCH request */
	list ($ret, $webDavOptions, $props) = WebDavHelper::proppatchRequestHelper();
	if ($ret) {
	    return $ret;
	}

	list ($ret, $lockId) = GalleryCoreApi::acquireWriteLock($itemId);
	if ($ret) {
	    return $ret;
	}

	$ret = WebDavHelper::_setItemProps($item, $props);
	if ($ret) {
	    GalleryCoreApi::releaseLocks($lockId);
	    return $ret;
	}

	$ret = $item->save();
	if ($ret) {
	    GalleryCoreApi::releaseLocks($lockId);
	    return $ret;
	}

	$ret = GalleryCoreApi::releaseLocks($lockId);
	if ($ret) {
	    return $ret;
	}

	$namespaces = array(WEBDAV_GALLERY_NAMESPACE => 'G');

	/* Format PROPPATCH response */
	$ret = WebDavHelper::proppatchResponseHelper($webDavOptions, $path, $props, $namespaces);
	if ($ret) {
	    return $ret;
	}
    }

    /**
     * Set item properties.
     * @param object GalleryItem reference $item
     * @param array reference $propos DAV file properties
     * @return object GalleryStatus a status code
     * @access private
     */
    function _setItemProps(&$item, &$props) {
	if (!method_exists($item, 'getClassName')) {
	    return GalleryCoreApi::error(ERROR_BAD_PARAMETER);
	}

	list ($ret, $memberInfo) = GalleryCoreApi::getExternalAccessMemberList(
	    $item->getClassName());
	if ($ret) {
	    return $ret;
	}

	foreach ($props as $key => $prop) {
	    $name = $prop['name'];
	    if ($prop['ns'] == 'DAV:') {
		if ($prop['name'] == 'displayname') {
		    $name = 'title';
		    /* Want to support any other DAV: properties? */
		} else {
		    $props[$key]['status'] = '403 Forbidden';
		    continue;
		}
	    } else if ($prop['ns'] != WEBDAV_GALLERY_NAMESPACE) {
		$props[$key]['status'] = '403 Forbidden';
		continue;
	    }

	    $setter = 'set' . $name;
	    if (!isset($memberInfo[$name])|| !$memberInfo[$name]['write']
		    || !method_exists($item, $setter)) {
		$props[$key]['status'] = '403 Forbidden';
		continue;
	    }

	    $item->$setter($prop['value']);
	}

	return null;
    }

    /**
     * MKCOL handler.
     * @return object GalleryStatus a status code
     */
    function mkcol() {
	/* Body parsing not yet supported */
	if (GalleryUtilities::getServerVar('CONTENT_LENGTH')) {
	    /*
	     * 415 (Unsupported Media Type) - The server does not support the request type of the
	     * body.
	     */
	    WebDavServer::setResponseStatus('415 Unsupported Media Type');
	    return GalleryCoreApi::error(ERROR_BAD_PARAMETER);
	}

	$path = WebDavHelper::getRequestVariable('path', true, false);

	list ($ret, $itemId) = WebDavHelper::fetchItemIdByPath($path);
	if ($ret && !($ret->getErrorCode() & ERROR_MISSING_OBJECT)) {
	    return $ret;
	}
	if (!$ret) {
	    /*
	     * 405 (Method Not Allowed) - MKCOL can only be executed on a deleted/non-existent
	     * resource.
	     */
	    WebDavServer::setResponseStatus('405 Method Not Allowed');
	    return GalleryCoreApi::error(ERROR_COLLISION);
	}

	$pathComponent = urldecode(basename($path));
	$parentPath = WebDavHelper::getParentPath($path);

	list ($ret, $parentId) = WebDavHelper::fetchItemIdByPath($parentPath);
	if ($ret) {
	    if ($ret->getErrorCode() & ERROR_MISSING_OBJECT) {
		/*
		 * 409 (Conflict) - A resource cannot be created at the destination until one or
		 * more intermediate collections have been created.
		 */
		WebDavServer::setResponseStatus('409 Conflict');
	    }

	    return $ret;
	}

	/* Make sure we have permission do edit this item */
	$ret = GalleryCoreApi::assertHasItemPermission($parentId, 'core.addAlbumItem');
	if ($ret) {
	    return $ret;
	}

	list ($ret, $lockIds[]) = GalleryCoreApi::acquireReadLock($parentId);
	if ($ret) {
	    return $ret;
	}

	list ($ret, $album) = GalleryCoreApi::createAlbum(
	    $parentId, $pathComponent, $pathComponent, '', '', '');
	if ($ret) {
	    if ($ret->getErrorCode() & ERROR_ILLEGAL_CHILD) {

		/*
		 * 403 (Forbidden) - This indicates at least one of two conditions: 1) the server
		 * does not allow the creation of collections at the given location in its
		 * namespace, or 2) the parent collection of the Request-URI exists but cannot
		 * accept members.
		 */
		WebDavServer::setResponseStatus('403 Forbidden');
	    }

	    GalleryCoreApi::releaseLocks($lockIds);
	    return $ret;
	}
	if (!isset($album)) {
	    GalleryCoreApi::releaseLocks($lockIds);
	    return GalleryCoreApi::error(ERROR_MISSING_OBJECT);
	}

	/* Add user permission */
	$ret = GalleryCoreApi::addUserPermission(
	    $album->getId(), $album->getOwnerId(), 'core.all', false);
	if ($ret) {
	    GalleryCoreApi::releaseLocks($lockIds);
	    return $ret;
	}

	/* Release all locks */
	$ret = GalleryCoreApi::releaseLocks($lockIds);
	if ($ret) {
	    return $ret;
	}

	/* Set WebDAV path component */
	if ($album->getPathComponent() != $pathComponent) {
	    $ret = GalleryCoreApi::setPluginParameter(
		'module', 'webdav', 'pathComponent', $pathComponent, $album->getId());
	    if ($ret) {
		return $ret;
	    }
	}

	/*
	 * 201 (Created) - The collection or structured resource was created in its entirety.
	 */
	WebDavServer::setResponseStatus('201 Created');
    }

    /**
     * DELETE helper.
     *
     * For an array of item ids, delete the items if not the root album and the user has permission.
     *
     * Copied from ItemDeleteController::handleRequest for consistancy.  Maybe eventually should go
     * in ItemDeleteController::requestHelper or a GalleryCoreApi method.
     *
     * @param array $itemIds ids of items to delete
     * @return array object GalleryStatus a status code
     *               int number of items deleted
     * @see ItemDeleteController::handleRequest
     */
    function deleteHelper($itemIds) {
        if (!is_array($itemIds)) {
	    $itemIds = array($itemIds);
	}

	/* Cache permissions in memory */
	$ret = GalleryCoreApi::studyPermissions($itemIds);
	if ($ret) {
	    return array($ret, null);
	}

	/* Get the root id, so we don't try to delete it */
	list ($ret, $rootId) = GalleryCoreApi::getDefaultAlbumId();
	if ($ret) {
	    return array($ret, null);
	}

	foreach ($itemIds as $itemId) {
	    /* Make sure we have permission to delete this item */
	    $ret = GalleryCoreApi::assertHasItemPermission($itemId, 'core.delete');
	    if ($ret) {
		return array($ret, null);
	    }

	    /* Make sure we're not deleting the root album */
	    if ($itemId == $rootId) {
		return array(GalleryCoreApi::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__,
		    "Can't delete the root album"), null);
	    }
	}

	/* If we're still here then all are deletable */
	$count = 0;
	foreach ($itemIds as $itemId) {
	    $ret = GalleryCoreApi::deleteEntityById($itemId);
	    if ($ret) {
		return array($ret, null);
	    }

	    $count++;
	}

	return array(null, $count);
    }

    /**
     * DELETE handler.
     * @return object GalleryStatus a status code
     */
    function delete() {
	/* RFC2518 9.2 last paragraph */
	if (GalleryUtilities::getServerVar('HTTP_DEPTH') != null
		&& GalleryUtilities::getServerVar('HTTP_DEPTH') != 'infinity') {
	    WebDavServer::setResponseStatus('400 Bad Request');
	    return GalleryCoreApi::error(ERROR_BAD_PARAMETER);
	}

	$path = WebDavHelper::getRequestVariable('path', true, false);

	/* Check resource is not locked */
	$ret = WebDavHelper::checkLocks($path);
	if ($ret) {
	    return $ret;
	}

	list ($ret, $itemId) = WebDavHelper::fetchItemIdByPath($path);
	if ($ret) {
	    return $ret;
	}

	list ($ret, $item) = GalleryCoreApi::loadEntitiesById($itemId);
	if ($ret) {
	    return $ret;
	}

	list ($ret, $count) = WebDavHelper::deleteHelper($itemId);
	if ($ret) {
	    return $ret;
	}

	/* What do we do if we weren't successful?  No thumbnail, I guess. */
	list ($ret, $success) = GalleryCoreApi::guaranteeAlbumHasThumbnail($item->getParentId());
	if ($ret) {
	    return $ret;
	}

	WebDavServer::setResponseStatus('204 No Content');
	return null;
    }

    /**
     * PUT request helper.
     *
     * Wrapper around HTTP_WebDAV_Server::put_request_helper which prepares data-structures from PUT
     * requests.
     *
     * @return array object GalleryStatus a status code
     *               array WebDAV library options
     *               resource request body file handle
     *               string request content type
     * @see HTTP_WebDAV_Server::put_request_helper
     */
    function putRequestHelper() {
	$webDavServer =& WebDavHelper::getWebDavServer();

	if (!$webDavServer->put_request_helper($webDavOptions)) {
	    /* WebDAV library found error in the request */
	    return array(GalleryCoreApi::error(ERROR_UNKNOWN), null, null, null);
	}

	return array(null, $webDavOptions,
		     $webDavOptions['stream'],
		     $webDavOptions['content_type']);
    }

    /**
     * PUT response helper.
     *
     * Wrapper around HTTP_WebDAV_Server::put_response_helper which formats PUT responses.
     *
     * @param array $webDavOptions WebDAV library options
     * @param resource $stream destination file handle
     * @see HTTP_WebDAV_Server::put_response_helper
     */
    function putResponseHelper($webDavOptions, $stream) {
	$webDavServer =& WebDavHelper::getWebDavServer();
	$webDavOptions['new'] = false;
	$webDavServer->put_response_helper($webDavOptions, $stream);
    }

    /**
     * COPY / MOVE request helper.
     *
     * Wrapper around HTTP_WebDAV_Server::copymove_request_helper which prepates data-structures
     * from COPY / MOVE requests.
     *
     * @return array object GalleryStatus a status code
     *               array WebDAV library options
     *               int maximum depth of descendant paths
     *               boolean overwrite items at destination path
     *               string destination path
     * @see HTTP_WebDAV_Server::copymove_request_helper
     */
    function copyMoveRequestHelper() {
	global $gallery;
	$platform =& $gallery->getPlatform();
	$webDavServer =& WebDavHelper::getWebDavServer();

	/* Body parsing not yet supported */
	if (GalleryUtilities::getServerVar('CONTENT_LENGTH')) {
	    /*
	     * 415 (Unsupported Media Type) - The server does not support the request type of the
	     * body.
	     */
	    WebDavServer::setResponseStatus('415 Unsupported Media Type');
	    return array(GalleryCoreApi::error(ERROR_BAD_PARAMETER), null, null, null, null);
	}

	if (!$webDavServer->copymove_request_helper($webDavOptions)) {
	    /* WebDAV library found error in the request */
	    return array(GalleryCoreApi::error(ERROR_UNKNOWN), null, null, null, null);
	}

	/* Copying to remote servers not yet supported */
	if (isset($webDavOptions['dest_url'])) {
	    /*
	     * 502 (Bad Gateway) - This may occur when the destination is on another server and the
	     * destination server refuses to accept the resource.
	     */
	    WebDavServer::setResponseStatus('502 Bad Gateway');
	    return array(GalleryCoreApi::error(ERROR_BAD_PARAMETER), null, null, null, null);
	}

	return array(null, $webDavOptions,
		     $webDavOptions['depth'],
		     $webDavOptions['overwrite'],
		     $webDavOptions['dest']);
    }

    /**
     * Validate MOVE requests.
     *
     * Copied from ItemMoveController::handleRequest for consistancy.  Maybe eventually should go in
     * ItemMoveController::validateRequest or a GalleryCoreApi method.
     *
     * @param array $items items to move
     * @param object GalleryAlbumItem $newParent
     * @return array object GalleryStatus a status code
     *               array error strings
     * @see ItemMoveController::handleRequest
     */
    function moveValidateHelper($items, $newParent) {
        if (!is_array($items)) {
	    $items = array($items);
	}

	$error = array();

	list ($ret, $permissions) = GalleryCoreApi::getPermissions($newParent->getId());
	if ($ret) {
	    return array($ret, null);
	}

	$canAddItem = isset($permissions['core.addDataItem']);
	$canAddAlbum = isset($permissions['core.addAlbumItem']);
	if (!$canAddAlbum && !$canAddItem) {
	    $error[] = 'form[error][destination][permission]';
	}

	if (!GalleryUtilities::isA($newParent, 'GalleryAlbumItem')) {
	    /* The view should never let this happen */
	    return array(GalleryCoreApi::error(ERROR_BAD_DATA_TYPE), null);
	}

	/* Load destination parent ids: we don't want recursive moves */
	list ($ret, $newParentAncestorIds) = GalleryCoreApi::fetchParentSequence(
	    $newParent->getId());
	if ($ret) {
	    return array($ret, null);
	}
	$newParentAncestorIds[] = $newParent->getId();

	foreach ($items as $item) {
	    /* Can't move into a tree that is included in the source */
	    if (in_array($item->getId(), $newParentAncestorIds)) {
		$error[] = 'form[error][source][' . $item->getId() . '][selfMove]';
		continue;
	    }

	    list ($ret, $permissions) = GalleryCoreApi::getPermissions($item->getId());
	    if ($ret) {
		return array($ret, null);
	    }

	    /* Can we delete this item from here? */
	    if (!isset($permissions['core.delete'])) {
		$error[] = 'form[error][source][' . $item->getId() . '][permission][delete]';
	    }

	    /* Check if the destination allows this source to be added */
	    if (GalleryUtilities::isA($item, 'GalleryDataItem')) {
		if (!$canAddItem) {
		    $error[] =
			'form[error][source][' . $item->getId() . '][permission][addDataItem]';
		}
	    } else if (GalleryUtilities::isA($item, 'GalleryAlbumItem')) {
		if (!$canAddAlbum) {
		    $error[] =
			'form[error][source][' . $item->getId() . '][permission][addAlbumItem]';
		}
	    } else {
		/* The view should never let this happen */
		return array(GalleryCoreApi::error(ERROR_BAD_DATA_TYPE), null);
	    }
	}

	return array(null, $error);
    }

    /**
     * MOVE handler.
     *
     * Rename an item, change its parent, or both.
     *
     * @return object GalleryStatus a status code
     */
    function move() {
	$path = WebDavHelper::getRequestVariable('path', true, false);

	/* Check source is not locked */
	$ret = WebDavHelper::checkLocks($path);
	if ($ret) {
	    return $ret;
	}

	/* Validate before deleting a conflicting item */
	list ($ret, $itemId) = WebDavHelper::fetchItemIdByPath($path);
	if ($ret) {
	    return $ret;
	}

	/* Get the root id, so we don't try to move it */
	list ($ret, $rootId) = GalleryCoreApi::getDefaultAlbumId();
	if ($ret) {
	    return $ret;
	}
	if ($itemId == $rootId) {
	    return GalleryCoreApi::error(ERROR_BAD_PARAMETER);
	}

	list ($ret, $item) = GalleryCoreApi::loadEntitiesById($itemId);
	if ($ret) {
	    return $ret;
	}

	/* Prepare data-structure from MOVE request */
	list ($ret, $webDavOptions, $depth, $overwrite, $newPath) =
	    WebDavHelper::copyMoveRequestHelper();
	if ($ret) {
	    return $ret;
	}

	/* Check destination is not locked */
	$ret = WebDavHelper::checkLocks($newPath);
	if ($ret) {
	    return $ret;
	}

	if (GalleryUtilities::isA($item, 'GalleryAlbumItem') && $depth != 'infinity') {
	    /*
	     * The MOVE method on a collection MUST act as if a "Depth: infinity" header was used on
	     * it.  A client MUST NOT submit a Depth header on a MOVE on a collection with any value
	     * but "infinity".
	     */
	    WebDavServer::setResponseStatus('400 Bad Request');
	    return GalleryCoreApi::error(ERROR_BAD_PARAMETER);
	}

	$pathComponent = urldecode(basename($path));
	$newPathComponent = urldecode(basename($newPath));

	$parentPath = WebDavHelper::getParentPath($path);
	$newParentPath = WebDavHelper::getParentPath($newPath);
	if ($newParentPath != $parentPath) {
	    list ($ret, $newParentId) = WebDavHelper::fetchItemIdByPath($newParentPath);
	    if ($ret) {
		if ($ret->getErrorCode() & ERROR_MISSING_OBJECT) {

		    /*
		     * 409 (Conflict) - A resource cannot be created at the destination until
		     * one or more intermediate collections have been created.
		     */
		    WebDavServer::setResponseStatus('409 Conflict');
		}

		return $ret;
	    }

	    list ($ret, $newParent) = GalleryCoreApi::loadEntitiesById($newParentId);
	    if ($ret) {
		return $ret;
	    }

	    list ($ret, $error) = WebDavHelper::moveValidateHelper($item, $newParent);
	    if ($ret) {
		return $ret;
	    }
	    if (!empty($error)) {
		foreach ($error as $error) {
		    if (!strpos($error, 'permission')) {
			return GalleryCoreApi::error(ERROR_BAD_PARAMETER);
		    }
		}

		/* If all errors were permission denied return more specific error */
		return GalleryCoreApi::error(ERROR_PERMISSION_DENIED);
	    }
	}

	list ($ret, $conflictingItemId) = WebDavHelper::fetchItemIdByPath($newPath);
	if ($ret && !($ret->getErrorCode() & ERROR_MISSING_OBJECT)) {
	    return $ret;
	}
	if (!$ret) {
	    if (!$overwrite) {
		/*
		 * 412 (Precondition Failed) - The server was unable to maintain the liveness of the
		 * properties listed in the propertybehavior XML element or the Overwrite header is
		 * "F" and the state of the destination resource is non-null.
		 */
		WebDavServer::setResponseStatus('412 Precondition Failed');
		return GalleryCoreApi::error(ERROR_COLLISION);
	    }

	    list ($ret, $count) = WebDavHelper::deleteHelper($conflictingItemId);
	    if ($ret) {
		return $ret;
	    }
	}

	if ($newParentPath != $parentPath) {
	    /*
	     * Read lock both parent hierarchies
	     * TODO Optimize this
	     */
	    list ($ret, $lockIds[]) = GalleryCoreApi::acquireReadLockParents($newParentId);
	    if ($ret) {
		return $ret;
	    }

	    $oldParentId = $item->getParentId();
	    list ($ret, $lockIds[]) = GalleryCoreApi::acquireReadLockParents($oldParentId);
	    if ($ret) {
		GalleryCoreApi::releaseLocks($lockIds);
		return $ret;
	    }

	    list ($ret, $lockIds[]) = GalleryCoreApi::acquireReadLock(
		array($newParentId, $oldParentId));
	    if ($ret) {
		GalleryCoreApi::releaseLocks($lockIds);
		return $ret;
	    }
	}

	/* Write lock the item we're moving */
	list ($ret, $lockIds[]) = GalleryCoreApi::acquireWriteLock($itemId);
	if ($ret) {
	    GalleryCoreApi::releaseLocks($lockIds);
	    return $ret;
	}

	/* Refresh the item in case it changed before it was locked */
	list ($ret, $item) = $item->refresh();
	if ($ret) {
	    GalleryCoreApi::releaseLocks($lockIds);
	    return $ret;
	}

	/* Try renaming first - if it fails it's easier to undo */
	if ($newPathComponent != $pathComponent) {
	    $ret = $item->rename($newPathComponent);
	    if ($ret) {
		GalleryCoreApi::releaseLocks($lockIds);
		return $ret;
	    }
	}

	if ($newParentPath != $parentPath) {
	    /* Do the move */
	    $ret = $item->move($newParentId);
	    if ($ret) {
		if ($newPathComponent != $pathComponent) {
		    $item->rename($pathComponent);
		    /* Ignore cascading failures here */
		}

		GalleryCoreApi::releaseLocks($lockIds);
		return $ret;
	    }
	}

	$ret = $item->save();
	if ($ret) {
	    if ($newPathComponent != $pathComponent) {
		$ret = $item->rename($pathComponent);
		/* Ignore cascading failures here */
	    }

	    GalleryCoreApi::releaseLocks($lockIds);
	    return $ret;
	}

	if ($newParentPath != $parentPath) {
	    if (GalleryUtilities::isA($item, 'GalleryDataItem')) {
		/* Update for derivative preferences of new parent */
		$ret = GalleryCoreApi::addExistingItemToAlbum($item, $newParentId);
		if ($ret) {
		    GalleryCoreApi::releaseLocks($lockIds);
		    return $ret;
		}
	    }
	}

	/* Release all locks */
	$ret = GalleryCoreApi::releaseLocks($lockIds);
	if ($ret) {
	    return $ret;
	}

	/* Set WebDAV path component */
	if ($item->getPathComponent() != $newPathComponent) {
	    $ret = GalleryCoreApi::setPluginParameter(
		'module', 'webdav', 'pathComponent', $newPathComponent, $itemId);
	    if ($ret) {
		return $ret;
	    }
	}

	/* Fix thumbnail integrity */
	if ($newParentPath != $parentPath) {
	    /* What do we do if we weren't successful?  No thumbnail, I guess. */
	    list ($ret, $success) = GalleryCoreApi::guaranteeAlbumHasThumbnail($oldParentId);
	    if ($ret) {
		return $ret;
	    }
	}

	/* If an item was overwritten fix thumbnail integrity */
	if (empty($count)) {
	    /*
	     * 201 (Created) - The source resource was successfully copied.  The copy operation
	     * resulted in the creation of a new resource.
	     */
	    WebDavServer::setResponseStatus('201 Created');
	    return null;
	}

	/* In case we only renamed the item */
	if (empty($newParentId)) {
	    $newParentId = $item->getParentId();
	}

	/* What do we do if we weren't successful?  No thumbnail, I guess. */
	list ($ret, $success) = GalleryCoreApi::guaranteeAlbumHasThumbnail($newParentId);
	if ($ret) {
	    return $ret;
	}

	/*
	 * 204 (No Content) - The source resource was successfully copied to a pre-existing
	 * destination resource.
	 */
	WebDavServer::setResponseStatus('204 No Content');
	return null;
    }

    /**
     * LOCK request helper.
     *
     * Wrapper around HTTP_WebDAV_Server::lock_request_helper which prepares data-structures from
     * LOCK reqeusts.
     *
     * @return array object GalleryStatus a status code
     *               array WebDAV library options
     *               string token of WebDAV lock to refresh or null
     *               string scope of WebDAV lock (exclusive or shared)
     *               string type of WebDAV lock (read or write)
     *               int maximum depth of descendant paths
     *               string owner of WebDAV lock
     *               int timeout of WebDAV lock
     *               string token of WebDAV lock to create
     * @see HTTP_WebDAV_Server::lock_request_helper
     * @todo Simplify function signature
     */
    function lockRequestHelper() {
	$webDavServer =& WebDavHelper::getWebDavServer();

	if (!$webDavServer->lock_request_helper($webDavOptions)) {
	    /* WebDAV library found error in the request */
	    return array(GalleryCoreApi::error(ERROR_UNKNOWN),
			 null, null, null, null, null, null, null, null);
	}

	if (isset($webDavOptions['update'])) {
	    return array(null, $webDavOptions,
	    		 $webDavOptions['update'], null, null, null, null, null, null);
	}

	return array(null, $webDavOptions,
		     null,
		     $webDavOptions['scope'],
		     $webDavOptions['type'],
		     $webDavOptions['depth'],
		     $webDavOptions['owner'],
		     $webDavOptions['timeout'],
		     $webDavOptions['token']);
    }

    /**
     * LOCK response helper.
     *
     * Wrapper around HTTP_WebDAV_Server::lock_response_helper which formates LOCK responses.
     *
     * @param array $webDavOptions WebDAV library options
     * @param array $locks for response (path)
     * @param mixed $status HTTP response status
     * @param string $scope of WebDAV lock (exclusive or shared)
     * @param string $type of WebDAV lock (read or write)
     * @param int $depth maximum depth of descendant paths
     * @param string $owner of WebDAV lock
     * @param int $timeout of WebDAV lock
     * @param int $expires timestamp of WebDAV lock expiration
     * @param string $token of WebDAV lock
     * @see HTTP_WebDAV_Server::lock_response_helper
     * @todo Simplify function signature
     */
    function lockResponseHelper(
	    $webDavOptions, $locks, $status, $scope, $type, $depth, $owner, $expires, $token) {
	$webDavServer =& WebDavHelper::getWebDavServer();
	$webDavOptions['locks'] = $locks;
	$webDavOptions['scope'] = $scope;
	$webDavOptions['type'] = $type;
	$webDavOptions['depth'] = $depth;
	$webDavOptions['owner'] = $owner;
	$webDavOptions['expires'] = $expires;
	$webDavOptions['token'] = $token;
	$webDavServer->lock_response_helper($webDavOptions, $status);
    }

    /**
     * LOCK handler.
     *
     * WebDAV locks persist between requests.
     *
     * @return object GalleryStatus a status code
     * @todo Make corresponding Gallery locks persist between requests
     */
    function lock() {
	global $gallery;

	$path = WebDavHelper::getRequestVariable('path', true, false);

	/* Check resource is not locked */
	$ret = WebDavHelper::checkLocks($path);
	if ($ret) {
	    return $ret;
	}

	/* Prepare data-structure from LOCK request */
	list ($ret, $webDavOptions, $update, $scope, $type, $depth, $owner, $timeout, $token) =
	    WebDavHelper::lockRequestHelper();
	if ($ret) {
	    return $ret;
	}

	list ($ret, $itemId) = WebDavHelper::fetchItemIdByPath($path);
	if ($ret) {
	    return $ret;
	}

	/* Refresh lock */
	if (!empty($update)) {
	    /* Don't join with the Gallery lock table since we might be using flock system */
	    $query = '
		SELECT
		  [WebDavLockMap::depth],
		  [WebDavLockMap::owner],
		  [WebDavLockMap::galleryLockId]
		FROM
		  [WebDavLockMap]
		WHERE
		  [WebDavLockMap::path] = ?
		AND
		  [WebDavLockMap::token] = ?';
	    list ($ret, $results) = $gallery->search($query, array($path, $update));
	    if ($ret) {
		return $ret;
	    }

	    /* Tried to refresh a lock which no longer exists */
	    if (($result = $results->nextResult()) === false) {
		/*
		 * 412 (Precondition Failed) - The included lock token was not enforceable on this
		 * resource or the server could not satisfy the request in the lockinfo XML element.
		 */
		WebDavServer::setResponseStatus('412 Precondition Failed');
		return GalleryCoreApi::error(ERROR_BAD_PARAMETER);
	    }

	    /* Load WebDAV lock information */
	    $scope = 'exclusive';
	    $type = 'write';
	    $depth = $result[0];
	    $owner = $result[1];
	    $lockId = $result[2];

	    /* Check that the Gallery lock didn't disappear before the WebDAV lock */
	    if (GalleryCoreApi::isWriteLocked($itemId)) {
		/* TODO: Need an interface to update g_freshUntil for only $lockId */
	    } else {
		list ($ret, $lockId) = GalleryCoreApi::acquireWriteLock($itemId);
		if ($ret) {
		    return $ret;
		}
	    }
	} else {
	    /* Support only exclusive write locks */
	    if ($scope != 'exclusive' || $type != 'write') {
		/*
		 * 412 (Precondition Failed) - The included lock token was not enforceable on this
		 * resource or the server could not satisfy the request in the lockinfo XML element.
		 */
		WebDavServer::setResponseStatus('412 Precondition Failed');
		return GalleryCoreApi::error(ERROR_BAD_PARAMETER);
	    }

	    if ($depth == 'infinity') {
		list ($ret, $locks) = WebDavHelper::getDescendentsLocks($path);
		if ($ret) {
		    return $ret;
		}

		if (!empty($locks)) {
		    /* Format LOCK response */
		    return WebDavHelper::lockResponseHelper(
			$webDavOptions, $locks, null, null, null, null, null, null, null);
		}
	    }

	    list ($ret, $lockId) = GalleryCoreApi::acquireWriteLock($itemId);
	    if ($ret) {
		return $ret;
	    }
	}

	/* Use Gallery lock freshUntil for WebDAV lock timeout */
	$query = '
	    SELECT
	      [Lock::freshUntil]
	    FROM
	      [Lock]
	    WHERE
	      [Lock::lockId] = ?';
	list ($ret, $results) = $gallery->search($query, array($lockId));
	if ($ret) {
	    return $ret;
	}

	if (($result = $results->nextResult()) !== false) {
	    $expires = $result[0];
	} else {
	    /*
	     * Might be using flock system
	     * TODO: Get expires from flock locks
	    return GalleryCoreApi::error(ERROR_MISSING_VALUE);
	     */
	    $expires = time() + 30;
	}

	/* Refresh lock */
	if (!empty($update)) {
	    $ret = GalleryCoreApi::updateMapEntry('WebDavLockMap',
		array('token' => $update, 'path' => $path),
		array('expires' => $expires, 'galleryLockId' => $lockId));
	    if ($ret) {
		return $ret;
	    }
	} else {
	    $ret = GalleryCoreApi::addMapEntry('WebDavLockMap',
		array('depth' => $depth,
		      'owner' => $owner,
		      'expires' => $expires,
		      'token' => $token,
		      'path' => $path,
		      'galleryLockId' => $lockId));
	    if ($ret) {
		return $ret;
	    }
	}

	/* Format LOCK response */
	$ret = WebDavHelper::lockResponseHelper(
	    $webDavOptions, null, true, $scope, $type, $depth, $owner, $expires, $token);
	if ($ret) {
	    return $ret;
	}
    }

    /**
     * UNLOCK request helper.
     *
     * Wrapper around HTTP_WebDAV_Server::unlock_request_helper wich prepares data-structures from
     * UNLOCK requests.
     *
     * @return array object GalleryStatus a status code
     *               array WebDAV library options
     *               string token of WebDAV lock to clear
     * @see HTTP_WebDAV_Server::unlock_request_helper
     */
    function unlockRequestHelper() {
	$webDavServer =& WebDavHelper::getWebDavServer();

	if (!$webDavServer->unlock_request_helper($webDavOptions)) {
	    /* WebDAV library found error in the request */
	    return array(GalleryCoreApi::error(ERROR_UNKNOWN), null, null);
	}

	return array(null, $webDavOptions, $webDavOptions['token']);
    }

    /**
     * UNLOCK handler.
     * @return object GalleryStatus a status code
     */
    function unlock() {
	global $gallery;

	/* Prepare data-structure from UNLOCK request */
	list ($ret, $webDavOptions, $token) = WebDavHelper::unlockRequestHelper();
	if ($ret) {
	    return $ret;
	}

	$path = WebDavHelper::getRequestVariable('path', true, false);

	$query = '
	    SELECT
	      [WebDavLockMap::galleryLockId]
	    FROM
	      [WebDavLockMap]
	    WHERE
	      [WebDavLockMap::path] = ?
	    AND
	      [WebDavLockMap::token] = ?';
	list ($ret, $results) = $gallery->search($query, array($path, $token));
	if ($ret) {
	    return $ret;
	}

	if (($result = $results->nextResult()) === false) {
	    return GalleryCoreApi::error(ERROR_MISSING_VALUE);
	}
	$lockId = $result[0];

	$ret = GalleryCoreApi::releaseLocks($lockId);
	if ($ret) {
	    return $ret;
	}

	$ret = GalleryCoreApi::removeMapEntry('WebDavLockMap',
	    array('token' => $token, 'path' => $path));
	if ($ret) {
	    return $ret;
	}

	/*
	 * The 204 (No Content) status code is used instead of 200 (OK) because there is no response
	 * entity body.
	 */
	WebDavServer::setResponseStatus('204 No Content');
	return null;
    }
}

/**
 * Sub-class of HTTP_WebDAV_Server which overrides getHref, openRequestBody, setResponseHeader and
 * setResponseStatus.  getHref uses the URL generator.  openRequestBody uses the platform, for
 * testability.  setResponseHeader and setResponseStatus use GalleryUtilities::setResponseHeader to
 * avoid response headers being replaced elsewhere in Gallery and for testability, since
 * GalleryUtilities::setResponseHeader uses $phpVm->header.
 */
class WebDavServer extends HTTP_WebDAV_Server {

    /**
     * @see HTTP_WebDAV_Server::getHref
     */
    function getHref($path) {
	global $gallery;
	$urlGenerator =& $gallery->getUrlGenerator();

	return $urlGenerator->generateUrl(array('controller' => 'webdav.WebDav',
						 'path' => $path),
					   array('forceServerRelativeUrl' => true,
						 'forceSessionId' => false,
						 'urlEncode' => false,
						 'useAuthToken' => false));
    }

    /**
     * @see HTTP_WebDAV_Server::openRequestBody
     */
    function openRequestBody() {
	global $gallery;
	$platform =& $gallery->getPlatform();

	return $platform->fopen('php://input', 'rb');
    }

    /**
     * @see HTTP_WebDAV_Server::setResponseHeader
     */
    function setResponseHeader($header, $replace=true) {
	GalleryUtilities::setResponseHeader($header, $replace);
    }

    /**
     * @see HTTP_WebDAV_Server::setResponseStatus
     */
    function setResponseStatus($status, $replace=true) {
	GalleryUtilities::setResponseHeader('HTTP/1.0 ' . $status, $replace);
    }
}
?>
