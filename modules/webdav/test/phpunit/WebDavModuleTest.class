<?php
/*
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2007 Bharat Mediratta
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA  02110-1301, USA.
 */

/**
 * WebDAV module tests.
 * @package WebDav
 * @subpackage PHPUnit
 * @author Jack Bates <ms419@freezone.co.uk>
 * @version $Revision$
 */
class WebDavModuleTest extends GalleryTestCase {

    function WebDavModuleTest($methodName) {
	$this->GalleryTestCase($methodName);
    }

    function setUp() {
	parent::setUp();
	global $gallery;
	$this->_urlGenerator =& $gallery->getUrlGenerator();

	/* Create test items */
	list ($ret, $this->_album) = $this->_createRandomAlbum(
	    $this->_getRootId());
	if ($ret) {
	    print $ret->getAsHtml();
	    return $this->failWithStatus($ret);
	}
	$this->_markForCleanup($this->_album);

	list ($ret, $this->_item) = $this->_createRandomDataItem(
	    $this->_album->getId(), 'test/file');
	if ($ret) {
	    print $ret->getAsHtml();
	    return $this->failWithStatus($ret);
	}

	list ($ret, $this->_subAlbum) = $this->_createRandomAlbum($this->_album->getId());
	if ($ret) {
	    print $ret->getAsHtml();
	    return $this->failWithStatus($ret);
	}

	list ($ret, $this->_derivative) = $this->_createDerivative(
	    $this->_item, $this->_item->getId(), DERIVATIVE_TYPE_IMAGE_THUMBNAIL);
	if ($ret) {
	    print $ret->getAsHtml();
	    return $this->failWithStatus($ret);
	}

	$this->_items = array($this->_album, $this->_item, $this->_subAlbum);

	$this->_wantsDetailedLinks = array($this->_album->getId() => true,
					   $this->_item->getId() => true,
					   $this->_subAlbum->getId() => true);

	list ($ret, $this->_permissions) = GalleryCoreApi::fetchPermissionsForItems(
	    array($this->_album->getId(), $this->_item->getId(), $this->_subAlbum->getId()));
	if ($ret) {
	    print $ret->getAsHtml();
	    return $this->failWithStatus($ret);
	}

	$this->_userId = $gallery->getActiveUserId();

	/* Load WebDAV module */
	list ($ret, $this->_module) = GalleryCoreApi::loadPlugin('module', 'webdav');
	if ($ret) {
	    print $ret->getAsHtml();
	    return $this->failWithStatus($ret);
	}

	/* Mock disable WebDAV rewrite rules */
	$this->_activeRules =& WebDavModuleTestRewriteApi::_fetchActiveRulesForModule('webdav');
	$this->_activeRules = array();
	$this->_activateCalls =& WebDavModuleTestRewriteApi::_activateCalls();
	$this->_markFactoryForCleanup();
	$this->_registerFactoryImplementationForTest(
	    'RewriteApi', 'WebDavModuleTestRewriteApi', 'WebDavModuleTestRewriteApi',
	    'modules/webdav/test/phpunit/WebDavModuleTest.class', 'test');
	if ($ret) {
	    print $ret->getAsHtml();
	    return $this->failWithStatus($ret);
	}

	/* Use WebDavModuleTestHttpAuthInterface */
	$this->_requestCalls =& WebDavModuleTestHttpAuthInterface::_requestCalls();
	$this->_requestCalls = array();
	$this->_registerFactoryImplementationForTest('HttpAuthInterface_1_0',
	    'WebDavModuleTestHttpAuthInterface', 'WebDavModuleTestHttpAuthInterface',
	    'module/webdav/test/phpunit/WebDavModuleTest.class', 'test');

	/* Define OPTIONS request */
	$this->_optionsRequest = implode("\r\n", array(
	    'OPTIONS ' . $this->_urlGenerator->generateUrl(
		array('controller' => 'webdav.WebDav'),
		array('forceServerRelativeUrl' => true,
		      'htmlEntities' => false)) . ' HTTP/1.0',
	    'Host: ' . $this->_urlGenerator->getHostName(),
	    '',
	    ''));

	/* Define success and failure responses */
	$this->_includesDavHeadersResponse = implode("\r\n", array(
	    'HTTP/1.1 200 OK',
	    'Date: Mon, 24 Nov 2003 05:40:03 GMT',
	    'Server: Apache/1.3.28 (Unix)',
	    'Allow: OPTIONS,PROPFIND,PROPPATCH,MKCOL,GET,HEAD,DELETE,PUT,MOVE,LOCK,UNLOCK',
	    'DAV: 1,2',
	    'MS-Author-Via: DAV',
	    'Content-Length: 0',
	    'Connection: close',
	    'Content-Type: text/html',
	    '',
	    ''));
	$this->_missingDavHeadersResponse = implode("\r\n", array(
	    'HTTP/1.1 200 OK',
	    'Date: Mon, 24 Nov 2003 05:40:03 GMT',
	    'Server: Apache/1.3.28 (Unix)',
	    'Allow: OPTIONS,GET,HEAD,POST',
	    'Content-Length: 0',
	    'Connection: close',
	    'Content-Type: text/html',
	    '',
	    ''));

	/* Use WebDavModuleTestPlatform */
	$this->_platform = new WebDavModuleTestPlatform();
	$this->_platform->_messages[$this->_optionsRequest] =
	    $this->_includesDavHeadersResponse;
	$gallery->setPlatform($this->_platform);

	/* Register event listeners */
	$this->_registerTestEventListener('Gallery::ActivatePlugin', $this->_module);
	$this->_registerTestEventListener('GalleryEntity::delete', $this->_module);
	$this->_registerTestEventListener('GalleryEntity::save', $this->_module);
    }

    function tearDown() {
	GalleryDataCache::reset();
	parent::tearDown();
    }

    function testGetItemLinks() {
	list ($ret, $links) = $this->_module->getItemLinks(
	    $this->_items, $this->_wantsDetailedLinks, $this->_permissions, $this->_userId);
	if ($ret) {
	    return $this->failWithStatus($ret);
	}

	$expectedLinks = array();
	$expectedLinks[$this->_album->getId()][0]['text'] =
	    $this->_module->translate(array('text' => 'Mount with WebDAV'));
	$expectedLinks[$this->_album->getId()][0]['params'] =
	    array('view' => 'webdav.WebDavMount',
		  'itemId' => $this->_album->getId());
	$expectedLinks[$this->_subAlbum->getId()][0]['text'] =
	    $this->_module->translate(array('text' => 'Mount with WebDAV'));
	$expectedLinks[$this->_subAlbum->getId()][0]['params'] =
	    array('view' => 'webdav.WebDavMount',
		  'itemId' => $this->_subAlbum->getId());
	$this->assertEquals($expectedLinks, $links, 'item links for any user agent');
    }

    function testGetItemLinksNoDetail() {
	list ($ret, $links) = $this->_module->getItemLinks(
	    $this->_items, array(), $this->_permissions, $this->_userId);
	if ($ret) {
	    return $this->failWithStatus($ret);
	}

	$this->assertEquals(array(), $links, 'Must request detailed links');
    }

    function testGetRewriteRules() {
	$rules = $this->_module->getRewriteRules();
	$this->assertEquals(array('connect', 'davmount'), array_keys($rules));
    }

    function testGetRewriteRulesOptionsRuleActive() {
	$this->_activeRules = array('options');

	$rules = $this->_module->getRewriteRules();
	$this->assertEquals(array('connect', 'davmount', 'options'), array_keys($rules));
    }

    function testGetRewriteRulesMissingDavHeaders() {
	$this->_platform->_messages[$this->_optionsRequest] =
	    $this->_missingDavHeadersResponse;

	$rules = $this->_module->getRewriteRules();
	$this->assertEquals(array('connect', 'davmount', 'options'), array_keys($rules));
    }

    function testHandleEventActivatePlugin() {
	$event = GalleryCoreApi::newEvent('Gallery::ActivatePlugin');
	$event->setData(array('pluginType' => 'module',
			      'pluginId' => 'rewrite'));
	list ($ret, $results) = GalleryCoreApi::postEvent($event);
	if ($ret) {
	    return $this->failWithStatus($ret);
	}

	$this->assertEquals(array(array('webdav')), $this->_activateCalls);
    }

    function testHandleEventError() {
	$this->_registerTestEventListener('Gallery::Error', $this->_module);

	$error = GalleryCoreApi::error(GALLERY_ERROR);
	$event = GalleryCoreApi::newEvent('Gallery::Error');
	$event->setData(array('error' => $error));
	list ($ret, $results) = GalleryCoreApi::postEvent($event);
	if ($ret) {
	    return $this->failWithStatus($ret);
	}

	$this->assertEquals(array(array('suppressBody' => 1)), $results);
	$this->assertEquals(array(), $this->_requestCalls,
	    'Authentication should be requested only on ERROR_PERMISSION_DENIED');
    }

    function testHandleEventErrorPermissionDenied() {
	$this->_registerTestEventListener('Gallery::Error', $this->_module);

	$error = GalleryCoreApi::error(ERROR_PERMISSION_DENIED);
	$event = GalleryCoreApi::newEvent('Gallery::Error');
	$event->setData(array('error' => $error));
	list ($ret, $results) = GalleryCoreApi::postEvent($event);
	if ($ret) {
	    return $this->failWithStatus($ret);
	}

	$this->assertEquals(array(array('suppressBody' => 1)), $results);
	$this->assertEquals(array(array()), $this->_requestCalls,
	    'Authentication should be requested');
    }

    function testHandleEventDelete() {
	global $gallery;

	$expectedPathComponent = 'The Quick!Brown#Fox';

	/* Set WebDAV path component */
	$ret = GalleryCoreApi::addMapEntry('WebDavPathComponentMap',
	    array('itemId' => $this->_item->getId(), 'pathComponent' => $expectedPathComponent));
	if ($ret) {
	    return $this->failWithStatus($ret);
	}

	/* Delete the item */
	$ret = GalleryCoreApi::deleteEntityById($this->_item->getId());
	if ($ret) {
	    return $this->failWithStatus($ret);
	}

	$query = '
	    SELECT
	      [WebDavPathComponentMap::pathComponent]
	    FROM
	      [WebDavPathComponentMap]
	    WHERE
	      [WebDavPathComponentMap::itemId] = ?';
	list ($ret, $results) = $gallery->search($query, $this->_item->getId());
	if ($ret) {
	    return $this->failWithStatus($ret);
	}
	$this->assertEquals(false, $results->nextResult(),
			    'WebDAV path component should be removed');
    }

    function testHandleEventSave() {
	global $gallery;

	$expectedPathComponent = 'The Quick!Brown#Fox';

	/* Set WebDAV path component */
	$ret = GalleryCoreApi::addMapEntry('WebDavPathComponentMap',
	    array('itemId' => $this->_item->getId(), 'pathComponent' => $expectedPathComponent));
	if ($ret) {
	    return $this->failWithStatus($ret);
	}

	/* Write lock the item we're moving */
	list ($ret, $lockIds[]) = GalleryCoreApi::acquireWriteLock($this->_item->getId());
	if ($ret) {
	    GalleryCoreApi::releaseLocks($lockIds);
	    return $this->failWithStatus($ret);
	}

	/* Refresh the item in case it changed before it was locked */
	list ($ret, $this->_item) = $this->_item->refresh();
	if ($ret) {
	    GalleryCoreApi::releaseLocks($lockIds);
	    return $this->failWithStatus($ret);
	}

	/* Rename the item */
	$oldPathComponent = $this->_item->getPathComponent();
	$ret = $this->_item->rename('testItem-' . rand());
	if ($ret) {
	    GalleryCoreApi::releaseLocks($lockIds);
	    return $this->failWithStatus($ret);
	}

	$ret = $this->_item->save();
	if ($ret) {
	    $this->_item->rename($oldPathComponent);
	    GalleryCoreApi::releaseLocks($lockIds);
	    return $this->failWithStatus($ret);
	}

	$ret = GalleryCoreApi::releaseLocks($lockIds);
	if ($ret) {
	    return $this->failWithStatus($ret);
	}

	$query = '
	    SELECT
	      [WebDavPathComponentMap::pathComponent]
	    FROM
	      [WebDavPathComponentMap]
	    WHERE
	      [WebDavPathComponentMap::itemId] = ?';
	list ($ret, $results) = $gallery->search($query, $this->_item->getId());
	if ($ret) {
	    return $this->failWithStatus($ret);
	}
	$this->assertEquals(false, $results->nextResult(),
			    'WebDAV path component should be removed');
    }

    function testHandleEventSaveNotFilesystemEntity() {
	/* Write lock the item we're saving */
	list ($ret, $lockIds[]) = GalleryCoreApi::acquireWriteLock($this->_derivative->getId());
	if ($ret) {
	    GalleryCoreApi::releaseLocks($lockIds);
	    return $this->failWithStatus($ret);
	}

	/* Refresh the item in case it changed before it was locked */
	list ($ret, $this->_derivative) = $this->_derivative->refresh();
	if ($ret) {
	    GalleryCoreApi::releaseLocks($lockIds);
	    return $this->failWithStatus($ret);
	}

	$ret = $this->_derivative->save();
	if ($ret) {
	    GalleryCoreApi::releaseLocks($lockIds);
	    return $this->failWithStatus($ret);
	}

	$ret = GalleryCoreApi::releaseLocks($lockIds);
	if ($ret) {
	    return $this->failWithStatus($ret);
	}
    }

    function testHandleEventSaveNoRename() {
	global $gallery;

	$expectedPathComponent = 'The Quick!Brown#Fox';

	/* Set WebDAV path component */
	$ret = GalleryCoreApi::addMapEntry('WebDavPathComponentMap',
	    array('itemId' => $this->_item->getId(), 'pathComponent' => $expectedPathComponent));
	if ($ret) {
	    return $this->failWithStatus($ret);
	}

	/* Write lock the item we're moving */
	list ($ret, $lockIds[]) = GalleryCoreApi::acquireWriteLock($this->_item->getId());
	if ($ret) {
	    GalleryCoreApi::releaseLocks($lockIds);
	    return $this->failWithStatus($ret);
	}

	/* Refresh the item in case it changed before it was locked */
	list ($ret, $this->_item) = $this->_item->refresh();
	if ($ret) {
	    GalleryCoreApi::releaseLocks($lockIds);
	    return $this->failWithStatus($ret);
	}

	$this->_item->setTitle('new title');
	$this->_item->setSummary('new summary');
	$this->_item->setDescription('new description');

	$ret = $this->_item->save();
	if ($ret) {
	    GalleryCoreApi::releaseLocks($lockIds);
	    return $this->failWithStatus($ret);
	}

	$ret = GalleryCoreApi::releaseLocks($lockIds);
	if ($ret) {
	    return $this->failWithStatus($ret);
	}

	$query = '
	    SELECT
	      [WebDavPathComponentMap::pathComponent]
	    FROM
	      [WebDavPathComponentMap]
	    WHERE
	      [WebDavPathComponentMap::itemId] = ?';
	list ($ret, $results) = $gallery->search($query, $this->_item->getId());
	if ($ret) {
	    return $this->failWithStatus($ret);
	}
	if (($result = $results->nextResult()) === false) {
	    return $this->failWithStatus(GalleryCoreApi::error(ERROR_MISSING_VALUE));
	}
	$this->assertEquals($expectedPathComponent, $result[0]);
    }
}

class WebDavModuleTestRewriteApi {

    function &_fetchActiveRulesForModule($moduleId) {
	static $activeRules;
	return $activeRules;
    }

    function &_activateCalls() {
	static $activateCalls;
	return $activateCalls;
    }

    function isCompatibleWithApi($version) {
	return array(null, true);
    }

    function fetchActiveRulesForModule($moduleId) {
	return array(null, WebDavModuleTestRewriteApi::_fetchActiveRulesForModule($moduleId));
    }

    function activateRewriteRulesForModule($moduleId) {
	$activateCalls =& WebDavModuleTestRewriteApi::_activateCalls();
	$activateCalls[] = array($moduleId);
    }
}

class WebDavModuleTestHttpAuthInterface /* extends HttpAuthInterface_1_0 */ {

    function &_requestCalls() {
	static $requestCalls;
	return $requestCalls;
    }

    function requestAuthentication() {
	$requestCalls =& WebDavModuleTestHttpAuthInterface::_requestCalls();
	$requestCalls[] = array();
    }
}

class WebDavModuleTestPlatform extends GalleryPlatform {
    var $_messages;
    var $_buffer;

    function fsockopen($target, $port, &$errno, &$errstr, $timeout) {
	return 'test';
    }

    function feof($handle) {
	return empty($this->_buffer);
    }

    function fgets($handle, $length) {
	if (empty($this->_buffer)) {
	    return null;
	}

	if (strpos($this->_buffer, "\n") < $length) {
	    $length = strpos($this->_buffer, "\n") + 1;
	}

	return $this->fread($handle, $length);
    }

    function fread($handle, $length) {
	if (empty($this->_buffer)) {
	    return null;
	}

	$buffer = substr($this->_buffer, 0, $length);
	$this->_buffer = substr($this->_buffer, $length);
	return $buffer;
    }

    function fwrite($handle, $string, $length=0) {
	if (isset($this->_messages[$string])) {
	    $this->_buffer = $this->_messages[$string];
	    return strlen($string);
	}
    }

    function fflush($handle) {
	return true;
    }

    function fclose($handle) {
	return true;
    }
}
?>
