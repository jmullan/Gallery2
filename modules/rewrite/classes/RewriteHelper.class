<?php
/*
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2006 Bharat Mediratta
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA  02110-1301, USA.
 */
/**
 * A helper class for the URL rewrite module
 * @package Rewrite
 * @subpackage Classes
 * @author Douglas Cau <douglas@cau.se>
 * @version $Revision$ $Date$
 * @static
 */

/* General status codes */
define('REWRITE_STATUS_OK', 0);
define('REWRITE_STATUS_BAD_KEYWORD', 1);
define('REWRITE_STATUS_MULTISITE', 2);
define('REWRITE_STATUS_DUPE_SHORT_URL', 3); /* Deprecated */
define('REWRITE_STATUS_INVALID_PATTERN', 4);
define('REWRITE_STATUS_EMPTY_VALUE', 5);

/**
 * A helper class for the URL rewrite module
 * @static
 */
class RewriteHelper {

    /**
     * Load and initialize the rewrite plugin.  If no plugin has been configured yet
     * it returns a GalleryStatus ERROR_MISSING_VALUE.
     *
     * @param boolean $new (optional) true if we need a new instance
     * @return array object GalleryStatus a status code
     *               object RewritePlugin a loaded parser
     */
    function getRewriteParser($new=false) {
	global $gallery;
	static $rewriteParser;
	$platform =& $gallery->getPlatform();

	if (!isset($rewriteParser) || $new) {
	    list ($ret, $rewriteParserId) = GalleryCoreApi::getPluginParameter(
		'module', 'rewrite', 'parserId');
	    if ($ret) {
		return array($ret, null);
	    }
	    if (empty($rewriteParserId)) {
		return array(GalleryCoreApi::error(ERROR_MISSING_VALUE), null);
	    }

	    $path = 'modules/rewrite/classes/parsers/' . $rewriteParserId . '/parser.inc';
	    if ($platform->file_exists(GalleryCoreApi::getPluginBaseDir('module', 'rewrite') .
		    $path)) {
		GalleryCoreApi::requireOnce($path);
	    }
	    $class = $rewriteParserId . 'Parser';
	    $rewriteParser = new $class();
	}

	return array(null, $rewriteParser);
    }

    /**
     * Parse active rules into an array of regular expressions for parsing URLs during page requests
     * and build an array for the URL generator to use when generating short URLs.
     *
     * @param array $activeRules array array ('pattern' => string pattern) active rules by reference
     * @param object RewriteParser $rewriteParser
     * @param object GalleryModule $upgradeModule (optional) passed in during activate/upgrade
     * @param array $flags optional definition of default and mandator flags
     * @return array object GalleryStatus a status code
     *               int rewrite status code (REWRITE_STATUS_OK on success)
     *               array parsed patterns translated to regular expressions
     *               array short URLs which will used by to generate URLs
     *               array string module (on error)
     *                     int rule id (on error)
     */
    function parseActiveRules(&$activeRules, $rewriteParser, $upgradeModule=null, $flags=null) {
	global $gallery;
	$urlGenerator =& $gallery->getUrlGenerator();

	/* Get access list information */
	list ($ret, $accessList) = GalleryCoreApi::getPluginParameter(
	    'module', 'rewrite', 'accessList');
	if ($ret) {
	    return array($ret, null, null, null, null);
	}
	$accessList = unserialize($accessList);
	$ourHostNames[$urlGenerator->getHostName()] = true;
	$ourHostNames[$urlGenerator->getHostName(true)] = true;
	$accessList = array_merge($accessList, array_keys($ourHostNames));

	$regexRules = array();
	$shortUrls = array();
	foreach (array_keys($activeRules) as $moduleId) {
	    if (isset($upgradeModule) && $upgradeModule->getId() == $moduleId) {
		/* Avoid PLUGIN_VERSION_MISMATCH during upgrade by passing in module */
		$module = $upgradeModule;
	    } else {
		list ($ret, $module) = GalleryCoreApi::loadPlugin('module', $moduleId);
		if ($ret) {
		    if ($ret->getErrorCode() & ERROR_PLUGIN_VERSION_MISMATCH) {
			/*
			 * Add CONFIGURATION_REQUIRED code to more gracefully abort upgrade if a
			 * dependent module for one of our rules also needs upgrading.
			 */
			$ret->addErrorCode(ERROR_CONFIGURATION_REQUIRED);
		    }
		    return array($ret, null, null, null, null);
		}
	    }

	    $rules = $module->getRewriteRules();
	    foreach ($activeRules[$moduleId] as $ruleId => $rule) {
		/* Make sure this rule still exists, if not silently continue */
		if (!isset($rules[$ruleId])) {
		    unset($activeRules[$moduleId][$ruleId]);
		    continue;
		}

		/* Make sure this parser supports this kind of rule */
		if (!$rewriteParser->isValidRule($rules[$ruleId],
			$activeRules[$moduleId][$ruleId])) {
		    return array(null, REWRITE_STATUS_INVALID_PATTERN,
			null, null, array($moduleId, $ruleId));
		}

		/* Save the pattern for the URL generator to use */
		if (isset($rules[$ruleId]['match']) && isset($rule['pattern'])) {
		    $shortUrl = array('match' => $rules[$ruleId]['match'],
			'pattern' => $rule['pattern']);

		    /* Get custom function information */
		    if (isset($rules[$ruleId]['keywords'])) {
			foreach ($rules[$ruleId]['keywords'] as $key => $info) {
			    if (isset($info['function'])) {
				$shortUrl['functions'][$key] = $info['function'];
			    }
			}
		    }

		    /* Save the onLoad handler for this rule */
		    if (isset($rules[$ruleId]['onLoad'])) {
			$shortUrl['onLoad'] = $rules[$ruleId]['onLoad'];
		    }

		    $shortUrls[] = $shortUrl;
		}

		/* Parse the pattern and create regular expressions with conditions */
		$settings = array();
		$keywords = array('itemId' => array('pattern' => '([0-9]+)'));

		/* Add custom keywords to the list of allowed keywords */
		if (isset($rules[$ruleId]['keywords'])) {
		    $keywords = array_merge($keywords, $rules[$ruleId]['keywords']);
		}

		/* Restrict this rule to given query string conditions */
		if (!empty($rules[$ruleId]['restrict'])) {
		    foreach ($rules[$ruleId]['restrict'] as $key => $value) {
			$settings['restrict'][] = $key . '=' . $value;
		    }

		    $settings['exempt'] = array();
		    /* Exempt request from the following hosts */
		    if  (isset($rules[$ruleId]['exemptReferer'])) {
			$settings['exempt'] = $accessList;
		    }
		}

		/* Build the list of flags to apply to this rule */
		$settings['flags'] = isset($flags) ? $flags['default'] : array();
		if (isset($rules[$ruleId]['flags']) && isset($flags)) {
		    $settings['flags'] = array_merge($rules[$ruleId]['flags'], $flags['mandatory']);
		}

		/* Make sure that there's no subrequest made when we match by the query string */
		if (isset($settings['restrict']) && !in_array('L', $settings['flags'])) {
		    $settings['flags'][] = 'L';
		}
		$settings['flags'] = join(',', $settings['flags']);

		/* Build the query string to map the request on to */
		$queryString = array();
		if (isset($rules[$ruleId]['match'])) {
		    $queryString = $rules[$ruleId]['match'];
		}
		if (!empty($rules[$ruleId]['queryString'])) {
		    $queryString = array_merge($queryString, $rules[$ruleId]['queryString']);
		}

		/* Parse the rule */
		list ($ret, $code) = RewriteHelper::_parseRule($activeRules[$moduleId][$ruleId],
		    $keywords, $queryString, $regexRules, $settings, $rules[$ruleId]);
		if ($ret) {
		    return array($ret, null, null, null, null);
		}
		if ($code != REWRITE_STATUS_OK) {
		    return array(null, $code, null, null,
			array($moduleId, $ruleId));
		}
	    }
	}

	usort($regexRules, array('RewriteHelper', '_sortRules'));
	return array(null, REWRITE_STATUS_OK, $regexRules, $shortUrls, null);
    }

    /**
     * Replaces all keywords with an appropriate pattern and append to $regexRules.
     *
     * @param array $activeRule array ('pattern' => string pattern)
     * @param array $keywords of keywords => regular expresion for the htaccess file
     * @param array $queryString of query string params (key => value)
     * @param array $regexRules of parsed rules
     * @param array $settings of settings
     * @param array $rule rewrite rule
     * @return array object GalleryStatus a status code
     *               int rewrite status code (REWRITE_STATUS_OK on success)
     * @access private
     */
    function _parseRule($activeRule, $keywords, $queryString, &$regexRules, $settings, $rule) {
	$reference = 1;
	$regexRule = array('settings' => $settings);

	if (isset($rule['conditions'])) {
	    $regexRule['conditions'] = array();
	    foreach ($rule['conditions'] as $condition) {
		$code = RewriteHelper::_parseKeywords(
		    $reference, $condition['pattern'], $keywords, $queryString);
		if ($code != REWRITE_STATUS_OK) {
		    return array(null, $code);
		}

		$regexRule['conditions'][] = $condition;
	    }
	}

	if (isset($activeRule['pattern'])) {
	    $pattern = preg_quote($activeRule['pattern']);
	    $code = RewriteHelper::_parseKeywords(
		$reference, $pattern, $keywords, $queryString);
	    if ($code != REWRITE_STATUS_OK) {
		return array(null, $code);
	    }

	    $regexRule['pattern'] = $pattern;
	}

	$args = array();
	foreach ($queryString as $key => $value) {
	    $args[] = GalleryUtilities::prefixFormVariable($key) . '=' . $value;
	}
	$regexRule['queryString'] = join('&', $args);
	$regexRules[] = $regexRule;

	return array(null, REWRITE_STATUS_OK);
    }

    /**
     * Replaces all keywords with an appropriate pattern.
     * @param array $reference back reference to next keyword pattern
     * @param array $pattern
     * @param array $keywords of keywords => regular expresion for the htaccess file
     * @param array $queryString of query string params (key => value)
     * @return int rewrite status code (REWRITE_STATUS_OK on success)
     * @access private
     */
    function _parseKeywords(&$reference, &$pattern, $keywords, &$queryString) {
	preg_match_all('/\%([^%]+)\%/', $pattern, $matches);
	foreach ($matches[1] as $keyword) {
	    if (!isset($keywords[$keyword]['pattern'])) {
		return REWRITE_STATUS_BAD_KEYWORD;
	    }

	    $pattern = str_replace('%' . $keyword . '%', $keywords[$keyword]['pattern'], $pattern);

	    if (!isset($keywords[$keyword]['ignore'])) {
		$queryString[$keyword] = '$' . $reference;
	    }
	    $reference++;
	}

	return REWRITE_STATUS_OK;
    }

    /**
     * Comparison function used to order rewrite rules.
     * @access private
     */
    function _sortRules($a, $b) {
	if (isset($a['conditions']) || isset($b['conditions'])) {
	    if (isset($a['conditions']) && isset($b['conditions'])) {
		return count($a['conditions']) - count($b['conditions']);
	    }

	    if (isset($a['conditions'])) {
		return -1;
	    }

	    return 1;
	}

	if (isset($a['settings']['restrict']) || isset($b['settings']['restrict'])) {
	    if (isset($a['settings']['restrict']) && isset($b['settings']['restrict'])) {
		return count($a['settings']['restrict']) - count($b['settings']['restrict']);
	    }

	    if (isset($a['settings']['restrict'])) {
		return -1;
	    }

	    return 1;
	}

	/* Regular expression in both */
	if (strpos($a['pattern'], '(') !== false && strpos($b['pattern'], '(') !== false) {
	    if (strpos($a['pattern'], '(') == strpos($b['pattern'], '(')) {
		if (strlen($a['pattern']) == strlen($b['pattern'])) {
		    return 0;
		}

		return (strlen($a['pattern']) < strlen($b['pattern'])) ? 1 : -1;
	    }

	    return (strpos($a['pattern'], '(') < strpos($b['pattern'], '(')) ? 1 : -1;
	}
	if (strpos($a['pattern'], '(') !== false) {
	    return 1;
	}
	if (strpos($b['pattern'], '(') !== false) {
	    return -1;
	}

	return (strlen($a['pattern']) < strlen($b['pattern'])) ? 1 : -1;
    }


    /**
     * Get the rewrite rule history for a specific module.
     * @param string $moduleId id of the module
     * @return array object GalleryStatus a status code
     *               array (mixed ruleId => array ('pattern' => string pattern))
     */
    function getHistoryForModule($moduleId) {
	list ($ret, $history) =
		GalleryCoreApi::getPluginParameter('module', 'rewrite', 'history.' . $moduleId);
	if ($ret) {
	    return array($ret, null);
	}
	$history = empty($history) ? array() : unserialize($history);

	return array(null, $history);
    }

    /**
     * Store the rewrite rule history for a specific module.
     * @param string $moduleId id of the module
     * @param array $history array (mixed ruleId => array ('pattern' => string pattern))
     * @return object GalleryStatus a status code
     */
    function setHistoryForModule($moduleId, $history) {
	if (!empty($history)) {
	    $ret = GalleryCoreApi::setPluginParameter('module', 'rewrite',
						      'history.' . $moduleId, serialize($history));
	} else {
	    $ret = GalleryCoreApi::removePluginParameter('module', 'rewrite',
							 'history.' . $moduleId);
	}
	if ($ret) {
	    return $ret;
	}

	return null;
    }
}
?>
