<?php
/*
 * $RCSfile: CodeAuditTest.class,v $
 *
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2005 Bharat Mediratta
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA  02110-1301, USA.
 */
/**
 * @version $Revision: 1.34 $ $Date: 2005/08/23 03:49:33 $
 * @package GalleryCore
 * @subpackage PHPUnit
 * @author Alan Harder <alan.harder@sun.com>
 */

/**
 * Scan through all of our source code and verify that we're not doing anything "bad".
 * Checks for style guidelines too.
 *
 * @package GalleryCore
 * @subpackage PHPUnit
 */
class CodeAuditTest extends CodeAuditTestCase {

    function CodeAuditTest($methodName) {
	global $gallery;

	$this->CodeAuditTestCase($methodName);

	$platform = $gallery->getPlatform();

	$this->_exception['endphp'] = array();

	$this->_exceptions['preamble'] =
	    '{(:?/TestCase/|blocks/blocks.inc|(:?install|upgrade)/index.php|' .
	    'DatabaseStorage/ErrorHandler.inc|Php41IllegalFunctions.inc|GdFunctionMatrix.inc|' .
	    'frame.inc|iconpack.inc)}';

	$this->_exception['superglobals'] = array(
	    'FILES' => array(
		'modules/core/classes/GalleryUtilities.class' => 1,
		),
	    'POST' => array(
		'modules/core/classes/GalleryUtilities.class' => 1,
		),
	    'GET' => array(
		'modules/core/classes/GalleryUtilities.class' => 1,
		),
	    'REQUEST' => array(
		'modules/core/classes/GallerySession.class' => 1,
		),
	    'COOKIE' => array(
		'modules/core/classes/GallerySession.class' => 1,
		'modules/core/classes/GalleryUtilities.class' => 1,
		),
	    'SERVER' => array(
		'modules/core/classes/GalleryUtilities.class' => 1,
		),
	    );

	$this->_exception['returns'] = array(
	    'install/steps/SystemChecksStep.class' => array(
		'SystemChecksStep::CheckManifest' => 1,
		),
	    'upgrade/steps/SystemChecksStep.class' => array(
		'SystemChecksStep::CheckManifest' => 1,
		),
	    'modules/netpbm/classes/NetPbmToolkit.class' => array(
		'NetPbmToolkit::_extractCommands' => 1,
		),
	    'modules/nokiaupload/classes/ImageUploadHelper.class' => array(
		'ImageUploadHelper::getRSCapabilities' => 1,
		),
	    'modules/core/classes/FlockLockSystem.class' => array(
		'FlockLockSystem::_acquireLock' => 1,
		),
	    'main.php' => array(
		'::_GalleryMain_doRedirect' => 1,
		),
	    );

	$this->_longLineCount = 0;
	$this->_errorCount = 0;

	$this->_lineEnding = $platform->getLineEnding();

	/* Windows CVS appends a CRLF after ?>, so allow for it */
	$this->_phpEndFile = '/\?>(' . $this->_lineEnding . ')?$/';

	/* Use the first 21 lines of this file itself as our canonical preamble */
	$this->_preamble = $this->getPreamble(file(__FILE__));

	/* Turn the preamble into a pattern that we can use to match */
	$pattern = join("(:?\r\n|\n|\r)", $this->_preamble);
	$pattern = str_replace('?', '\?', $pattern);
	$pattern = str_replace('*', '\*', $pattern);
	$pattern = str_replace('(', '\(', $pattern);
	$pattern = str_replace(')', '\)', $pattern);
	$pattern = str_replace('/', '\/', $pattern);
	$this->_preamblePattern = str_replace(
	    'RCSFILE PLACEHOLDER',
	    '.*RCSfile.*',
	    $pattern);
    }

    /**
     * @see CodeAuditTestCase::shouldCheckFile()
     */
    function shouldCheckFile($fileName) {
	$base1 = basename($fileName);

	if ($base1 == 'GNUmakefile.inc') {
	    return false;
	}

	$dir1 = dirname($fileName);
	$base2 = basename($dir1);
	$dir2 = dirname($dir1);
	$base3 = basename($dir2);

	/* Skip generated interfaces files */
	if ($base3 == 'classes' && $base2 == 'interfaces') {
	    return false;
	}

	$dir3 = dirname($dir2);
	$base4 = basename($dir3);

	/* Skip known embedded 3rd party libs */
	if ($base4 == 'lib' && $base3 == 'exifer' ||
		$base3 == 'lib' && $base2 == 'exifer') {
	    return false;
	}
	if ($base4 == 'lib' && $base3 == 'JPEG' ||
		$base3 == 'lib' && $base2 == 'JPEG') {
	    return false;
	}

	return true;
    }

    /**
     * @see CodeAuditTestCase::checkFile()
     */
    function checkFile($fileName, $buffer) {
	$fileName = substr($fileName, strlen($this->_baseDir) + 1);
	$lines = split("(\r\n|\n)", $buffer);
	$checkSuperglobals = !preg_match('{/test/phpunit|^install/|^upgrade/}', $fileName);
	$longLineCount = 0;
	$currentFunction = null;
	$currentClass = null;
	$returnTable = array();

	if ($this->_lineEnding == "\n" && strpos($buffer, "\r\n") !== false) {
	    $this->_errorCount++;
	    $this->assert(false, sprintf('%s has Windows line endings', $fileName));
	}
	if (substr($fileName, -4) == '.tpl' || substr($fileName, -3) == '.po') {
	    /* Only perform newlines check on tpl and po files */
	    return;
	}

	$this->checkPreamble($fileName, $buffer, $lines);

	for ($i = 0; $i < count($lines); $i++) {
	    if (preg_match('/^\s*class (\S+)/', $lines[$i], $matches)) {
		$currentClass = $matches[1];
	    }

	    if (preg_match('/^\s*function (\S+)\(/', $lines[$i], $matches)) {
		$currentFunction = $currentClass . '::' . $matches[1];
	    }

	    if (preg_match('/^\s*return (.*)/', $lines[$i])) {
		if (!isset($currentFunction)) {
		    $this->_errorCount++;
		    $this->assert(false, "Return outside of a function on line $i in $fileName");
		}
		$return = '';
		$j = $i;
		do {
		    $return .= trim($lines[$j++]);
		} while ($j < count($lines) && strpos($return, ';') === false);
		$returnTable[$currentFunction][] = preg_replace('/^return\s+/', '', $return);
	    }

	    /* Check that Session and UrlGenerator are always accessed by-reference */
	    if (preg_match_all('/= *\$gallery->get(Session|UrlGenerator)/', $lines[$i], $matches)) {
		foreach (array_unique($matches[1]) as $item) {
		    $this->_errorCount++;
		    $this->assert(false,
				  sprintf('%s gets %s by value instead of by reference on line %d',
					  $fileName, $item, $i + 1));
		}
	    }

	    /*
	     * Verify that all access to superglobal variables from the browser
	     * is properly filtered through the framework so that we don't
	     * get remote exploits.
	     */
	    if ($checkSuperglobals && preg_match_all(
		    '/\$_(REQUEST|POST|GET|SESSION|FILES|SERVER|COOKIE)/', $lines[$i], $matches)) {
		foreach (array_unique($matches[1]) as $item) {
		    if (isset($this->_exception['superglobals'][$item][$fileName])) {
			continue;
		    }

		    /* It's ok if it's inside a debug statement */
		    if (preg_match("/gallery->debug(|_r)\(.*$item.*\)/", $lines[$i])) {
			continue;
		    }

		    $this->_errorCount++;
		    $this->assert(false,
				  sprintf('%s uses the %s superglobal instead of ' .
					  'its helper on line %d',
					  $fileName, $item, $i + 1));
		}
	    }

	    /* Check for lines wider than 100 characters */
	    /* Do a simple tab->8spaces conversion.. good enough for this check */
	    $line = str_replace("\t", '        ', $lines[$i]);
	    if (strlen($line) > 100) {
		$this->_longLineCount++;
		$longLineCount++;
	    }
	}

	/* Examine the return table for discrepancies */
	$returnMismatch = array();
	foreach ($returnTable as $function => $returns) {
	    if (isset($this->_exception['returns'][$fileName][$function])) {
		continue;
	    }

	    if (count($returns) < 2) {
		continue;
	    }

	    for ($i = 0; $i < count($returns); $i++) {
		if (preg_match('/^array(:?_keys)?\s*\(/', $returns[$i])) {
		    /*
		     * Determine the number of elements in returned arrays:
		     * 1. Strip off the enclosing array()
		     * 2. Collapse anything inside any remaining parens and quotes
		     * 3. Count the commas
		     * 4. Count the => tokens and subtract N-1 commas
		     *
		     * Step 4 covers the case where we return a bare associative array, eg:
		     *    return array('a' => 1, 'b' => 2, 'c' => 3);
		     *    return array('d' => 1, 'e' => 2);
		     * these match, even though they have a different number of commas
		     */
		    $tmp = $returnTable[$function][$i];
		    $tmp = preg_replace('/array\((.*)\)/', '$1', $tmp);
		    $tmp = preg_replace('/\'[^\']*\'/', '', $tmp);
		    $tmp = preg_replace('/"[^\']*"/', '', $tmp);
		    $runaway = 0;
		    while (strpos($tmp, ')') !== false) {
			$tmp = preg_replace('/\([^\(\)]*\)/', '', $tmp);
			if ($runaway++> 10) {
			    break;
			}
		    }

		    $commaCount = substr_count($tmp, ",");
		    $assignCount = substr_count($tmp, "=>");
		    if ($assignCount > 0) {
			$commaCount -= ($assignCount - 1);
		    }

		    $finalCount = "array($commaCount)";
		    $returnCount[$function][$i] = array($finalCount, $tmp);
		} else {
		    $returnCount[$function][$i] = array("scalar", $returns[$i]);
		}
		if ($i > 0 && $returnCount[$function][$i][0] != $returnCount[$function][0][0]) {
		    $returnMismatch[$function] = 1;
		}
	    }
	}

	foreach (array_keys($returnMismatch) as $function) {
	    $returns = '';
	    for ($i = 0; $i < count($returnTable[$function]); $i++) {
		$returns .= sprintf("[%s] return %s%s\n",
				    $returnCount[$function][$i][0],
				    $returnTable[$function][$i],
				    false ? '' :  /* set to false to see the transformed return */
				    ' --> ' . $returnCount[$function][$i][1]);
	    }
	    $this->assert(false, sprintf('Mismatched returns in %s %s()<pre>%s</pre>',
					 $fileName, $function, $returns));
	}

	/*
	 * Check that php files end with ?>
	 * As noted in the constructor, Windows CVS will append a CRLF to
	 * the end of the file, so we allow for that.
	 */
	if (!isset($this->_exception['endphp'][basename($fileName)])
		&& !preg_match($this->_phpEndFile, $buffer)) {
	    $this->_errorCount++;
	    $this->assert(false, $fileName . ' does not end with ?&gt;');
	}

	if ($longLineCount > 0) {
	    /* debug */
	    /* printf("%s: %d<br/>", $fileName, $longLineCount); */
	}

	if ($this->_errorCount > 10) {
	    $this->halt();
	}
    }

    function checkPreamble($fileName, $buffer, $lines) {
	if (preg_match($this->_exceptions['preamble'], $fileName)) {
	    return;
	}

	if (preg_match('/^' . $this->_preamblePattern . '/', $buffer)) {
	    return;
	} else {
	    $this->_errorCount++;
	    $errorReported = false;
	    for ($i = 0; $i < count($this->_preamble); $i++) {
		if ($i == 2) {
		    /* Break up the RCSfile keyword so that CVS doesn't expand it */
		    $expected = ' * $' . 'RCSfile: ' . basename($fileName) . ',v $';
		} else {
		    $expected = $this->_preamble[$i];

		}

		if (strcmp($expected, $lines[$i])) {
		    $this->assert(false,
				  "Preamble mismatch in $fileName on line " . ($i + 1) . ":<br/>" .
				  "Expected: [$expected]<br/>" .
				  "Received: [$lines[$i]]<br/>");
		    $errorReported = true;
		}
	    }
	    if (!$errorReported) {
		$this->assert(false, "Unknown preamble mismatch in $fileName");
	    }
	}
    }

    function getPreamble($lines) {
	$copy = array();
	for ($i = 0; $i < count($lines); $i++) {
	    if (preg_match('/.*RCSfile.*/', $lines[$i])) {
		$new = " * RCSFILE PLACEHOLDER";
	    } else {
		$new = rtrim($lines[$i]);
	    }

	    if (!strncmp($lines[$i], ' */', 3)) {
		return $copy;
	    }

	    $copy[] = $new;
	}

	return $copy;
    }

    /**
     * @see CodeAuditTestCase::testCodeAudit()
     */
    function testCodeAudit() {
	parent::testCodeAudit();

	/* Check result of longLineCount */
	if (!$this->_shouldHalt) {
	    if ($this->_longLineCount > 1175) {
		$this->assert(false, 'Found too many lines longer than 100 characters (' .
			      $this->_longLineCount . ')');
	    }
	    if ($this->_longLineCount < 1075) {
		$this->assert(false, 'Yay!  We are down to ' . $this->_longLineCount .
			      ' lines longer than 100 characters; update the failure' .
			      ' thresholds in this unit test.');
	    }
	}
    }
}
?>
