<?php
/*
 * $RCSfile
 *
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2003 Bharat Mediratta
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

/**
 * Utility class for gathering run-time profile data
 *
 * @version $Revision$ $Date$
 * @package GalleryCore
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class GalleryProfiler {

    /*
     * ****************************************
     *                 Members
     * ****************************************
     */

    /**
     * The raw profiling data we've gathered
     *
     * @var array
     * @access private
     */
    var $_profile = array();
    
    /*
     * ****************************************
     *                 Methods
     * ****************************************
     */

    /**
     * Constructor
     */
    function GalleryProfiler() {
	$this->_profile = array();
    }

    /**
     * Get the singleton of this class
     *
     * @return object GalleryProfiler
     * @access private
     */
    function &_singleton() {
	static $galleryProfiler;
	if (empty($galleryProfiler)) {
	    $galleryProfiler = new GalleryProfiler();
	}

	return $galleryProfiler;
    }

    /**
     * Start profiling a function/method
     *
     * You can optionally specify the real start of this method (only useful at
     * bootstrap time, when we want to retroactively start the overall
     * profiling at the time the script started, as opposed to after this class
     * is loaded).
     *
     * @param string the function/method name
     * @param array the optional microtime() to use as the start of this function/method
     */
    function start($key, $start=null) {
	global $gallery;

	if (!$gallery->isProfiling()) {
	    return;
	}

	/* Delegate to the singleton */
	if (empty($this) || get_class($this) != 'galleryprofiler') {
	    $galleryProfiler =& GalleryProfiler::_singleton();
	    return $galleryProfiler->start($key, $start);
	}

	if (empty($start)) {
	    $start = microtime();
	}

	if (!is_array($this->_profile)) {
	    $this->_profile = array();
	}
	
	$this->_profile[] = array('type' => 'start',
				  'marker' => $key,
				  'eventTime' => $start);
    }

    /**
     * Stop profiling a function/method
     *
     * @param string the function/method name
     */
    function stop($key) {
	global $gallery;

	if (!$gallery->isProfiling()) {
	    return;
	}

	/* Delegate to the singleton */
	if (empty($this) || get_class($this) != 'galleryprofiler') {
	    $galleryProfiler =& GalleryProfiler::_singleton();
	    return $galleryProfiler->stop($key);
	}

	$this->_profile[] = array('type' => 'stop',
				  'marker' => $key,
				  'eventTime' => microtime());
    }

    /**
     * Get the profiling data
     *
     * For each function/method, either return an error or the total time,
     * average time and number of calls to the function/method.
     *
     * @return array('name' => ...,
     *               'error' => ...,
     *               'total' => ...,
     *               'average' => ...,
     *               'count' => ...)
     */
    function getProfile() {
	/* Delegate to the singleton */
	if (empty($this) || get_class($this) != 'galleryprofiler') {
	    $galleryProfiler =& GalleryProfiler::_singleton();
	    return $galleryProfiler->getProfile();
	}

	/* The entries may not be in time order.  Sort them now. */
	usort($this->_profile, array('GalleryProfiler', 'sortByEventTime'));

	/*
	 * Traverse the event stack and calculate how much time we spend in
	 * each function that we're profiling.  Track also how much time we
	 * spend in sub functions and calculate the "internal" and "external"
	 * time for each function.
	 */
	$eventStack = array();
	$carryoverStack = array();
	$collated = array();
	$error = null;

	foreach ($this->_profile as $entry) {
	    if ($entry['type'] == 'start') {
		array_push($eventStack, $entry);
		array_push($carryoverStack, array('elapsed' => 0.0,
						  'markers' => array()));
	    }

	    if ($entry['type'] == 'stop') {
		$stop = $entry;
		$start = array_pop($eventStack);
		$carryover = array_pop($carryoverStack);

		if ($start == null) {
		    $error = "Stack underflow! ($stop[marker])";
		    break;
		}

		if ($start['marker'] != $stop['marker']) {
		    $error = "Stack mismatch! ($start[marker] != $stop[marker])";
		    break;
		}
		
		if ($start['type'] != 'start') {
		    $error = "Stack mismatch! ($start[marker]: $start[type] != start)";
		    break;
		}
		
		list ($startMicro, $startSecs) = explode(' ', $start['eventTime']);
		list ($stopMicro, $stopSecs) = explode(' ', $stop['eventTime']);
		$elapsed = ($stopSecs - $startSecs) + ($stopMicro - $startMicro);

		$collated[$start['marker']][] = array('internal' => $elapsed - $carryover['elapsed'],
						      'external' => $carryover);

		// Increment parent's carryover
		if (sizeof($carryoverStack) > 0) {
		    $top = array_pop($carryoverStack);
		    $top['elapsed'] += $elapsed;
		    $top['markers'][] = array('elapsed' => $elapsed,
					      'marker' => $start['marker']);
		    array_push($carryoverStack, $top);
		}
	    }
	}

	if (empty($error) && sizeof($eventStack) > 0) {
	    $error = 'Elements left on the stack: ' . sizeof($eventStack);
	}

	if ($error) {
	    $results[] = array('name' => 'GalleryProfiler',
			       'error' => $error);
	} else {
	    $precision = 5;

	    /*
	     * Go through our collated data and build a report for each
	     * individual marker.
	     */
	    foreach ($collated as $marker => $calls) {
		$internal['total'] = 0.0;
		$internal['max'] = 0.0;
		$external['total'] = 0.0;
		$external['max'] = 0.0;
		$external['calls'] = array();
		foreach ($calls as $call) {
		    $internal['total'] += $call['internal'];
		    $internal['max'] = max($internal['max'], $call['internal']);
		    $external['total'] += $call['external']['elapsed'];
		    $external['max'] = max($external['max'], $call['external']['elapsed']);
		    $external['calls'] = array_merge($external['calls'], $call['external']['markers']);
		}
		$internal['average'] = ($internal['total'] / sizeof($calls));
		$external['average'] = ($external['total'] / sizeof($calls));
		
		foreach (array('average', 'total', 'max') as $key) {
		    $internal[$key] = round($internal[$key], $precision);
		    $external[$key] = round($external[$key], $precision);
		}
		
		$results[] = array('name' => $marker,
				   'count' => sizeof($calls),
				   'total' => $internal['total'] + $external['total'],
				   'internal' => $internal,
				   'external' => $external);
	    }
	}
			     
	usort($results, array('GalleryProfiler', 'sortByInternalTotal'));

	return $results;
    }

    /**
     * Sort profile entries by their totals
     *
     * @param array('total' => ###)
     * @param array('total' => ###)
     * @return -1, 0, or 1
     */
    function sortByInternalTotal($cmpA, $cmpB) {
	if ($cmpA['internal']['total'] == $cmpB['internal']['total']) {
	    return 0;
	}

	if ($cmpA['internal']['total'] > $cmpB['internal']['total']) {
	    return -1;
	} else {
	    return 1;
	}
    }

    /**
     * Sort profile entries by their event times
     *
     * @param cmpA array('eventTime' => "0.### ####")
     * @param cmpB array('eventTime' => "0.### ####")
     * @return -1, 0, or 1
     */
    function sortByEventTime($cmpA, $cmpB) {

	$cmpA = explode(' ', $cmpA['eventTime']);
	$cmpB = explode(' ', $cmpB['eventTime']);

	if ($cmpA[1] < $cmpB[1]) {
	    return -1;
	}

	if ($cmpA[1] > $cmpB[1]) {
	    return 1;
	}

	if ($cmpA[0] < $cmpB[0]) {
	    return -1;
	}
	
	if ($cmpA[0] > $cmpB[0]) {
	    return 1;
	}

	return 0;
    }
}
?>
