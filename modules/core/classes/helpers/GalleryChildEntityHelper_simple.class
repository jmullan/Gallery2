<?php
/*
 * $RCSfile$
 *
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2004 Bharat Mediratta
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
/**
 * @version $Revision$ $Date$
 * @package GalleryCore
 * @author Ernesto Baschny <ernst@baschny.de>
 */

/**
 * Helper class for GalleryChildEntities
 *
 * @package GalleryCore
 * @subpackage Helpers
 * @abstract
 */
class GalleryChildEntityHelper_simple {

    /**
     * Return the ids of the children of this entity, in the order specified
     * by the orderBy field and the direction specified by the orderDirection
     * field, that are visible to the given user.
     *
     * @param object GalleryItem an item
     * @param int where to start
     * @param int how many to return
     *
     * @access public
     * @return array object GalleryStatus a status code
     *               array integer ids
     * @static
     */
    function fetchChildItemIds($item, $offset=null, $count=null) {
	global $gallery;

	if (!GalleryUtilities::isA($item, 'GalleryItem')) {
	    return array(GalleryStatus::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__), null);
	}

	list ($ret, $permissionBits) = GalleryCoreApi::convertPermissionIdsToBits('core.view');
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	$storage =& $gallery->getStorage();

	/* List of classes that we will need */
	$classes = array('[GalleryChildEntity]', '[GalleryItem]', '[GalleryPermissionMap]');

	list($orderColumn, $extraWhere, $orderDirection) = GalleryChildEntityHelper_simple::_getOrderInfo($item);
	$extraIds = 0;

	if (!empty($extraWhere)) {
	    $extraIds = substr_count($extraWhere, '?');
	    $extraWhere = 'AND ' . $extraWhere;

	    list ($ret, $orderClasses) = $storage->extractClasses($extraWhere);
	    if ($ret->isError()) {
    		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	    $classes = array_unique(array_merge($classes, $orderClasses));
	}
	if (!empty($orderColumn)) {
	    $orderClause = 'ORDER BY ' . $orderColumn . ' ' . $orderDirection;
	    $groupExtra = ', ' . $orderColumn;
	    $selectExtra = ', ' . $orderColumn;
	} else {
	    $orderClause = '';
	    $groupExtra = '';
	    $selectExtra = '';
	}

	list ($ret, $groupIds) = GalleryCoreApi::fetchGroupsForUser($gallery->getActiveUserId());
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	$groupIds = array_keys($groupIds);
	$groupIdMarkers = GalleryUtilities::makeMarkers($groupIds);
	list ($ret, $andPermission) = $storage->getFunctionSql('BITAND',
						array('[GalleryPermissionMap::permission]', '?'));
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	/* Prepare the query */
	$query = '
        SELECT
          [GalleryChildEntity::id] ' . $selectExtra . '
        FROM
          ' . join(', ', $classes) . '
        WHERE
          [GalleryChildEntity::parentId] = ?
          AND
          [GalleryChildEntity::id] = [GalleryItem::id]
          AND
          ([GalleryPermissionMap::userId] = ?
           OR
          [GalleryPermissionMap::groupId] IN (' . $groupIdMarkers . '))
          AND
        ' . $andPermission . ' > ?
          AND
          [GalleryPermissionMap::itemId] = [GalleryChildEntity::id]
	  ' . $extraWhere . '
        GROUP BY
          [GalleryChildEntity::id] ' . $groupExtra . '
	' . $orderClause . '
	';
	$data[] = $item->getId();
	$data[] = $gallery->getActiveUserId();
	array_splice($data, sizeof($data), 0, $groupIds);
	$data[] = $storage->convertIntToBits($permissionBits);
	$data[] = $storage->convertIntToBits(0);
	for ($i = 0; $i < $extraIds; $i++) {
	    /* add the data for $orderWhere's extra ?'s */
	    $data[] = $this->getId();
	}
	$options = array();
	$options['limit'] = array('count' => $count, 'offset' => $offset);
	if ($gallery->getDebug()) {
	    $gallery->debug_r($options);
	}
	list ($ret, $searchResults) = $gallery->search($query, $data, $options);
	
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	$ids = array();
	while ($result = $searchResults->nextResult()) {
	    $ids[] = (int)$result[0];
	}

	return array(GalleryStatus::success(), $ids);
    }

    /**
     * Return the ids of the children of this entity, in the order specified
     * by the orderBy field and the direction specified by the orderDirection
     * field, that are visible to the given user.
     *
     * @param object GalleryItem an item
     * @param int where to start
     * @param int how many to return
     *
     * @access public
     * @return array object GalleryStatus a status code
     *               array integer ids
     * @static
     */
    function fetchChildDataItemIds($item, $offset=null, $count=null) {
	global $gallery;

	list ($ret, $permissionBits) = GalleryCoreApi::convertPermissionIdsToBits('core.view');
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	$storage =& $gallery->getStorage();

	/* List of classes that we will need */
	$classes = array('[GalleryChildEntity]', '[GalleryDataItem]', '[GalleryPermissionMap]');

	list($orderColumn, $extraWhere, $orderDirection) = GalleryChildEntityHelper_simple::_getOrderInfo($item);
	$extraIds = 0;

	if (!empty($extraWhere)) {
	    $extraIds = substr_count($extraWhere, '?');
	    $extraWhere = 'AND ' . $extraWhere;

	    list ($ret, $orderClasses) = $storage->extractClasses($extraWhere);
	    if ($ret->isError()) {
    		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	    $classes = array_unique(array_merge($classes, $orderClasses));
	}
	if (!empty($orderColumn)) {
	    $orderClause = 'ORDER BY ' . $orderColumn . ' ' . $orderDirection;
	    $groupExtra = ', ' . $orderColumn;
	    $selectExtra = ', ' . $orderColumn;
	} else {
	    $orderClause = '';
	    $groupExtra = '';
	    $selectExtra = '';
	}

	list ($ret, $groupIds) = GalleryCoreApi::fetchGroupsForUser($gallery->getActiveUserId());
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	$groupIds = array_keys($groupIds);
	$groupIdMarkers = GalleryUtilities::makeMarkers($groupIds);
	list ($ret, $andPermission) = $storage->getFunctionSql('BITAND',
						array('[GalleryPermissionMap::permission]', '?'));
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	/* Prepare the query */
	$query = '
        SELECT
          [GalleryChildEntity::id] ' . $selectExtra . '
        FROM
          ' . join(', ', $classes) . '
        WHERE
          [GalleryChildEntity::parentId] = ?
          AND
          [GalleryChildEntity::id] = [GalleryDataItem::id]
          AND
          ([GalleryPermissionMap::userId] = ?
           OR
           [GalleryPermissionMap::groupId] IN (' . $groupIdMarkers . '))
          AND
        ' . $andPermission . ' > ?
          AND
          [GalleryPermissionMap::itemId] = [GalleryChildEntity::id]
	  ' . $extraWhere . '
        GROUP BY
          [GalleryChildEntity::id] ' . $groupExtra . '
	' . $orderClause . '
	';
	$data[] = $item->getId();
	$data[] = $gallery->getActiveUserId();
	array_splice($data, sizeof($data), 0, $groupIds);
	$data[] = $storage->convertIntToBits($permissionBits);
	$data[] = $storage->convertIntToBits(0);
	for ($i = 0; $i < $extraIds; $i++) {
	    /* add the data for $orderWhere's extra ?'s */
	    $data[] = $this->getId();
	}
	$options = array();
	$options['limit'] = array('count' => $count, 'offset' => $offset);
	if ($gallery->getDebug()) {
	    $gallery->debug_r($options);
	}
	list ($ret, $searchResults) = $gallery->search($query, $data, $options);
	
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	$ids = array();
	while ($result = $searchResults->nextResult()) {
	    $ids[] = (int)$result[0];
	}
	
	return array(GalleryStatus::success(), $ids);
    }

    /**
     * Return the ids of the children of this entity, in the order specified
     * by the orderBy field and the direction specified by the orderDirection
     * field, that are visible to the given user.
     *
     * @param object GalleryItem an item
     * @param int where to start
     * @param int how many to return
     *
     * @access public
     * @return array object GalleryStatus a status code
     *               array integer ids
     * @static
     */
    function fetchChildItemIdsIgnorePermissions($item, $offset=null, $count=null) {
	global $gallery;

	list ($ret, $permissionBits) = GalleryCoreApi::convertPermissionIdsToBits('core.view');
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	$storage =& $gallery->getStorage();

	/* List of classes that we will need */
	$classes = array('[GalleryChildEntity]', '[GalleryItem]');

	list($orderColumn, $extraWhere, $orderDirection) = GalleryChildEntityHelper_simple::_getOrderInfo($item);
	$extraIds = 0;

	if (!empty($extraWhere)) {
	    $extraIds = substr_count($extraWhere, '?');
	    $extraWhere = 'AND ' . $extraWhere;

	    list ($ret, $orderClasses) = $storage->extractClasses($extraWhere);
	    if ($ret->isError()) {
    		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	    $classes = array_unique(array_merge($classes, $orderClasses));
	}
	if (!empty($orderColumn)) {
	    $orderClause = 'ORDER BY ' . $orderColumn . ' ' . $orderDirection;
	    $groupExtra = ', ' . $orderColumn;
	    $selectExtra = ', ' . $orderColumn;
	} else {
	    $orderClause = '';
	    $groupExtra = '';
	    $selectExtra = '';
	}

	/* Prepare the query */
	$query = '
        SELECT
          [GalleryChildEntity::id] ' . $selectExtra . '
        FROM
          ' . join(', ', $classes) . '
        WHERE
          [GalleryChildEntity::parentId] = ?
          AND
          [GalleryChildEntity::id] = [GalleryItem::id]
	  ' . $extraWhere . '
        GROUP BY
          [GalleryChildEntity::id] ' . $groupExtra . '
	' . $orderClause . '
	';
	$data[] = $item->getId();
	for ($i = 0; $i < $extraIds; $i++) {
	    /* add the data for $orderWhere's extra ?'s */
	    $data[] = $this->getId();
	}
	$options = array();
	$options['limit'] = array('count' => $count, 'offset' => $offset);
	if ($gallery->getDebug()) {
	    $gallery->debug_r($options);
	}
	list ($ret, $searchResults) = $gallery->search($query, $data, $options);
	
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	$ids = array();
	while ($result = $searchResults->nextResult()) {
	    $ids[] = (int)$result[0];
	}
	
	return array(GalleryStatus::success(), $ids);
    }
    
    /**
     * Load all the ancestors of this item
     *
     * @param object GalleryItem an item
     * @return array object GalleryStatus a status code 
     *               array (array(memberName => memberValue))
     * @static
     */
    function fetchParents($item) {
	global $gallery;

	if (GalleryUtilities::isA($item, 'GalleryAlbumItem')) {
	    list ($ret, $parentIds) = GalleryCoreApi::fetchParentSequence($item->getId());
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	} else {
	    list ($ret, $parentIds) = GalleryCoreApi::fetchParentSequence($item->getParentId());
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	    array_push($parentIds, $item->getParentId());
	}

	if (!empty($parentIds)) {
	    list ($ret, $parents) = GalleryCoreApi::loadEntitiesById($parentIds);
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	} else {
	    $parents = array();
	}

	return array(GalleryStatus::success(), $parents);
    }


    /**
     * If we want to sort, which storage info we need?
     *
     * This will return the ORDER BY clause to sort the items and a
     * condition that we need to add to the fetching query. To join with
     * a new table, the [GalleryChildEntity::id] will contain the current
     * ID. Eventualy another table mentioned in the condition will have to
     * be included too, the calling function has to decide that (using
     * GalleryStorage::extractClasses())
     *
     * @return array string an order clause, string a row matching condition
     * @access private
     * @static
     */
    function _getOrderInfo(&$item) {
	/*
	 * Don't simply plug getOrderBy into the SQL clause, or we could open
	 * the door for SQL injection.
	 *
	 * XXX: Eventually this should be something that a module can register
	 * so that we can allow modules to introduce their own custom sort
	 * orders.
	 */
	$orderBy = $item->getOrderBy();
	$orderDirection = $item->getOrderDirection();
	if (empty($orderBy)) {
	    list ($ret, $orderBy) =
	        GalleryCoreApi::getPluginParameter('module', 'core', 'default.orderBy');
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	    list ($ret, $orderDirection) =
	        GalleryCoreApi::getPluginParameter('module', 'core', 'default.orderDirection');
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	}

	switch ($orderDirection) {
	case ORDER_DESCENDING:
	    $direction = 'DESC';
	    break;

	case ORDER_ASCENDING:
	default:
	    $direction = '';
	}

	switch ($orderBy) {
	case 'title':
	    $orderColumn = '[GalleryItem::title]';
	    $condition = '[GalleryItem::id] = [GalleryChildEntity::id]';
	    break;

	case 'summary':
	    $orderColumn = '[GalleryItem::summary]';
	    $condition = '[GalleryItem::id] = [GalleryChildEntity::id]';
	    break;

	case 'creationTimestamp':
	    $orderColumn = '[GalleryEntity::creationTimestamp]';
	    $condition = '[GalleryEntity::id] = [GalleryChildEntity::id]';
	    break;

	case 'modificationTimestamp':
	    $orderColumn = '[GalleryEntity::modificationTimestamp]';
	    $condition = '[GalleryEntity::id] = [GalleryChildEntity::id]';
	    break;

	case 'description':
	    $orderColumn = '[GalleryItem::description]';
	    $condition = '[GalleryItem::id] = [GalleryChildEntity::id]';
	    break;

	case 'keywords':
	    $orderColumn = '[GalleryItem::keywords]';
	    $condition = '[GalleryItem::id] = [GalleryChildEntity::id]';
	    break;

	case 'pathComponent':
	    $orderColumn = '[GalleryFileSystemEntity::pathComponent]';
	    $condition = '[GalleryFileSystemEntity::id] = [GalleryChildEntity::id]';
	    break;

	case 'viewCount':
	    $orderColumn = '[GalleryItemAttributesMap::viewCount]';
	    $condition = '[GalleryItemAttributesMap::itemId] = [GalleryChildEntity::id]';
	    break;

	case 'orderWeight':
	default:
	    $orderColumn = '[GalleryItemAttributesMap::orderWeight]';
	    $condition = '[GalleryItemAttributesMap::itemId] = [GalleryChildEntity::id]';
	    $direction = '';
	}

	return array($orderColumn, $condition, $direction);
    }
}
?>
