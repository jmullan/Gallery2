<?php
/*
 * $RCSfile$
 *
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2003 Bharat Mediratta
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
/**
 * @version $Revision$ $Date$
 * @package GalleryCore
 * @author Bharat Mediratta <bharat@menalto.com>
 */

/**
 * A helper class for GalleryDerivatives
 *
 * Utility functions useful in managing GalleryDerivatives
 *
 * @package GalleryCore
 * @subpackage Helpers
 */
class GalleryDerivativeHelper_advanced {

    /**
     * Load the derivative images that have the specified source id(s) with
     * the type(s) specified
     *
     * @param array GalleryItem ids
     * @param array derivative types (eg, 'DERIVATIVE_TYPE_IMAGE_THUMBNAIL')
     * @return array object GalleryStatus a status code 
     *               array(GalleryItem id => GalleryDerivativeImage, ...)
     * @static
     */
    function fetchDerivativesBySourceIds($ids, $types=array()) {
	require_once(dirname(__FILE__) . '/GalleryDerivativeHelper_medium.class');
	list ($ret, $results) =
		GalleryDerivativeHelper_medium::_loadDerivatives(null, $ids, $types);
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	return array(GalleryStatus::success(), $results);
    }

    /**
     * Remove the given operations from any derivatives that depend on the given ids.  Use case: we've done
     * the "rotate" option on a data item but that data item has a derivative which is being generated using
     * the "crop" operation.  After the rotate, the crop parameters are no longer valid, so we remove it.
     *
     * @param array ids the source ids
     * @param array operation the operations to remove
     * @return object GalleryStatus a status code
     * @static
     */
    function pruneDerivativeOperations($ids, $operations) {
	global $gallery;
	$idMarkers = GalleryUtilities::makeMarkers($ids);

	$query = '
        SELECT
          [GalleryDerivative::id]
        FROM
          [GalleryDerivative]
        WHERE
          [GalleryDerivative::derivativeSourceId] IN (' . $idMarkers . ')
        ';

	list ($ret, $searchResults) = $gallery->search($query, $ids);
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	/* Get all derivative ids */
	$derivativeIds = array();
	while ($result = $searchResults->nextResult()) {
	    $derivativeIds[] = $result[0];
	}

	if (!empty($derivativeIds)) {
	    /* Turn ids into objects */
	    list ($ret, $derivatives) = GalleryCoreApi::loadEntitiesById($derivativeIds);
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }

	    $changed = array();
	    $changedIds = array();
	    foreach ($derivatives as $derivative) {
		$newOperations = array();
		foreach (explode(';', $derivative->getDerivativeOperations()) as $derivativeOperation) {
		    list ($op) = explode('|', $derivativeOperation);
		    if (!in_array($op, $operations)) {
			$newOperations[] = $derivativeOperation;
		    }
		}
		
		$derivative->setDerivativeOperations(join(';', $newOperations));
		if ($derivative->isModified()) {
		    $changed[] = $derivative;
		    $changedIds[] = $derivative->getId();
		}
	    }

	    /* Recurse */
	    $ret = GalleryCoreApi::pruneDerivativeOperations($derivativeIds, $operations);
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }

	    if (sizeof($changed) > 0) {
		/* Save any derivatives that changed */
		list ($ret, $lockIds) = GalleryCoreApi::acquireWriteLock($changedIds);
		if ($ret->isError()) {
		    return $ret->wrap(__FILE__, __LINE__);
		}

		for ($i = 0; $i < sizeof($changed); $i++) {
		    $ret = $changed[$i]->save();
		    if ($ret->isError()) {
			return $ret->wrap(__FILE__, __LINE__);
		    }
		}
	    
		$ret = GalleryCoreApi::releaseLocks($lockIds);
		if ($ret->isError()) {
		    return $ret->wrap(__FILE__, __LINE__);
		}
	    }
	}

	return GalleryStatus::success();
    }

    /**
     * Find all derivatives attached to one source and switch them to another one
     *
     * @param string the original source id
     * @param string the new source id
     * @return object GalleryStatus a status code
     * @static
     */
    function remapSourceIds($originalSourceId, $newSourceId) {
	global $gallery;

	if ($originalSourceId == $newSourceId) {
	    return GalleryStatus::success();
	}

	$query = '
        SELECT
          [GalleryDerivative::id]
        FROM
          [GalleryDerivative]
        WHERE
          [GalleryDerivative::derivativeSourceId] = ?
          AND
          [GalleryDerivative::id] NOT IN (?, ?)
        ';

	list ($ret, $searchResults) = $gallery->search($query, array($originalSourceId,
								     $originalSourceId,
								     $newSourceId));
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	/* Get all derivative ids */
	$derivativeIds = array();
	while ($result = $searchResults->nextResult()) {
	    $derivativeIds[] = $result[0];
	}

	if (!empty($derivativeIds)) {
	    /* Lock them all */
	    list ($ret, $lockId) = GalleryCoreApi::acquireWriteLock($derivativeIds);
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	    
	    /* Turn ids into objects */
	    list ($ret, $derivatives) = GalleryCoreApi::loadEntitiesById($derivativeIds);
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }

	    /* Remap each derivative */
	    foreach ($derivatives as $derivative) {
		$derivative->setDerivativeSourceId($newSourceId);
		$ret = $derivative->expireCache();
		if ($ret->isError()) {
		    return $ret->wrap(__FILE__, __LINE__);
		}

		$ret = $derivative->save();
		if ($ret->isError()) {
		    return $ret->wrap(__FILE__, __LINE__);
		}
	    }

	    /* Release locks */
	    $ret = GalleryCoreApi::releaseLocks($lockId);
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	}

	return GalleryStatus::success();
    }

    /**
     * Copy the derivative preferences from one id to another
     *
     * Note that this doesn't modify pre-existing preferences already assigned
     * to the target.
     *
     * @param int the source id
     * @param int the target id
     * @return object GalleryStatus a status code
     * @static
     */
    function copyPreferences($sourceId, $targetId) {
	list ($ret, $preferences) = GalleryCoreApi::fetchDerivativePreferencesForItem($sourceId);
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	require_once(dirname(__FILE__) . '/../GalleryDerivativePreferencesMap.class');
	foreach ($preferences as $preference) {
	    $ret = GalleryCoreApi::addDerivativePreference($preference['order'],
							   $targetId,
							   $preference['derivativeType'],
							   $preference['derivativeOperations']);
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	}

	return GalleryStatus::success();
    }

    /**
     * Add a derivative preference to a given item
     *
     * @param int the position of this preference
     * @param int the item id
     * @param int the derivative type (eg, DERIVATIVE_TYPE_IMAGE_THUMBNAIL)
     * @param string the derivative operations (eg, 'thumbnail|200')
     * @return object GalleryStatus a status code
     * @static
     */
    function addPreference($order, $itemId, $derivativeType, $derivativeOperations) {
	require_once(dirname(__FILE__) . '/../GalleryDerivativePreferencesMap.class');
	$ret = GalleryDerivativePreferencesMap::addMapEntry(
	    array('order' => $order,
		  'itemId' => $itemId,
		  'derivativeType' => $derivativeType,
		  'derivativeOperations' => $derivativeOperations));
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

    	return GalleryStatus::success();
    }

    /**
     * Remove all derivative preferences for a given item
     *
     * @param int the item id
     * @return object GalleryStatus a status code
     * @static
     */
    function removePreferencesForItem($itemId) {
	require_once(dirname(__FILE__) . '/../GalleryDerivativePreferencesMap.class');
	$ret = GalleryDerivativePreferencesMap::removeMapEntry(array('itemId' => $itemId));
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * Get the derivative preferences for the given item
     *
     * @param int the target id
     * @return array object GalleryStatus a status code
     *               array (derivativeType => ..., derivativeOperations => ...)
     * @static
     */
    function fetchPreferencesForItem($targetId) {
	global $gallery;

	$query = '
        SELECT
          [GalleryDerivativePreferencesMap::order],
          [GalleryDerivativePreferencesMap::derivativeType],
          [GalleryDerivativePreferencesMap::derivativeOperations]
        FROM
          [GalleryDerivativePreferencesMap]
        WHERE
          [GalleryDerivativePreferencesMap::itemId] = ?
        ORDER BY
          [GalleryDerivativePreferencesMap::order] ASC
        ';

	list ($ret, $searchResults) = $gallery->search($query, array($targetId));
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	$data = array();
	while ($result = $searchResults->nextResult()) {
	    $data[] = array('order' => $result[0],
			    'derivativeType' => $result[1],
			    'derivativeOperations' => $result[2]);
	}
	return array(GalleryStatus::success(), $data);
    }

    /**
     * Merge a new operation into this derivative's operation list
     *
     * @see GalleryToolkit::mergeOperation()
     *
     * @param string the command
     * @return object GalleryStatus a status code
     * @static
     */
    function mergeOperation(&$derivative, $newOperation, $newArgs, $headMerge=false) {
	global $gallery;

	/* Load the source */
	list($ret, $source) = GalleryCoreApi::loadEntitiesById($derivative->getDerivativeSourceId());
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	if (GalleryUtilities::isA($source, 'GalleryDerivative')) {
	    $mimeType = $source->getDerivativeMimeType();
	} else {
	    $mimeType = $source->getMimeType();
	}
	$operationString = $derivative->getDerivativeOperations();

	if (empty($operationString)) {
	    $mergedOperations = $newOperation . '|' . join(',', $newArgs);
	} else {
	    /*
	     * Here things get a little tricky.  When merging operations, we want
	     * to try to merge against the last operation first because operations
	     * are cumulative.  However, we can't start from the tail end of the
	     * operations and merge backwards because we don't know what the input
	     * mime type is for the last operation.  So perform a tail recursive merge
	     * on our operations.
	     */
	    $operations = split(';', $operationString);
	    list ($ret, $mergeComplete, $newOperations) =
		GalleryDerivativeHelper_advanced::_recursiveMergeOperation($mimeType,
									   $operations,
									   $newOperation, $newArgs);
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }

	    if (!$mergeComplete) {
		if ($headMerge) {
		    $mergedOperations = $newOperation . '|' . join(',', $newArgs) . ';' . join(';', $operations);
		} else {
		    $mergedOperations = join(';', $operations) . ';' . $newOperation . '|' . join(',', $newArgs);
		}
	    } else {
		$mergedOperations = join(';', $newOperations);
	    }
	}

	$derivative->setDerivativeOperations($mergedOperations);

	return GalleryStatus::success();
    }

    /**
     * Tail-recursively merge a new operation onto an existing set of operations
     *
     * @param string the mime type of the source for the first operation
     * @param array the remaining operations in the sequence
     * @param string the new operation
     * @param array mixed the new operation's args
     * @return array object GalleryStatus a status code
     *               boolean whether the merge was complete or not
     *               array the merged operations
     * @access private
     * @static
     */
    function _recursiveMergeOperation($mimeType, $remainingOperations,
				      $newOperation, $newArgs) {

	if (empty($remainingOperations)) {
	    /* Trivial case -- no operations left means nothing to merge against */
	    return array(GalleryStatus::success(), false, array());
	}

	/*
	 * Pull the first operation off of the queue and get a toolkit that can
	 * handle it.  Use the toolkit to figure out what the mime type is for
	 * the next operation in line.
	 */
	$currentOperation = array_shift($remainingOperations);
	list ($operation, $argString) = split('\|', $currentOperation);
	$args = split(',', $argString);
	list($ret, $toolkit, $outputMimeType) =
	    GalleryCoreApi::getToolkitByOperation($mimeType, $operation);
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null, null);
	}

	/* Give the next operation in line the chance to do the merge. */
	list ($ret, $mergeComplete, $returnedOperations) =
	    GalleryDerivativeHelper_advanced::_recursiveMergeOperation($outputMimeType, $remainingOperations,
								       $newOperation, $newArgs);
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null, null);
	}

	if ($mergeComplete) {
	    /*
	     * If we successfully merged farther on down the line then just
	     * prepend our operation back at the beginning and declare victory.
	     */
	    array_unshift($returnedOperations, $currentOperation);
	    return array(GalleryStatus::success(), true, $returnedOperations);
	} else {

	    if (!isset($toolkit)) {
		/*
		 * There's no applicable toolkit for the current operation.  This
		 * should only happen if a toolkit goes away.  All we can do at
		 * this point is to nuke the invalid operation and hope for the best
		 */
		return array(GalleryStatus::success(), true, $returnedOperations);
	    }
	    
	    /*
	     * No joy farther down the line.  Give the toolkit a chance to
	     * merge against the current operation.
	     *
	     * XXX: We should try this against all toolkits, not just the first
	     * one in line.
	     */
	    list ($mergeComplete, $mergedOperation, $mergedArgs) = 
		$toolkit->mergeOperations($mimeType,
					  $operation, $args,
					  $newOperation, $newArgs);
	    if ($mergeComplete) {
		/* Success -- prepend our merged operation and return the results */
		if (!empty($mergedOperation)) {
		    array_unshift($returnedOperations,
				  $mergedOperation . '|' . join(',', $mergedArgs));
		}
		return array(GalleryStatus::success(), true, $returnedOperations);
	    } else {
		/* No joy -- prepend the current operation and return the results */
		array_unshift($returnedOperations, $currentOperation);
		return array(GalleryStatus::success(), false, $returnedOperations);
	    }
	}
    }

    /**
     * Expire all derivatives that depend on the source ids specified
     *
     * @param array source ids
     * @return object GalleryStatus a status code
     * @static
     */
    function expireDerivativeTreeBySourceIds($ids) {
	global $gallery;

	$idMarkers = GalleryUtilities::makeMarkers($ids);

	$query = '
        SELECT
          [GalleryDerivative::id]
        FROM
          [GalleryDerivative]
        WHERE
          [GalleryDerivative::derivativeSourceId] IN (' . $idMarkers . ')
        ';
	
	list ($ret, $searchResults) = $gallery->search($query, $ids);
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	/* Get all derivative ids */
	$derivativeIds = array();
	while ($result = $searchResults->nextResult()) {
	    $derivativeIds[] = $result[0];
	}

	if (!empty($derivativeIds)) {
	    /* Turn ids into objects */
	    list ($ret, $derivatives) = GalleryCoreApi::loadEntitiesById($derivativeIds);
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }

	    /* Expire each derivative */
	    foreach ($derivatives as $derivative) {
		$ret = $derivative->expireCache();
		if ($ret->isError()) {
		    return $ret->wrap(__FILE__, __LINE__);
		}
	    }

	    /* Repeat the process on the next set of derivatives */
	    $ret = GalleryDerivativeHelper_advanced::expireDerivativeTreeBySourceIds($derivativeIds);
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	}

	return GalleryStatus::success();
    }

    /**
     * Rebuild the cache for the given derivative
     *
     * @param the id of the derivative
     * @return array object GalleryStatus a status code
     *               object GalleryDerivative the rebuilt derivative
     * @static
     */
    function rebuildCache($derivativeId) {
	global $gallery;

	list ($ret, $derivative) = GalleryCoreApi::loadEntitiesById($derivativeId);
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	/* Check to see if we're a broken derivative. */
	$sourceId = $derivative->getDerivativeSourceId();
	if (empty($sourceId)) {
	    return array(GalleryStatus::error(ERROR_BROKEN_DERIVATIVE, __FILE__, __LINE__), null);
	}

	/* Load the source */
	list ($ret, $source) = GalleryCoreApi::loadEntitiesById($sourceId);
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	/* If the source is a derivative, make sure it's current */
	if (GalleryUtilities::isA($source, 'GalleryDerivative')) {
	    list ($ret, $isCurrent) = $source->isCacheCurrent();
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	    if (!$isCurrent) {
		list ($ret, $source) = GalleryDerivativeHelper_advanced::rebuildCache($sourceId);
		if ($ret->isError()) {
		    return array($ret->wrap(__FILE__, __LINE__), null);
		}
	    }
	}

	/*
	 * Rebuild the cache.  Lock it, then refresh it in case it was modified
	 * before we acquired the lock, rebuild it, save it, then release the
	 * lock.
	 */
	list ($ret, $lockId) = GalleryCoreApi::acquireWriteLock($derivativeId, 1);
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}
	
	list ($ret, $derivative) = $derivative->refresh();
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	$ret = $derivative->rebuildCache();
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	$ret = $derivative->save(false);
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	$ret = GalleryCoreApi::releaseLocks($lockId);
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	return array(GalleryStatus::success(), $derivative);
    }
}
?>
