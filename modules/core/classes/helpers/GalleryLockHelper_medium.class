<?php
/*
 * $RCSfile$
 *
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2003 Bharat Mediratta
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
/**
 * @version $Revision$ $Date$
 * @package GalleryCore
 * @author Bharat Mediratta <bharat@menalto.com>
 */

/**
 * The simple version holds the static lock table
 */
require_once(dirname(__FILE__) . '/GalleryLockHelper_simple.class');

/**
 * Helper class for handling locking
 *
 * @package GalleryCore
 * @subpackage Helpers
 * @abstract
 */
class GalleryLockHelper_medium {

    /**
     * Read Lock one or more objects
     *
     * @access public
     * @param array ids to lock
     * @param integer how long to wait for the lock before giving up
     * @return array object GalleryStatus a status code
     *               int the lock id
     * @static
     */
    function acquireReadLock($ids, $timeout=10) {
	if (!is_array($ids)) {
	    $ids = array($ids);
	}
	
	list ($ret, $lockId) = GalleryLockHelper_medium::_acquireLock($ids, $timeout, LOCK_READ);
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	return array(GalleryStatus::success(), $lockId);
    }

    /**
     * Acquire read locks on all the parents of this id.  This is useful when
     * we're going to do a filesystem related operation and we want to make
     * sure that the tree does not change out from underneath us.
     *
     * @access public
     * @param integer an id to lock
     * @param integer how long to wait for the lock before giving up
     * @return array object GalleryStatus a status code
     *               object GalleryLock a lock
     * @static
     */
    function acquireReadLockParents($id, $timeout=10) {
	global $gallery;

	/*
	 * The current id may not be an item, in which case it has no direct parent sequence.  But its parent
	 * should be an item, so the surefire way to get the parent sequence in one shot is to get the
	 * parent's parent sequence and then tack on the parent id.
	 */

	$storage =& $gallery->getStorage();

	/* Get the parent entity id */
	$query = '
        SELECT
          [GalleryItemAttributesMap::itemId],
          [GalleryItemAttributesMap::parentSequence]
        FROM
          [GalleryChildEntity], [GalleryItemAttributesMap]
        WHERE
          [GalleryChildEntity::id] = ?
          AND
          [GalleryChildEntity::parentId] = [GalleryItemAttributesMap::itemId]
        ';

	list ($ret, $searchResults) = $gallery->search($query, array($id));
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}
	
	if ($searchResults->resultCount() == 0) {
	    /* No parents.  This can only happen when the item is the root */
	    list ($ret, $rootId) = GalleryCoreApi::getPluginParameter('module', 'core', 'id.rootAlbum');
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }

	    if ($id == $rootId) {
		return array(GalleryStatus::success(), null);
	    } else {
		/* This should never happen! */
		return array(GalleryStatus::error(ERROR_MISSING_OBJECT, __FILE__, __LINE__, "Id: $id"), null);
	    }
	}
	
	/* Extract the parent ids */
	$parentIds = array();
	while ($result = $searchResults->nextResult()) {
	    $parentIds = preg_split('/\//', $result[1], -1, PREG_SPLIT_NO_EMPTY);
	    $parentIds[] = $result[0];
	}

	/* Get rid of any locks we already have */
	$tmp = array();
	foreach ($parentIds as $id) {
	    if (!GalleryLockHelper_medium::isReadLocked($id) &&
		!GalleryLockHelper_medium::isWriteLocked($id)) {
		$tmp[] = $id;
	    }
	}
	$parentIds = $tmp;
	
	if (empty($parentIds)) {
	    /* No locks required */
	    return array(GalleryStatus::success(), null);
	}

	/* Read lock the parents */
	list ($ret, $lock) = GalleryLockHelper_medium::acquireReadLock($parentIds, $timeout);
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	return array(GalleryStatus::success(), $lock);
    }

    /**
     * Return true if the given id is read locked or write locked.
     *
     * @access public
     * @param int an entity id
     * @return boolean true if the entity is read locked
     * @static
     */
    function isReadLocked($id) {
	$locks =& GalleryLockHelper_simple::_getLocks();
	foreach (array_keys($locks) as $lockId) {
	    $lock =& $locks[$lockId];
	    if (in_array($id, $lock['ids'])) {
		return true;
	    }
	}

	return false;
    }

    /**
     * Write lock one or more objects
     *
     * @access public
     * @param array ids to lock
     * @param integer how long to wait for the lock before giving up
     * @return array object GalleryStatus a status code
     *               int the lock id
     * @static
     */
    function acquireWriteLock($ids, $timeout=10) {
	if (!is_array($ids)) {
	    $ids = array($ids);
	}

	list ($ret, $lockId) = GalleryLockHelper_medium::_acquireLock($ids, $timeout, LOCK_WRITE);
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	return array(GalleryStatus::success(), $lockId);
    }

    /**
     * Return true if the given id is write locked
     *
     * @access public
     * @param int an entity id
     * @return boolean true if the entity is write locked
     * @static
     */
    function isWriteLocked($id) {
	$locks =& GalleryLockHelper_simple::_getLocks();

	foreach (array_keys($locks) as $lockId) {
	    $lock =& $locks[$lockId];
	    if ($lock['type'] == LOCK_WRITE && in_array($id, $lock['ids'])) {
		return true;
	    }
	}

	return false;
    }

    /**
     * Release the given lock(s)
     *
     * @param array a list of lock ids, or a single lock id
     * @return object GalleryStatus a status code
     * @static
     */
    function releaseLocks($lockIds) {
	global $gallery;
	
	if (!is_array($lockIds)) {
	    $lockIds = array($lockIds);
	}

	$locks =& GalleryLockHelper_simple::_getLocks();

	/* Check all parameters before starting to release locks */
	foreach ($lockIds as $lockId) {
	    if (empty($lockId)) {
		continue;
	    }
	    
	    if (!isset($locks[$lockId])) {
		return GalleryStatus::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__);
	    }
	}

	/* Now release all locks */
	$platform = $gallery->getPlatform();
	foreach ($lockIds as $lockId) {
	    if (empty($lockId)) {
		continue;
	    }
	    
	    $gallery->guaranteeTimeLimit(5);
	    foreach ($locks[$lockId]['fds'] as $fd) {
		$platform->fclose($fd);
	    }
	    unset($locks[$lockId]);
	}

	return GalleryStatus::success();
    }

    /**
     * Let go of all of our locks.
     *
     * @return object GalleryStatus a status code
     * @access private
     * @static
     */
    function releaseAllLocks() {
	global $gallery;

	$locks =& GalleryLockHelper_simple::_getLocks();
	$platform = $gallery->getPlatform();
	foreach (array_keys($locks) as $lockId) {
	    $gallery->guaranteeTimeLimit(5);
	    foreach ($locks[$lockId]['fds'] as $fd) {
		$platform->fclose($fd);
	    }
	    unset($locks[$lockId]);
	}

	return GalleryStatus::success();
    }

    /**
     * Refresh all the locks that we hold so that they aren't accidentally considered expired
     *
     * @param int the new "fresh until" timestamp
     * @return object GalleryStatus a status code
     * @static
     */
    function refreshLocks($freshUntil) {
	global $gallery;

	$locks =& GalleryLockHelper_simple::_getLocks();

	// Flush one byte to each lock file to update its timestamp
	$platform = $gallery->getPlatform();
	foreach ($locks as $lockId => $lock) {
	    foreach ($lock['fds'] as $fd) {
		$count = $platform->fwrite($fd, '.');
		if ($count == 0) {
		    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
		}
		$platform->fflush($fd);
	    }
	}
    }

    /**
     * Delete the lock file for a given id.
     *
     * WARNING: use this only when the entity goes away -- it's possible to delete a lock file out from
     * underneath a process that still has it acquired!
     */
    function deleteLockFile($id) {
	global $gallery;

	$lockFile = GalleryLockHelper_medium::_getLockFile($id);
	$platform = $gallery->getPlatform();
	@$platform->unlink($lockFile);
    }

    /**
     * Return the lock file for a given entity id
     *
     * @param int the input id
     * @return string the complete path to the lock file
     */
    function _getLockFile($id) {
	global $gallery;
	
	$locksDir = $gallery->getConfig('data.gallery.locks');
	$tmp = "$id";
	if ($id < 100) {
	    $first = '0';
	    $second = $tmp[0];
	} else {
	    $first = $tmp[0];
	    $second = $tmp[1];
	}
	
	return "$locksDir$first/$second/$id";
    }

    /**
     * Read Lock one or more objects
     *
     * @access public
     * @param array ids to lock
     * @param integer how long to wait for the lock before giving up
     * @param the type of lock (LOCK_READ, LOCK_WRITE)
     * @return array object GalleryStatus a status code
     *               int the lock id
     * @access private
     * @static
     */
    function _acquireLock($ids, $timeout, $lockType) {
	global $gallery;

	$locks =& GalleryLockHelper_simple::_getLocks();
	$cutoffTime = time() + $timeout;

	$platform = $gallery->getPlatform();

	// Get a file handle for all the files first
	$notLocked = array();
	foreach ($ids as $id) {
	    $lockFile = GalleryLockHelper_medium::_getLockFile($id);
	    $fd = $platform->fopen($lockFile, 'wb+');
	    if ($fd) {
		$notLocked[] =& $fd;
	    } else {
		foreach ($open as $fd) {
		    $platform->fclose($fd);
		}
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	    }
	}

	// Move them from notLocked -> locked as we acquire the lock
	$locked = array();
	$wouldBlock = null;
	while (!empty($notLocked)) {
	    $tmp = $notLocked;
	    $notLocked = array();
	    foreach ($tmp as $fd) {
		$flockType = ($lockType == LOCK_READ) ? LOCK_SH : LOCK_EX;
		if (flock($fd, $flockType | LOCK_NB, $wouldBlock)) {
		    $locked[] = $fd;
		} else {
		    // Remember that it's not locked and keep going
		    $notLocked[] = $fd;
		}
	    }

	    if (!empty($notLocked)) {
		if (time() > $cutoffTime) {
		    foreach (array_merge($locked, $notLocked) as $fd) {
			$platform->fclose($fd);
		    }
		    return array(GalleryStatus::error(ERROR_LOCK_TIMEOUT, __FILE__, __LINE__), null);
		}

		// Wait a second and try any unacquired locks again
		sleep(1);
	    }
	}

	$lockId = md5(microtime());
	$locks[$lockId] = array('type' => $lockType,
				'ids' => $ids,
				'fds' => $locked);
	return array(GalleryStatus::success(), $lockId);
    }
}