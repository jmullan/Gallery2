<?php
/*
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2002 Bharat Mediratta
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

/* Load the parent class */
require_once(dirname(__FILE__) . '/GalleryItem.class');

/**
 * A subclass of GalleryItem for items containing actual data
 *
 * DataItems are ones that have an actual data source, such as 
 * PhotoItem or MovieItem.
 *
 * @g2 <class-name>GalleryDataItem</class-name>
 * @g2 <schema>
 * @g2   <schema-major>1</schema-major>
 * @g2   <schema-minor>0</schema-minor>
 * @g2 </schema>
 * @g2 <requires-id/>
 *
 * @version $Id$
 * @package GalleryCore
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class GalleryDataItem_core extends GalleryItem {

    /*
     * ****************************************
     *                 Members
     * ****************************************
     */

    /**
     * The file extension of the data file
     *
     * @g2 <member>
     * @g2   <member-name>fileExtension</member-name>
     * @g2   <member-type>STRING</member-type>
     * @g2 </member>
     *
     * @var string $_fileExtension
     * @access private
     */
    var $_fileExtension;

    /**
     * The mime type of the data file
     *
     * @g2 <member>
     * @g2   <member-name>mimeType</member-name>
     * @g2   <member-type>STRING</member-type>
     * @g2 </member>
     *
     * @var string $_mimeType
     * @access private
     */
    var $_mimeType;

    /*
     * ****************************************
     *                 Methods
     * ****************************************
     */

    /**
     * Create a new instance of this type in the persistent store.
     *
     * @access public
     * @param int the id of the parent GalleryItem
     * @param string the path to a data file to be contained
     * @param int the owner of the new item
     * @param string the desired name of the new item
     * @return object GalleryStatus a status code
     */
    function create($parentId, $inputFileName, $ownerId, $targetName=null) {
	global $gallery;
	list($ret, $platform) = $gallery->getPlatform();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	/* Validate the input file */
	if (empty($inputFileName)) {
	    return GalleryStatus::error(ERROR_BAD_PARAMETER,
					__FILE__, __LINE__);
	}

	if (!$platform->file_exists($inputFileName)) {
	    return GalleryStatus::error(ERROR_BAD_PATH,
					__FILE__, __LINE__);
	}
	
	/*
	 * The parent must be read locked at this point to make sure that it's
	 * not going to be moved around while we're adding stuff to it.
	 */
	if (!$gallery->isReadLocked($parentId)) {
	    return GalleryStatus::error(ERROR_LOCK_REQUIRED,
					__FILE__, __LINE__);
	}
	
	/* Figure out the new location for this file */
	list($ret, $parent) = $gallery->loadEntitiesById($parentId);
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	list($ret, $parentPath) = $parent->fetchContainerPath($parent);
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}
	
	if (empty($targetName)) {
	    $baseName = basename($inputFileName);
	} else {
	    $baseName = basename($targetName);

	    /* If we change the name, try to preserve the file tag */
	    $baseName = $baseName . '.' .
		    GalleryUtilities::getFileExtension($inputFileName);
	}
	$pathComponent = substr($baseName, 0, strrpos($baseName, '.'));
	$newFileName = $parentPath . $baseName;

	/* Do a collision check */
	if ($platform->file_exists($newFileName)) {
	    return GalleryStatus::error(ERROR_COLLISION,
					__FILE__, __LINE__);
	}
	
	/*
	 * XXX: Race condition here!  It's possible for two threads to be
	 * adding a file with the same name to the container at the same time.
	 * We have to write lock the container to be sure that this doesn't
	 * happen.
	 */
	/* Copy the file to its new location */
	if (!$platform->copy($inputFileName, $newFileName)) {
	    return GalleryStatus::error(ERROR_PLATFORM_FAILURE,
					__FILE__, __LINE__);
	}

	$ret = parent::create($parentId, $pathComponent, $ownerId);
	if ($ret->isError()) {
	    $platform->unlink($newFileName);
	    return $ret->wrap(__FILE__, __LINE__);
	}

	/* Set my mime type and file extension */
	$this->setMimeType(GalleryUtilities::getMimeType($inputFileName));
	$this->setFileExtension(GalleryUtilities::getFileExtension($inputFileName));

	return GalleryStatus::success();
    }

    /**
     * Delete this GalleryEntity
     *
     * @access public
     * @return object GalleryStatus a status code
     */
    function delete() {
	global $gallery;

	/*
	 * XXX: Check for derivative relationships and expire as necessary.
	 */

	/* Delete myself */
	$ret = parent::delete();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	/* Delete our source file */
	list($ret, $path) = $this->fetchPath();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}
	
	list($ret, $platform) = $gallery->getPlatform();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}
	
	$ret = $platform->unlink($path);
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }


    /**
     * Get the size of the source object.  
     * 
     * @access public
     * @return array object GalleryStatus a status code
     *               int the size of the object, -1 if unknown
     */
    function fetchSize() {
	global $gallery;
	list($ret, $platform) = $gallery->getPlatform();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	list($ret, $path) = $this->fetchPath();
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), false);
	}
	
	if ($platform->file_exists($path)) {
	    $size = $platform->filesize($path);
	} else {
	    $size = -1;
	}

	return array(GalleryStatus::success(), $size);
    }

    /**
     * Get the full path to the data file.
     *
     * @access public
     * @return array object GalleryStatus a status code,
     *               string a path where children can store their data files
     */
    function fetchPath() {
	global $gallery;

	/*
	 * Source files in the item's directory.  But the parent may be an item
	 * that doesn't have its own directory, so we need to get the path of
	 * the nearest parent who is a container (eg an AlbumItem), because a
	 * container has a directory for the items it contains.
	 */
	list($ret, $containerPath) = $this->fetchContainerPath();
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}
	
	return array(GalleryStatus::success(),
		     $containerPath . 
		     $this->getPathComponent() .
		     '.' .
		     $this->getFileExtension());
    }
}

include(dirname(__FILE__) . '/interfaces/GalleryDataItem.inc');
?>
