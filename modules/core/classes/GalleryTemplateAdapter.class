<?php
/*
 * $RCSfile$
 *
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2005 Bharat Mediratta
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
/**
 * @version $Revision$ $Date$
 * @package GalleryCore
 * @author Bharat Mediratta <bharat@menalto.com>
 */

/**
 * This class is a glue layer between the templating system and our various
 * callbacks that generate URLs, localized text, dates, themed widgets, etc.
 *
 * @package GalleryCore
 * @subpackage Classes
 */
class GalleryTemplateAdapter {

    /**
     * The active theme
     *
     * @var object GalleryTheme a theme instance
     * @access private
     */
    var $_theme;

    /**
     * The number of times our block callbacks have been executed
     * @var array _callCount
     */
    var $_callCount;

    /**
     * Custom smarty blocks registered by other modules
     *
     * @var array _blocks
     * @access private
     */
    var $_blocks;

    /**
     * Constructor
     */
    function GalleryTemplateAdapter() {
	$this->_callCount = $this->_blocks = array();
    }

    /**
     * Set the active theme
     *
     * @param object GalleryTheme
     */
    function setTheme($theme) {
	$this->_theme = $theme;
    }

    /**
     * Get the active theme
     *
     * @return object GalleryTheme
     */
    function getTheme() {
	return $this->_theme;
    }

    /*************************************************************
     * Special purpose template callback methods.
     *************************************************************/

    /**
     * @see GalleryUrlGenerator::generateUrl()
     *
     * Return a valid Gallery URL, standalone or embedded.
     *
     * @param array data in key/value pairs
     * @return string a URL
     */
    function url($params, &$smarty) {
	global $gallery;

	if (isset($params['href'])) {
	    $hrefParams = array('href' => $params['href']);
	} else if (isset($params['params'])) {
	    /* All the user to pass in bulk params */
	    $hrefParams = $params['params'];
	} else {
	    $hrefParams = array();

	    /* Search for args and add them to the params */
	    $i = 1;
	    while (isset($params['arg' . $i])) {
		list ($key, $value) = explode('=', $params['arg' . $i]);
		$hrefParams[$key] = $value;
		$i++;
	    }
	}

	if (isset($params['forceSessionId'])) {
	    $forceSessionId = $params['forceSessionId'];
	} else {
	    $forceSessionId = null;
	}

	$urlGenerator =& $gallery->getUrlGenerator();
	$url = $urlGenerator->generateUrl($hrefParams, $forceSessionId);

	if (!empty($params['forJavascript'])) {
	    $url = str_replace('&amp;', '&', $url);
	}

	return $url;
    }

    /**
     * Return any hidden form variables that we want to embed in this form based on the
     * current session and request context.  We use this to pass the special "return" variable
     * forward, for example.
     *
     * @param array data in key/value pairs
     * @return a series of XHTML 1.0 compliant <input> elements
     */
    function hiddenFormVars($params, &$smarty) {
	global $gallery;
	$urlGenerator =& $gallery->getUrlGenerator();
	$vars = array();

	/* The 'return' url */
	if (GalleryUtilities::hasRequestVariable('return')) {
	    $vars['return'] = GalleryUtilities::getRequestVariables('return');
	}

	/* Remember the current url for getting back to where we came from */
	if (empty($vars['return'])) {
	    $currentView = $gallery->getCurrentView();
	    list ($ret, $view) = GalleryView::loadView($currentView);
	    if ($ret->isError()) {
		$viewDescription = '';
	    } else {
		list ($ret, $viewDescription) = $view->getViewDescription();
		if ($ret->isError()) {
		    $viewDescription = '';
		}
	    }
	    $vars['returnName'] = $viewDescription;
	    $vars['return'] = $urlGenerator->getNavigationReturnUrl();
	}

	/* Our navigation id */
	$navigationId = $urlGenerator->getNavigationId();
	if (!empty($navigationId)) {
	    $vars['navId'] = $navigationId;
	    unset($vars['return']);
	}

	/* Remember the original URL where this form was first shown */
	$vars['formUrl'] = GalleryUtilities::getRequestVariables('formUrl');
	if (empty($vars['formUrl'])) {
	    /* First time we load this form */
	    $vars['formUrl'] = $urlGenerator->getNavigationReturnUrl();
	}

	$out = '';
	foreach ($vars as $key => $value) {
	    $out .= sprintf('<input type="hidden" name="%s" value="%s"/>' . "\n",
			   GalleryUtilities::prefixFormVariable($key),
			   $value);
	}
	return $out;
    }

    /**
     * Return a valid Gallery date.
     *
     * @todo This needs to be refactored.
     *
     * @param array data in key/value pairs
     * @return string a URL
     */
    function date($params, &$smarty) {
	global $gallery;

	if (empty($params['format'])) {
	    $params['format'] = '%x';
	}

	return strftime($params['format'], $params['timestamp']);
    }

    /**
     * @see GalleryTranslator::translate()
     */
    function text($params, &$smarty) {
	global $gallery;

	if (isset($params['l10Domain'])) {
	    $domain = $params['l10Domain'];
	} else {
	    $domain = $smarty->_tpl_vars['l10Domain'];
	}
	$translator =& $gallery->getTranslator();
	list ($ret, $text) = $translator->translateDomain($domain, $params);
	if ($ret->isError()) {
	    return $ret->getAsHtml();
	    return "[Translation error]";
	}

	if (!empty($params['forJavascript'])) {
	    $text = str_replace("'", "\\'", $text);
	}

	return $text;
    }

    /**
     * Return a transformed element name, useful when we're trying to use
     * Javascript to access a form element.
     *
     * @param array key => value attributes
     * @return HTML content
     */
    function formVar($params) {
	return GalleryUtilities::prefixFormVariable($params['var']);
    }

    /**
     * Delegate to the appropriate item class to render an image.
     *
     * @param array containing item, image, id, name, fallback
     * @param object Smarty the smarty instance
     * @return string HTML content
     */
    function image($params, &$smarty) {
 	global $gallery;

	/* Ask the entity to render itself in HTML */
	list ($ret, $item) = GalleryCoreApi::loadEntitiesById($params['item']['id']);
	if ($ret->isError()) {
	    /* TODO: is there a more graceful way to handle this? */
	    return '[Render error: missing item]';
	}

	list ($ret, $entity) = GalleryCoreApi::loadEntitiesById($params['image']['id']);
	if ($ret->isError()) {
	    /* TODO: is there a more graceful way to handle this? */
	    return '[Render error: missing entity]';
	}

	if (!isset($params['maxSize'])) {
	    $params['maxSize'] = null;
	}

	if (!isset($params['class'])) {
	    $params['class'] = null;
	}

	if (!isset($params['id'])) {
	    $params['id'] = null;
	}

	if (!isset($params['name'])) {
	    $params['name'] = null;
	}

	if (!isset($params['imgmap'])) {
	    $params['imgmap'] = null;
	}

	if (!isset($params['fallback'])) {
	    $params['fallback'] = null;
	}

	if ($entity->getId() == $item->getId()) {
	    $html = $item->render('HTML', array('class' => $params['class'],
						'id' => $params['id'],
						'name' => $params['name'],
						'maxSize' => $params['maxSize'],
						'fallback' => $params['fallback'],
						'imgmap' => $params['imgmap']));
	} else {
	    $html = $entity->render('HTML', $item,
				    array('class' => $params['class'],
					  'id' => $params['id'],
					  'name' => $params['name'],
					  'maxSize' => $params['maxSize'],
					  'fallback' => $params['fallback'],
					  'imgmap' => $params['imgmap']));
	}

	if (empty($html)) {
	    /*
	     * TODO: We should let the {g->image} tag provide some kind of fallback in case
	     * the image can't be rendered.
	     */
	    return $params['fallback'];
	}

	return $html;
    }

    /**
     * Allow the current theme to return any style tags
     *
     * @param array
     * @param object Smarty the smarty instance
     * @return string HTML content
     */
    function style($params, &$smarty) {
	return $this->_theme->style($params, $smarty);
    }

    /**
     * Include our AutoCompletion template.
     *
     * @param array
     * @param string content
     * @param object Smarty the smarty instance
     * @return string HTML content
     */
    function autoComplete($params, $content, &$smarty) {
	if (!isset($content)) {
	    if (!isset($this->_callCount['autoComplete'])) {
		$this->_callCount['autoComplete'] = 0;
	    }
	    return;
	}
	$this->_callCount['autoComplete']++;
	$url = trim($content);
	return $smarty->_smarty_include(
	    array('smarty_include_tpl_file' => 'gallery:modules/core/templates/AutoComplete.tpl',
		  'smarty_include_vars' =>
			array('element' => $params['element'],
			      'url' => $url,
			      'callCount' => $this->_callCount['autoComplete'])));
    }

    /**
     * Include form inputs for dimensions.
     *
     * @param array params
     * @param object Smarty the smarty instance
     * @return string HTML content
     */
    function dimensions($params, &$smarty) {
	if (!isset($this->_callCount['dimensions'])) {
	    $this->_callCount['dimensions'] = 0;
	}
	return $smarty->_smarty_include(
	    array('smarty_include_tpl_file' => 'gallery:modules/core/templates/Dimensions.tpl',
		  'smarty_include_vars' => array(
				 'formVar' => $params['formVar'],
				 'width' => isset($params['width']) ? $params['width'] : null,
				 'height' => isset($params['height']) ? $params['height'] : null,
				 'callCount' => ++$this->_callCount['dimensions'])));
    }

    /**
     * Register a new block callback.
     * Use {g->block type="blocktype"}..{/g->block} in a template to call the block.
     *
     * @param string block type
     * @param callback function to call
     */
    function register_block($blockType, $callback) {
	$this->_blocks[$blockType] = $callback;
    }

    /**
     * A smarty block callback to support block functions registered by modules.
     *
     * @param array data in key/value pairs
     * @param string content inside the block
     * @param object Smarty
     */
    function block($params, $content, &$smarty) {
	if (!isset($content)) {
	    return;
	}
	if (empty($params['type']) || empty($this->_blocks[$params['type']])) {
	    return $content;
	}
	$callback = $this->_blocks[$params['type']];
	if (is_array($callback)) {
	    list ($object, $function) = $callback;
	    if (!is_object($object)) {
		$object = new $object();
	    }
	    return $object->$function($params, $content, $smarty);
	} else {
	    return $function($params, $content, $smarty);
	}
    }
}
?>
