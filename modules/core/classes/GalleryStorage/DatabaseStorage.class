<?php
/*
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2002 Bharat Mediratta
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

/*
 * Require the ADOdb libraries
 */
global $gallery;
require_once($gallery->getConfig('code.gallery.lib') . '/adodb/adodb.inc.php');
require_once(dirname(__FILE__) . '/DatabaseStorage/ErrorHandler.inc');

/**
 * Name of the sequence we'll use for GalleryEntity ids
 */
define('DATABASE_SEQUENCE_ID', 'sequence_id');

/**
 * Name of the sequence we'll use for lock ids
 */
define('DATABASE_SEQUENCE_LOCK', 'sequence_lock');

/**
 * Default prefix to prepend to table names
 */
define('DATABASE_TABLE_PREFIX', 'g2_');

/**
 * Default prefix to prepend to column names
 */
define('DATABASE_COLUMN_PREFIX', 'g_');

/**
 * Database connection states
 */
define('DATABASE_STATUS_NOT_CONNECTED', 0);
define('DATABASE_STATUS_CONNECTED', 1);

/**
 * Database implementation of the GalleryStorage interface.
 *
 * This strategy implements the hooks for saving and restoring GalleryEntity
 * objects in a relational database.
 *
 * @version $Id$
 * @package GalleryStorage
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class DatabaseStorage extends GalleryStorage {

    /**
     * Internal pointer to ADOdb database object
     *
     * @var object ADOdb $_db
     * @access private
     */
    var $_db;

    /**
     * Name of the database user
     * 
     * @var string $_username
     * @access private
     */
    var $_username;
    
    /**
     * Password for the database user
     * 
     * @var string $_password
     * @access private
     */
    var $_password;
    
    /**
     * Name of the database to use
     * 
     * @var string $_database
     * @access private
     */
    var $_database;

    /**
     * Host the database runs on
     * 
     * @var string $_hostname
     * @access private
     */
    var $_hostname;

    /**
     * A DatabaseSchema instance, used to check and update the schema
     * 
     * @var object DatabaseSchema an instance of the DatabaseSchema class
     * @access private
     */
    var $_databaseSchema;

    /**
     * Status of the database connection
     * 
     * @var int status
     * @access private
     */
    var $_connectionStatus;

    /**
     * The capabilities available in this version of the database software
     *
     * @var array $_capabilities
     * @access private
     */
    var $_capabilities;

    /**
     * A mapping of id to object type, useful when we are going to do multiple
     * lookups on the same object.
     *
     * @var array $_entityTypeCache
     * @access private
     */
    var $_entityTypeCache;

    /**
     * A string to prepend to table names
     *
     * @var string $_tablePrefix
     * @access private
     */
    var $_tablePrefix;

    /**
     * A string to prepend to column names
     *
     * @var string $_columnPrefix
     * @access private
     */
    var $_columnPrefix;

    /**
     * Constructor.
     *
     * @param array database configuration values
     */
    function DatabaseStorage($config) {
	$this->GalleryStorage();
	$this->_connectionStatus = DATABASE_STATUS_NOT_CONNECTED;

	$this->_username = $config['username'];
	$this->_password = $config['password'];
	$this->_hostname = $config['hostname'];
	$this->_database = $config['database'];

	if (isset($config['tablePrefix'])) {
	    $this->_tablePrefix = $config['tablePrefix'];
	} else {
	    $this->_tablePrefix = DATABASE_TABLE_PREFIX;
	}

	if (isset($config['columnPrefix'])) {
	    $this->_columnPrefix = $config['columnPrefix'];
	} else {
	    $this->_columnPrefix = DATABASE_COLUMN_PREFIX;
	}

	if (isset($config['capabilities'])) {
	    $this->_capabilities = $config['capabilities'];
	} else {
	    $this->_capabilities = array();
	}
    }

    /**
     * Do any initialization that is required by this class
     *
     * @return object GallerySatus a status code
     */
    function init() {
	return $this->_connect();
    }
    
    /**
     * Connect to the database
     *
     * @return object GalleryStatus a status code
     * @access private
     */
    function _connect() {
	global $gallery;
	
	if (empty($this->_username) || empty($this->_hostname)) {
	    return GalleryStatus::error(ERROR_MISSING_VALUE,
					__FILE__, __LINE__);
	}

	$this->_traceStart();
	$this->_db = ADONewConnection($this->getType());
	$this->_traceStop();
	if (empty($this->_db)) {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE,
					__FILE__, __LINE__);
	}

	/*
	 * Turn on debugging in the database connection if Gallery is in debug
	 * mode
	 */
	if ($gallery->getDebug()) {
	    $this->_db->debug = true;
	}

	$this->_traceStart();
	$ret = $this->_db->PConnect($this->_hostname,
				    $this->_username,
				    $this->_password,
				    $this->_database);
	$this->_traceStop();

	if (!$ret) {
	    $this->_connectionStatus = DATABASE_STATUS_NOT_CONNECTED;
	    $this->_db = null;
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE,
					__FILE__, __LINE__);
	} else {
	    $this->_connectionStatus = DATABASE_STATUS_CONNECTED;
	}


	return GalleryStatus::success();
    }

    /**
     * Turn debugging on or off.
     */
    function setDebug($bool) {
	parent::setDebug($bool);

	/* Flip the switch in the ADOdb class, also */
	if ($this->_debug) {
	    $this->_db->debug = true;
	} else {
	    $this->_db->debug = false;
	}
    }

    /**
     * Load the GalleryEntities with the ids specified
     *
     * @param mixed the ids (or id) of the GalleryEntities to load
     * @return array object GalleryStatus a status code,
     *               mixed one GalleryEntity or an array of GalleryEntities
     */
    function loadEntities($ids) {
	global $gallery;
	
	if ($this->_connectionStatus != DATABASE_STATUS_CONNECTED) {
	    return array(GalleryStatus::error(ERROR_STORAGE_CONNECTION,
					      __FILE__, __LINE__),
			 null);
	}

	if (is_array($ids)) {
	    $returnArray = true;
	} else {
	    $returnArray = false;
	    $ids = array($ids);
	}

	/* Identify all the ids at once */
	list ($ret, $types) = $this->_identifyEntities($ids);
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	/* Separate the ids by type */
	$classNames = array();
	for ($i = 0; $i < sizeof($ids); $i++) {
	    if (empty($types[$i])) {
		$gallery->debug("Missing object for id $ids[$i]");
		return array(GalleryStatus::error(ERROR_MISSING_OBJECT,
						  __FILE__, __LINE__),
			     null);
	    }
	    $classNames[$types[$i]][] = $ids[$i];
	}

	/* Load them in groups */
	foreach ($classNames as $className => $targetIds) {
	    /* Get our member info for this class */
	    list ($ret, $memberInfo) = $this->_describeEntityMembers($className);
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	    
	    $idCol = $this->_prefixColumnName('id');


	    /* Build up our query */
	    $columns = array();
	    $tables = array();
	    $where = array();
	    $types = array();
	    $callbacks = array();
	    $markers = GalleryUtilities::makeMarkers(sizeof($targetIds));
	    foreach ($memberInfo['members'] as $columnName => $columnInfo) {
		$tableName = $this->_prefixTableName($columnInfo['class']);
		$types[] = $columnInfo['type'];
		$callbacks[] = 'set' . ucFirst($columnName);
		$columns[$tableName . '.' . $this->_prefixColumnName($columnName)] = 1;
		$tables[$tableName] = 1;
	    }
	    $tables = array_keys($tables);
	    $columns = array_keys($columns);
	    
	    for ($i = 0; $i < sizeof($tables); $i++) {
		if ($i == 0) {
		    $where[] = $tables[$i] . '.' . $idCol .
			' IN (' . $markers . ')';
		} else {
		    $where[] = $tables[$i] . '.' . $idCol . '=' .
			$tables[0] . '.' . $idCol;
		}
	    }
	    
	    $query = 'SELECT ';
	    $query .= join(', ', $columns);
	    $query .= ' FROM ';
	    $query .= join(', ', $tables);
	    $query .= ' WHERE ';
	    $query .= join(' AND ', $where);

	    /* Execute the query */
	    $GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;
	    $this->_traceStart();
	    $recordSet = $this->_db->Execute($query, $targetIds);
	    $this->_traceStop();
	    if ($recordSet) {
		if ($recordSet->RecordCount() != sizeof($targetIds)) {
		    return array(GalleryStatus::error(ERROR_MISSING_OBJECT,
						      __FILE__, __LINE__),
				 null);
		}

		/* Process all the results */
		while ($row = $recordSet->FetchRow()) {
		    $entity = new $className;
		    if (empty($entity)) {
			return array(GalleryStatus::error(ERROR_BAD_DATA,
							  __FILE__, __LINE__),
				     null);
		    }

		    for ($i = 0; $i < sizeof($callbacks); $i++) {
			$value = $row[$i];
		    
			/* Convert the database representation to a timestamp */
			if ($types[$i] & STORAGE_TYPE_TIMESTAMP) {
			    $value = $this->_db->UnixTimeStamp($value);
			}
			
			/* Store the value in the object */
			$entity->$callbacks[$i]($value);
		    }

		    $entity->clearModifiedFlags();
		    $entities[$entity->getId()] = $entity;
		}
		$recordSet->Close();
	    } else {
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE,
						  __FILE__, __LINE__),
			     null);
	    }
	}

	/* Assemble the entities in the right order and return them */
	$result = array();
	foreach ($ids as $id) {
	    $result[] = $entities[$id];
	}

	if (!$returnArray) {
	    $result = $result[0];
	}
	return array(GalleryStatus::success(), $result);
    }

    /**
     * Save the changes to the GalleryEntity.
     *
     * @access public
     * @param object GalleryEntity reference to the GalleryEntity to save
     * @return object GalleryStatus a status code
     */
    function saveEntity(&$entity) {
	if ($this->_connectionStatus != DATABASE_STATUS_CONNECTED) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION,
					__FILE__, __LINE__);
	}

	/*
	 * Update the serial number, but remember the original one
	 */
	$originalSerialNumber = $entity->getSerialNumber();
	$entity->setSerialNumber($originalSerialNumber + 1);

	/*
	 * Get our member info for this class
	 */
	list ($ret, $memberInfo) = $this->_describeEntityMembers(get_class($entity));
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}
	$idColumn = null;

	/*
	 * Build up a complete picture of all the various changed fields, so
	 * that we can do an insert or update.
	 */
	$dataTable = array();
	$id = array();
	foreach ($memberInfo['members'] as $memberName => $memberData) {
	    $type = $memberData['type'];
	    $class = $memberData['class'];
	    $tableName = $this->_prefixTableName($class);

	    /* If the member is modified, record the new value in our table */
	    if ($entity->getModifiedFlag($memberName) & MEMBER_MODIFIED) {
		$getFunc = 'get' . $memberName;
		$value = $entity->$getFunc();

		/* Convert empty values to null */
		if (empty($value)) {
		    $value = null;
		}

		/* Convert timestamps to the database representation */
		if ($type & STORAGE_TYPE_TIMESTAMP) {
		    $value = $this->_db->DBTimeStamp($value);
		}

		$columnName = $this->_prefixColumnName($memberName);
		$dataTable[$tableName][$columnName] = $value;
	    } else {
		/*
		 * If we haven't set up a table for this class, do so now.
		 * Otherwise we don't have a complete list of tables that we
		 * need to insert into in order for this class to be completely
		 * serialized.
		 */
		
		if (!isset($dataTable[$tableName])) {
		    $dataTable[$tableName] = array();
		}
	    }

	    if ($type & STORAGE_TYPE_ID) {
		$getFunc = 'get' . $memberName;
		$value = $entity->$getFunc();

		$id['column'] = $this->_prefixColumnName($memberName);
		$id['value'] = $value;
	    }
	}

	if ($entity->testPersistentFlag(STORAGE_FLAG_NEWLY_CREATED)) {
	    /*
	     * Iterate through the data table and make up an INSERT statement
	     * for each table that requires one. 
	     */
	    foreach ($dataTable as $tableName => $columnChanges) {

		/* Make sure that the id column is set for each table */
		if (empty($columnChanges[$id['column']])) {
		    $columnChanges[$id['column']] = $id['value'];
		}

		$columns = array_keys($columnChanges);
		$data = array_values($columnChanges);
		$markers = GalleryUtilities::makeMarkers(sizeof($columnChanges));
		$query = 'INSERT INTO ' . $tableName . ' (';
		$query .= join(', ', $columns);
		$query .= ') VALUES (' . $markers . ')';

		$this->_traceStart();
		$recordSet = $this->_db->Execute($query, $data);
		$this->_traceStop();
		if (!$recordSet) {
		    return GalleryStatus::error(ERROR_STORAGE_FAILURE,
						__FILE__, __LINE__);
		}
	    }
	} else {

	    /*
	     * Iterate through the data table and make an UPDATE statement for
	     * each table that requires one.  Make sure that we do the table
	     * that has the serial number in it first, as we use the serial
	     * number to make sure that we're not hitting a concurrency issue.
	     */
	    $serialNumberClass = $memberInfo['members']['serialNumber']['class'];
	    $serialNumberTable = $this->_prefixTableName($serialNumberClass);

	    $queryList = array();
	    foreach ($dataTable as $tableName => $columnChanges) {
		$changeList = array();
		$data = array();
		
		foreach ($columnChanges as $columnName => $value) {
		    $changeList[] = $columnName . '=?';
		    $data[] = $value;
		}

		if (sizeof($changeList)) {
		    $query = 'UPDATE ' . $tableName  .  ' SET';
		    $query .= ' ' . join(',', $changeList);
		    $query .= ' WHERE ' . $id['column'] . '=?';
		    $data[] = $id['value'];

		    if (!strcmp($tableName, $serialNumberTable)) {
			$query .= ' AND ' .
				$this->_prefixColumnName('serialNumber') .
				'=?';
			$data[] = $originalSerialNumber;
			array_unshift($queryList, array($query, $data));
		    } else {
			array_push($queryList, array($query, $data));
		    }
		}
	    }

	    /*
	     * Now apply each UPDATE statement in turn.  Make sure that we're
	     * only affecting one row each time.
	     *
	     */
	    foreach ($queryList as $queryAndData) {
		list($query, $data) = $queryAndData;
		$this->_traceStart();
		$recordSet = $this->_db->Execute($query, $data);
		$this->_traceStop();

		if (!$recordSet) {
		    return GalleryStatus::error(ERROR_STORAGE_FAILURE,
						__FILE__, __LINE__);
		} else {
		    $affectedRows = $this->_db->Affected_Rows();
		    if ($affectedRows == 0) {
			return GalleryStatus::error(ERROR_OBSOLETE_DATA,
						    __FILE__, __LINE__);
		    } else if ($affectedRows > 1) {
			/*
			 * Holy shit, we just updated more than one row!  What do
			 * we do now?
			 */
			return GalleryStatus::error(ERROR_STORAGE_FAILURE,
						    __FILE__, __LINE__);
		    }
		}
	    }
	}
	
	$entity->clearPersistentFlag(STORAGE_FLAG_NEWLY_CREATED);
	$entity->clearModifiedFlags();

	return GalleryStatus::success();
    }

    /**
     * Delete the GalleryEntity.
     *
     * @access public
     * @param object GalleryEntity the GalleryEntity to delete
     * @return object GalleryStatus a status code
     */
    function deleteEntity(&$entity) {
	if ($this->_connectionStatus != DATABASE_STATUS_CONNECTED) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION,
					__FILE__, __LINE__);
	}

	/*
	 * If this object has not yet been saved in the database, don't bother
	 * saving it.
	 */
	if ($entity->testPersistentFlag(STORAGE_FLAG_NEWLY_CREATED)) {
	    $entity->clearPersistentFlag(STORAGE_FLAG_NEWLY_CREATED);
	    $entity->setPersistentFlag(STORAGE_FLAG_DELETED);
	    return;
	}

	/*
	 * Get our persistent and member info for this class
	 */
	list ($ret, $memberInfo) =
	    $this->_describeEntityMembers($entity->getEntityType());
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}
	
	$idCol = $this->_prefixColumnName('id');

	$tables = array();
	foreach ($memberInfo['members'] as $columnName => $columnInfo) {
	    $tables[$this->_prefixTableName($columnInfo['class'])] = 1;
	}

	/*
	 * XXX OPT:  Override this for specific database implementations that
	 * allow multi-table delete.
	 */
	foreach ($tables as $tableName => $junk) {
	    $query = 'DELETE FROM ' . $tableName .
		    ' WHERE ' . $idCol . '=?';
	    $data = array($entity->getId());
	    $this->_traceStart();
	    $recordSet = $this->_db->Execute($query, $data);
	    $this->_traceStop();
	    if (!$recordSet) {
		return GalleryStatus::error(ERROR_STORAGE_FAILURE,
					    __FILE__, __LINE__);
	    }
	}

	$entity->setPersistentFlag(STORAGE_FLAG_DELETED);
	    
	return GalleryStatus::success();
    }

    /**
     * Create a new GalleryEntity 
     *
     * @access public
     * @param object GalleryEntity the GalleryEntity to put the data in
     * @return object GalleryStatus a status code
     */
    function newEntity(&$entity) {
	if ($this->_connectionStatus != DATABASE_STATUS_CONNECTED) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION,
					__FILE__, __LINE__);
	}

	/*
	 * Get the id of the next object from our sequence.
	 */
	$this->_traceStart();
	$id = $this->_db->GenId(DATABASE_SEQUENCE_ID);
	$this->_traceStop();

	$entity->setId($id);
	$entity->setSerialNumber(0);
	$entity->setPersistentFlag(STORAGE_FLAG_NEWLY_CREATED);
	
	return GalleryStatus::success();
    }

    /**
     * Refresh a new GalleryEntity
     *
     * Refresh a GalleryEntity from the database, if it has changed.
     * Return the new object.
     *
     * @access public
     * @param object GalleryEntity the object to refresh
     * @return array object GalleryStatus a status code,
     *               GalleryEntity the refreshed entity
     */
    function refreshEntity($entity) {
	if ($this->_connectionStatus != DATABASE_STATUS_CONNECTED) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION,
					__FILE__, __LINE__);
	}

	/*
	 * Check the serial number to see if the current entity is up to
	 * date
	 */
	$tableName = $this->_prefixTableName('GalleryEntity');
	$serialNumberCol = $this->_prefixColumnName('serialNumber');
	$idCol = $this->_prefixColumnName('id');
	$query = 'SELECT ' . $serialNumberCol .
		' FROM ' . $tableName .
		' WHERE ' . $idCol . '=?';
	$data = array($entity->getId());
		
	$GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;
	$this->_traceStart();
	$recordSet = $this->_db->Execute($query, $data);
	$this->_traceStop();
	if (!$recordSet || $recordSet->RecordCount() == 0) {
	    return array(GalleryStatus::error(ERROR_MISSING_OBJECT,
					      __FILE__, __LINE__),
			 null);
	}

	if ($recordSet->FetchField(0) == $entity->getSerialNumber()) {
	    return array(GalleryStatus::success(), $entity);
	}

	/* Serial number didn't match -- reload the entity */
	list ($ret, $freshEntity) = $this->loadEntities($entity->getId());
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	$entity &= $freshEntity;

	return GalleryStatus::success();
    }

    /**
     * Acquire read locks on the given items
     *
     * @access public
     * @param int timeout before giving up on the lock
     * @return array object GalleryStatus a status code
     *               object a GalleryLock instance
     */
    function acquireReadLock($entityIds, $timeout) {

	/* It's ok to pass in a single id */
	if (!is_array($entityIds)) {
	    $entityIds = array($entityIds);
	}

	/* Know when to call it quits */
	$cutoffTime = time() + $timeout;

	/* Get the true name of the lock table */
	$lockTable = $this->_prefixTableName("Lock");

	/*
	 * Algorithm:
	 * 1. Get clearance to acquire locks (and get the lock id)
	 * 2. If any of the entities that we want to lock are currently write
	 *    locked, then clear the request and go back to step 1.
	 * 3. Acquire our read locks
	 */
	while (true) {
	    list($ret, $lockId) = $this->_getLockClearance($cutoffTime);
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }

	    /*
	     * Check to see if any of the ids that we care about are write
	     * locked.
	     */
	    $writeEntityIdCol = $this->_prefixColumnName('writeEntityId');
	    $markers = GalleryUtilities::makeMarkers(sizeof($entityIds));
	    $query = 'SELECT COUNT(*) FROM ' . $lockTable . ' ' .
		    'WHERE ' . $writeEntityIdCol . ' IN (' . $markers . ') ';
	    $data = $entityIds;

	    $GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;
	    $this->_traceStart();
	    $recordSet = $this->_db->Execute($query, $data);
	    $this->_traceStop();
	    if (!$recordSet) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE,
						  __FILE__, __LINE__),
			     null);
	    }

	    $row = $recordSet->FetchRow();
	    if ($row[0] == 0 ) {
		/* Success */
		break;
	    } else {
		/* An entity that we want is write locked */
		$this->_releaseLockById($lockId);

		if (time() > $cutoffTime) {
		    return array(GalleryStatus::error(ERROR_LOCK_TIMEOUT,
						      __FILE__, __LINE__),
				 null);
		}

		/* Wait a second and try again */
		sleep(1);
	    }
	}
	    
	/* Put in a read lock for every entity id */
	$lockIdCol = $this->_prefixColumnName('lockId');
	$readEntityIdCol = $this->_prefixColumnName('readEntityId');
	foreach ($entityIds as $entityId) {
	    $query = 'INSERT INTO ' . $lockTable .
		    '(' . $lockIdCol . ', ' . $readEntityIdCol . ') VALUES (?, ?)';
	    $data = array($lockId, $entityId);
	    $this->_traceStart();
	    $recordSet = $this->_db->Execute($query, $data);
	    $this->_traceStop();
	    if (!$recordSet) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE,
						  __FILE__, __LINE__),
			     null);
	    }
	}

	/* Drop the lock request, now that we've got the write locks */
	$requestCol = $this->_prefixColumnName('request');
	$query = 'DELETE FROM ' . $lockTable . ' ' .
		'WHERE ' . $lockIdCol . '=? AND ' . $requestCol . '=1';
	$data = array($lockId);
	$this->_traceStart();
	$recordSet = $this->_db->execute($query, $data);
	$this->_traceStop();
	if (!$recordSet) {
	    $this->_releaseLockById($lockId);
	    return array(GalleryStatus::error(ERROR_STORAGE_FAILURE,
					      __FILE__, __LINE__),
			 null);
	}

	/*
	 * Create a GalleryLock object and initialize it with the relevant
	 * data.
	 */
	$lock = new GalleryLock();
	$lock->acquireLock($lockId, LOCK_READ, $entityIds);

	/* Declare victory */
	return array(GalleryStatus::success(), $lock);
    }

    /**
     * Acquire write locks on the given items
     *
     * @access public
     * @param array or integer a set of ids
     * @param int timeout before giving up on the lock
     * @return array object GalleryStatus a status code
     *               object a GalleryLock instance
     */
    function acquireWriteLock($entityIds, $timeout) {

	/* It's ok to pass in a single id */
	if (!is_array($entityIds)) {
	    $entityIds = array($entityIds);
	}

	/* Know when to call it quits */
	$cutoffTime = time() + $timeout;

	/* Get the true name of the lock table */
	$lockTable = $this->_prefixTableName("Lock");

	/*
	 * Algorithm:
	 * 1. Get clearance to acquire locks (and get the lock id)
	 * 2. If any of the entities that we want to lock are currently locked,
	 *    then clear the request and go back to step 1.
	 * 3. Acquire our write locks
	 */
	while (true) {
	    list($ret, $lockId) = $this->_getLockClearance($cutoffTime);
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	
	    /*
	     * Check to see if any of the ids that we care about are locked.
	     */
	    $readEntityIdCol = $this->_prefixColumnName('readEntityId');
	    $writeEntityIdCol = $this->_prefixColumnName('writeEntityId');
	    $markers = GalleryUtilities::makeMarkers(sizeof($entityIds));
	    $query = 'SELECT COUNT(*) FROM ' . $lockTable . ' ' .
		    'WHERE ' . $readEntityIdCol . ' IN (' . $markers . ') ' .
		    'OR ' . $writeEntityIdCol . ' IN (' . $markers . ')';
	    $data = $entityIds;
	    $data = array_merge($data, $entityIds);

	    $GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;
	    $this->_traceStart();
	    $recordSet = $this->_db->Execute($query, $data);
	    $this->_traceStop();
	    if (!$recordSet) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE,
						  __FILE__, __LINE__),
			     null);
	    }

	    $row = $recordSet->FetchRow();
	    if ($row[0] == 0 ) {
		/* Success */
		break;
	    } else {
		/* An entity that we want is still locked */
		$this->_releaseLockById($lockId);

		if (time() > $cutoffTime) {
		    return array(GalleryStatus::error(ERROR_LOCK_TIMEOUT,
						      __FILE__, __LINE__),
				 null);
		}

		/* Wait a second and try again */
		sleep(1);
	    }
	}

	/*
	 * We are approved to acquire our write locks.
	 */
	$lockIdCol = $this->_prefixColumnName('lockId');
	$writeEntityIdCol = $this->_prefixColumnName('writeEntityId');
	foreach ($entityIds as $entityId) {
	    $query = 'INSERT INTO ' . $lockTable .
		    '(' . $lockIdCol . ', ' . $writeEntityIdCol .
		    ') VALUES (?, ?)';
	    $data = array($lockId, $entityId);
	    $this->_traceStart();
	    $recordSet = $this->_db->execute($query, $data);
	    $this->_traceStop();
	    if (!$recordSet) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE,
						  __FILE__, __LINE__),
			     null);
	    }
	}

	/* Drop the lock request, now that we've got the write locks */
	$requestCol = $this->_prefixColumnName('request');
	$query = 'DELETE FROM ' . $lockTable . ' ' .
		'WHERE ' . $lockIdCol . '=? AND ' . $requestCol . '=1';
	$data = array($lockId);
	$this->_traceStart();
	$recordSet = $this->_db->execute($query, $data);
	$this->_traceStop();
	if (!$recordSet) {
	    $this->_releaseLockById($lockId);
	    return array(GalleryStatus::error(ERROR_STORAGE_FAILURE,
					      __FILE__, __LINE__),
			 null);
	}

	/*
	 * Create a GalleryLock object and initialize it with the relevant
	 * data.
	 */
	$lock = new GalleryLock();
	$lock->acquireLock($lockId, LOCK_WRITE, $entityIds);

	/* Declare victory */
	return array(GalleryStatus::success(), $lock);
    }

    /**
     * Internal function to release a lock by id.  Outsiders should use
     * releaseLock()
     *
     * @access private
     * @param int the lock id
     * @return object GalleryStatus a status code
     */
    function releaseLock($lock) {
	return $this->_releaseLockById($lock->getAllIds());
    }

    /**
     * Internal function to release a lock by id.  Outsiders should use
     * releaseLock()
     *
     * @access private
     * @param mixed the lock id, or an array of lock ids
     * @return object GalleryStatus a status code
     */
    function _releaseLockById($lockIds) {
	if (!is_array($lockIds)) {
	    $lockIds = array($lockIds);
	}
	
	/* Get the true name of the lock table */
	$lockTable = $this->_prefixTableName("Lock");

	$lockIdCol = $this->_prefixColumnName('lockId');
	$markers = GalleryUtilities::makeMarkers(sizeof($lockIds));
	$query = 'DELETE FROM ' . $lockTable . ' ' .
		'WHERE ' . $lockIdCol . ' IN (' . $markers . ')';
	$data = $lockIds;
	$this->_traceStart();
	$recordSet = $this->_db->execute($query, $data);
	$this->_traceStop();
	if ($recordSet) {
	    return GalleryStatus::success();
	} else {
	    return array(GalleryStatus::error(ERROR_STORAGE_FAILURE,
					      __FILE__, __LINE__),
			 null);
	}
    }

    /**
     * Search the persistent store for the target values matching the given
     * criteria
     *
     * This is a flexible and powerful search mechanism.  You specify which
     * class members you wish to search for, how you want to search them, and
     * which class members you want returned in a very SQL like syntax
     *
     * @access public
     * @param array the search query
     * @param array any explicit data values required by the query
     * @return array object GalleryStatus a status code,
     *               array the result values
     */
    function search($query, $data=array()) {
	if ($this->_connectionStatus != DATABASE_STATUS_CONNECTED) {
	    return array(GalleryStatus::error(ERROR_STORAGE_CONNECTION,
					      __FILE__, __LINE__),
			 null);
	}

	/*
	 * Convert the generic query to a specific one.  Luckily, the
	 * generic query language is very close to standard SQL.  Isn't
	 * that convenient!
	 *
	 * Convert:
	 * array(
	 *   'select'   => '[Class1.member1] [Class2.member2]',
	 *   'where'    => '[Class3.member3] is NULL',
	 *   'order-by' => '[Class1.member1] ASC',
	 *   'limit'    => array('offset' => 0, 'count' => 10),
	 *   'group-by' => '[Class1.member1]'
	 *
	 * Into:
	 *
	 * SELECT   table1.column1, table2.column2, table3.column3
	 * FROM     table1, table2, table3
	 * WHERE    table3.member3 IS NULL
	 *          AND ((table1.id = table2.id) AND (table1.id = table3.id))
	 * ORDER BY table1.member1 ASC
	 * GROUP BY table1.member1
	 *
	 * Which would then be called like this:
	 *
	 * $db->SelectLimit($query, limit['count'], limit['offset']);
	 *
	 */
	$allTables = array();
	$entityTables = array();
	foreach (array('select', 'where', 'order-by', 'group-by') as $elementName) {
	    if (empty($query[$elementName])) {
		/* XXX: We should verify that 'select' exists here */
		continue;
	    }

	    $elementValue = $query[$elementName];
	    while (ereg("(\[[[:alnum:]]*::[[:alnum:]]*\])", $elementValue, $regs)) {
		$outer = $regs[1];
		ereg("([[:alnum:]]*)::([[:alnum:]]*)", $outer, $regs);
		list($class, $member) = array($regs[1], $regs[2]);
		
		$table = $this->_prefixTableName($class);
		$column = $this->_prefixColumnName($member);

		$allTables[$table] = 1;
		list ($ret, $classType) = $this->_getClassType($class);
		if ($ret->isError()) {
		    return array($ret->wrap(__FILE__, __LINE__),
				 null);
		}
		
		if (!strcmp($classType, 'entity')) {
		    $entityTables[$table] = 1;
		}

		$elementValue = str_replace($outer, "$table.$column", $elementValue);
	    }

	    /* Replace the element in the query */
	    $query[$elementName] = $elementValue;
	}

	/*
	 * Now that we know 'tables' is unique, convert it to a list for easier
	 * processing.
	 */
	$entityTables = array_keys($entityTables);
	$allTables = array_keys($allTables);

	if (sizeof($allTables)) {
	    $query['from'] = join(", ", $allTables);

	    if (sizeof($entityTables) > 1) {
		$query['where'] .= ' AND (';
		$idCol = $this->_prefixColumnName('id');
		for ($i = 1; $i < sizeof($entityTables); $i++) {
		    $query['where'] .= "($entityTables[0].$idCol = $entityTables[$i].$idCol)";
		    if ($i < (sizeof($entityTables)-1)) {
			$query['where'] .= ' AND ';
		    }
		}
		$query['where'] .= ')';
	    }
	}

	/* Assemble the query */
	$finalQuery = 'SELECT ' . $query['select'];
	$finalQuery .= ' FROM ' . $query['from'];
	if (!empty($query['where'])) {
	    $finalQuery .= ' WHERE ' . $query['where'];
	}

	if (!empty($query['order-by'])) {
	    $finalQuery .= ' ORDER BY ' . $query['order-by'];
	}

	if (!empty($query['group-by'])) {
	    $finalQuery .= ' GROUP BY ' . $query['group-by'];
	}

	/* Run it with the right limits and return the results */
	$GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_BOTH;

	if (isset($query['limit']) && sizeof($query['limit'])) {
	    if (empty($query['limit']['count'])) {
		$count = -1;
	    } else {
		$count = $query['limit']['count'];
	    }
	    
	    if (empty($query['limit']['offset'])) {
		$offset = -1;
	    } else {
		$offset = $query['limit']['offset'];
	    }
	    
	    $this->_traceStart();
	    $recordSet = $this->_db->SelectLimit($finalQuery, $count, $offset, $data);
	    $this->_traceStop();
	} else {
	    $this->_traceStart();
	    $recordSet = $this->_db->Execute($finalQuery, $data);
	    $this->_traceStop();
	}
	if ($recordSet) {
	    return array(GalleryStatus::success(),
			 new DatabaseSearchResults($recordSet));
	} else {
	    return array(GalleryStatus::error(ERROR_STORAGE_FAILURE,
					      __FILE__, __LINE__),
			 null);
	}
    }

    /**
     * Add a new entry to a map
     *
     * @param object the map we're working on
     * @param array an associative array of data about the entry
     * @return object GalleryStatus a status code
     */
    function addMapEntry($mapName, $entry) {

	$mapInfo = $this->_describeMapMembers($mapName);
	$tableName = $this->_prefixTableName($mapName);
	$data = array();
	$markers = array();
	$columns = array();
	foreach ($mapInfo['members'] as $memberName => $memberType) {
	    $markers[] = '?';
	    $columns[] = $this->_prefixColumnName($memberName);

	    $value = $entry[$memberName];
	    if ($memberType & STORAGE_TYPE_TIMESTAMP) {
		$value = $this->_db->DBTimeStamp($value);
	    }
	    $data[] = $value;
	}

	$markers = GalleryUtilities::makeMarkers(sizeof($columns));
	$query = 'INSERT INTO ' . $tableName . ' (';
	$query .= join(', ', $columns);
	$query .= ') VALUES (' . $markers . ')';

	$this->_traceStart();
	$recordSet = $this->_db->Execute($query, $data);
	$this->_traceStop();
	if (!$recordSet) {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE,
					__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * Remove an entry from a map
     *
     * This is dangerous, use very carefully!
     *
     * @param object the map we're working on
     * @param array an associative array of data about the entry
     */
    function removeMapEntry($mapName, $entry) {
	global $gallery;

	$mapInfo = $this->_describeMapMembers($mapName);
	$tableName = $this->_prefixTableName($mapName);
	$data = array();
	$where = array();
	foreach ($mapInfo['members'] as $memberName => $memberType) {
	    if (isset($entry[$memberName])) {
		$where[] = $this->_prefixColumnName($memberName) . '=?';
		$data[] = $entry[$memberName];
	    }
	}

	if (empty($where)) {
	    $gallery->debug("Missing where clause");
	    return GalleryStatus::error(ERROR_BAD_PARAMETER,
					__FILE__, __LINE__);
	}

	$query = 'DELETE FROM ' . $tableName . ' ';
	$query .= 'WHERE '  . join(' AND ', $where);

	$this->_traceStart();
	$recordSet = $this->_db->Execute($query, $data);
	$this->_traceStop();
	if (!$recordSet) {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE,
					__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * Update an entry in this map
     *
     * @param array the entry to match
     * @param array the values to change
     * @return object GalleryStatus a status code
     */
    function updateMapEntry($mapName, $match, $change) {

	$mapInfo = $this->_describeMapMembers($mapName);
	$tableName = $this->_prefixTableName($mapName);
	$data = array();
	foreach ($mapInfo['members'] as $memberName => $memberType) {
	    if (isset($match[$memberName])) {
		$where[] = $this->_prefixColumnName($memberName) . '=?';
		$wheredata[] = $match[$memberName];
	    }

	    if (isset($change[$memberName])) {
		$set[] = $this->_prefixColumnName($memberName) . '=?';
		$setdata[] = $change[$memberName];
	    }
	}

	if (sizeof($set) == 0 || sizeof($where) == 0) {
	    return GalleryStatus::error(ERROR_BAD_DATA,
					__FILE__, __LINE__);
	}

	$query = 'UPDATE ' . $tableName . ' ';
	$query .= 'SET ' . join(' AND ', $set) . ' ';
	$data = array_merge($data, $setdata);
	
	$query .= 'WHERE '  . join(' AND ', $where);
	$data = array_merge($data, $wheredata);

	$this->_traceStart();
	$recordSet = $this->_db->Execute($query, $data);
	$this->_traceStop();
	if (!$recordSet) {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE,
					__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * Test to see if our authentication information for this GalleryStorage is
     * valid.
     *
     * @return object GalleryStatus a status code
     */
    function testAuthentication() {
	global $gallery;

	/*
	 * Create a temporary connection that doesn't attach to the default
	 * database for this operation.
	 */
	$this->_traceStart();
	$db = ADONewConnection($this->getType());
	if (empty($db)) {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE,
					__FILE__, __LINE__);
	}

	/*
	 * Turn on debugging in the database connection if Gallery is in debug
	 * mode
	 */
	if ($gallery->getDebug()) {
	    $db->debug = true;
	}

	$ret = $db->Connect($this->_hostname,
			    $this->_username,
			    $this->_password);
	if (!$ret) {
	    return GalleryStatus::error(ERROR_STORAGE_BAD_AUTHENTICATON,
					__FILE__, __LINE__);
	}

	$db->Close();
	return GalleryStatus::success();
    }

    /**
     * Create the database.
     *
     * @return object GalleryStatus a status code
     */
    function createStore() {
	global $gallery;

	/*
	 * Create a temporary connection that doesn't attach to the default
	 * database for this operation.
	 */
	$this->_traceStart();
	$db = ADONewConnection($this->getType());
	if (empty($db)) {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE,
					__FILE__, __LINE__);
	}

	/*
	 * Turn on debugging in the database connection if Gallery is in debug
	 * mode
	 */
	if ($gallery->getDebug()) {
	    $db->debug = true;
	}

	$ret = $db->Connect($this->_hostname,
			    $this->_username,
			    $this->_password);
	if (!$ret) {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE,
					__FILE__, __LINE__);
	}
	
	$query = 'CREATE DATABASE ' . $this->_database;
	$recordSet = $db->Execute($query);
	$db->Close();
	
	if (empty($recordSet)) {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE,
					__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * Install or update the database schema for the given module
     *
     * Note that the database connection must not be attached to a specific
     * database for this to work.
     *
     * @return object GalleryStatus a status code
     */
    function configureStore($moduleName) {
	global $gallery;
	
	if ($this->_connectionStatus != DATABASE_STATUS_CONNECTED) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION,
					__FILE__, __LINE__);
	}
	
	/*
	 * Find the SQL files for this platform
	 */
	$sqlDir = dirname(__FILE__) . '/../../../../modules/' . $moduleName .
	    '/classes/GalleryStorage/DatabaseStorage/schema/platform/' .
	    $this->getType();
	$platform = $gallery->getPlatform();

	$sqlFiles = array();
	if ($dir = $platform->opendir($sqlDir)) {
	    while (($file = readdir($dir)) !== false) {
		/*
		 * There are two classes of files here, distinguished by name.
		 *   "Foo.sql" -- the definition for table "Foo"
		 *   "A_Foo_1.0.sql" -- an alteration to the 1.0 version of table "Foo"
		 *
		 * We need to parse these file names and group them together
		 * such that once we figure out what version of the Foo table
		 * we have in the database we can figure out which file to
		 * apply to install/update it.
		 */
		if (preg_match("/^A_(.*)_(\d+).(\d+).sql$/", $file, $matches)) {
		    $tableAlter[$matches[1]][$matches[2]][$matches[3]] = $sqlDir . '/' . $file;
		} else if (preg_match("/^(.*).sql$/", $file, $matches)) {
		    $tableDefinition[$matches[1]] = $sqlDir . '/' . $file;
		}
	    }
	    closedir($dir);
	} else {
	    return GalleryStatus::error(ERROR_BAD_PATH,
					__FILE__, __LINE__);
	}

	/* Get the metabase info about this database */
	$this->_traceStart();
	$metatables = $this->_db->MetaTables();
	$this->_traceStop();

	/*
	 * Some databases (notably MySQL on Win32) don't support mixed case
	 * table names.  So, when we get the meta table list back, it's lower
	 * case.  Force all metatable listings to lower case and then expect
	 * them to be lowercase so that we're consistent.
	 */
	for ($i = 0; $i < sizeof($metatables); $i++) {
	    $metatables[$i] = strtolower($metatables[$i]);
	}

	/* Do the schema table first */
	if (!in_array(strtolower($this->_prefixTableName('Schema')), $metatables)) {
	    $ret = $this->_executeSqlFile($tableDefinition['Schema']);
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	}

	/* Load all table versions */
	list ($ret, $tableVersions) = $this->_loadTableVersions();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	/*
	 * Now take care of the rest of the tables.  If the table doesn't
	 * exist, apply the current table definition.  If it already exists,
	 * check to see if there is an upgrade available for the given table
	 * version.  If so, apply it.
	 */
	foreach ($tableDefinition as $tableName => $sqlFile) {
	    if ($tableName == 'Schema') {
		continue;
	    }
	    
	    if (!in_array(strtolower($this->_prefixTableName($tableName)), $metatables)) {
		$ret = $this->_executeSqlFile($sqlFile);
		if ($ret->isError()) {
		    return $ret->wrap(__FILE__, __LINE__);
		}
	    } else {
		while (1) {
		    /* The table exists -- see if we have an upgrade for it */
		    if (empty($tableVersions[$tableName])) {
			/*
			 * We've found a SQL file that matches a table in the
			 * database, but has no matching version info in the
			 * schema table.  How can this be?  Leave it alone.
			 */
			$gallery->debug("Table $tableName: missing entry in Schema table");
			break;
		    }

		    /* If we locate an appropriate upgrade, apply it. */
		    list ($major,  $minor) = $tableVersions[$tableName];
		    if (!empty($tableAlter[$tableName][$major][$minor])) {
			$sqlFile = $tableAlter[$tableName][$major][$minor];
			$ret = $this->_executeSqlFile($sqlFile);
			if ($ret->isError()) {
			    return $ret->wrap(__FILE__, __LINE__);
			}

			/* Reload all table versions, cause one has now changed */
			list ($ret, $tableVersions) = $this->_loadTableVersions();
			if ($ret->isError()) {
			    return $ret->wrap(__FILE__, __LINE__);
			}
		    } else {
			/* No upgrade available */
			break;
		    }
		}
	    }
	}

	return GalleryStatus::success();
    }

    /**
     * Examine the schema table and return the version of all the Gallery tables
     *
     * @return array object GalleryStatus a status code
     *               array (name => (major, minor))
     */
    function _loadTableVersions() {
	global $gallery;
	
	$GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;
	$this->_traceStart();
	$recordSet = $this->_db->Execute('SELECT ' .
					 $this->_prefixColumnName('name') . ', ' .
					 $this->_prefixColumnName('major') . ', ' .
					 $this->_prefixColumnName('minor') .
					 ' FROM ' .
					 $this->_prefixTableName('Schema'));
	$this->_traceStop();
	
	if (empty($recordSet)) {
	    $gallery->debug("Error reading schema table");
	    return array(GalleryStatus::error(ERROR_STORAGE_FAILURE,
					      __FILE__, __LINE__), null);
	}

	while ($row = $recordSet->FetchRow()) {
	    $tableVersions[$row[0]] = array($row[1], $row[2]);
	}

	return array(GalleryStatus::success(), $tableVersions);
    }

    /**
     * Execute a given SQL file against the database.  Prefix table and column
     * names as necessary.  Split multiple commands in the file into separate
     * Execute() calls.
     *
     * @return object GalleryStatus a status code
     */
    function _executeSqlFile($fileName) {
	global $gallery;
	
	$platform = $gallery->getPlatform();
	
	if ($fd = $platform->fopen($fileName, "r")) {
	    $buffer = null;
	    while (!feof($fd)) {
		$buffer .= fgets($fd, 4096);
	    }
		
	    foreach (split(";", $buffer) as $query) {
		$query = trim($query);
		if (!empty($query)) {
		    $query = str_replace('TABLE_PREFIX', $this->_tablePrefix, $query);
		    $query = str_replace('COLUMN_PREFIX', $this->_columnPrefix, $query);
		    $this->_traceStart();
		    $recordSet = $this->_db->Execute($query);
		    $this->_traceStop();
		    if (empty($recordSet)) {
			$gallery->debug("Error trying to load $fileName");
			return GalleryStatus::error(ERROR_STORAGE_FAILURE,
						    __FILE__, __LINE__);
		    }
		}
	    }
	} else {
	    $gallery->debug("Unable to read file $fileName");
	    return GalleryStatus::error(ERROR_BAD_PATH,
					__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * Remove the database.
     *
     * Use this very carefully!
     *
     * Note that the database connection must not be attached to a specific
     * database for this to work.
     *
     * @return object GalleryStatus a status code
     */
    function removeStore() {
	global $gallery;
	
	/*
	 * Create a temporary connection that doesn't attach to the default
	 * database for this operation.
	 */
	$this->_traceStart();
	$db = ADONewConnection($this->getType());
	if (empty($db)) {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE,
					__FILE__, __LINE__);
	}

	/*
	 * Turn on debugging in the database connection if Gallery is in debug
	 * mode
	 */
	if ($gallery->getDebug()) {
	    $db->debug = true;
	}

	$ret = $db->Connect($this->_hostname,
			    $this->_username,
			    $this->_password);
	if (!$ret) {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE,
					__FILE__, __LINE__);
	}
	
	$query = 'DROP DATABASE ' . $this->_database;
	$recordSet = $db->Execute($query);
	$db->Close();
	
	if (empty($recordSet)) {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE,
					__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }
	
    /**
     * Identify the type of entity associated with the id provided
     *
     * @param int a object id
     * @return array a GalleryStatus and a string class name
     */
    function _identifyEntities($ids) {
	assert('!empty($ids)');

	if (!is_array($ids)) {
	    $ids = array($ids);
	    $returnArray = false;
	} else {
	    $returnArray = true;
	}

	$checkIds = array();
	foreach ($ids as $id) {
	    if (empty($this->_entityTypeCache[$id])) {
		$checkIds[] = $id;
	    }
	}

	if (!empty($checkIds)) {
	    $idCol = $this->_prefixColumnName('id');
	    $entityTypeCol = $this->_prefixColumnName('entityType');
	    $table = $this->_prefixTableName('GalleryEntity');
	    $markers = GalleryUtilities::makeMarkers(sizeof($checkIds));
	    $query = 'SELECT ' . $idCol . ', ' . $entityTypeCol .
		    ' FROM ' . $table .
		    ' WHERE ' . $idCol . ' IN (' . $markers . ')';

	    $GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;
	    $this->_traceStart();
	    $recordSet = $this->_db->Execute($query, $checkIds);
	    $this->_traceStop();
	    
	    if ($recordSet) {
		while ($row = $recordSet->FetchRow()) {
		    if (empty($row[1])) {
			return array(GalleryStatus::error(ERROR_MISSING_OBJECT,
							  __FILE__, __LINE__), null);
		    } else {
			$this->_entityTypeCache[$row[0]] = $row[1];
		    }
		}
	    } else {
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE,
						  __FILE__, __LINE__),
			     null);
	    }
	}

	if ($returnArray) {
	    $results = array();
	    foreach ($ids as $id) {
		if (empty($this->_entityTypeCache[$id])) {
		    return array(GalleryStatus::error(ERROR_MISSING_OBJECT,
						      __FILE__, __LINE__), null);
		}
		$results[] = $this->_entityTypeCache[$id];
	    }
	} else {
	    $results = $this->_entityTypeCache[$ids[0]];
	}

	return array(GalleryStatus::success(), $results);
    }

    /**
     * Translate a potentially unsafe column name into a safe one
     *
     * @param string the name of a column
     * @return string a safe column name
     * @access private
     */
    function _prefixColumnName($columnName) {
	return $this->_columnPrefix . $columnName;
    }

    /**
     * Translate a potentially unsafe table name into a safe one
     *
     * @param string the name of a table
     * @return string a safe table name
     * @access private
     */
    function _prefixTableName($tableName) {
	return $this->_tablePrefix . $tableName;
    }

    /**
     * Does the database software have the desired capability?
     *
     * @param string the name of the capability
     * @return bool true if yes
     * @access private
     */
    function _hasCapability($capabilityName) {
	return !empty($this->_capabilities[$capabilityName]);
    }

    /**
     * Internal function to get clearance to acquire locks
     *
     * Request clearance to acquire locks and then wait until it's our turn.
     *
     * @param int the time to stop trying to get clearance
     * @return object GalleryStatus a status code
     */
    function _getLockClearance($cutoffTime) {
	/* Get the true name of the lock table */
	$lockTable = $this->_prefixTableName("Lock");
	
	/* Get a new lock id */
	$this->_traceStart();
	$lockId = $this->_db->GenId(DATABASE_SEQUENCE_LOCK);
	$this->_traceStop();

	/* Put in a lock request */
	$lockIdCol = $this->_prefixColumnName('lockId');
	$requestCol = $this->_prefixColumnName('request');
	$query = 'INSERT INTO ' . $lockTable .
		'(' . $lockIdCol . ', ' . $requestCol .
		') VALUES (?, 1)';
	$data = array($lockId);
	$this->_traceStart();
	$recordSet = $this->_db->Execute($query, $data);
	$this->_traceStop();
	if (!$recordSet) {
	    $this->_releaseLockById($lockId);
	    return array(GalleryStatus::error(ERROR_STORAGE_FAILURE,
					      __FILE__, __LINE__),
			 null);
	}
    
	/* Wait till it's our turn */
	while (true) {
	    $query = 'SELECT ' . $lockIdCol . ' FROM ' . $lockTable . ' ' .
		    'WHERE ' . $requestCol . '=1 ORDER BY ' .
		    $lockIdCol . ' ASC';

	    $GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;
	    $this->_traceStart();
	    $recordSet = $this->_db->SelectLimit($query, 1);
	    $this->_traceStop();
	    if (!$recordSet) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE,
						  __FILE__, __LINE__),
			     null);
	    }

	    $row = $recordSet->FetchRow();
	    if ($row[0] == $lockId) {
		break;
	    }

	    /* Wait a second and try again */
	    sleep(1);

	    if (time() > $cutoffTime) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_LOCK_TIMEOUT,
						  __FILE__, __LINE__),
			     null);
	    }
	}

	return array(GalleryStatus::success(), $lockId);
    }
}
?>
