<?php
/*
 * $RCSfile$
 *
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2003 Bharat Mediratta
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
/**
 * @version $Revision$ $Date$
 * @package GalleryCore
 * @author Bharat Mediratta <bharat@menalto.com>
 */

/**
 * Require the ADOdb libraries
 */
require_once(dirname(__FILE__) . '/../../../../lib/adodb/adodb.inc.php');
require_once(dirname(__FILE__) . '/DatabaseStorage/ErrorHandler.inc');

/**
 * Name of the sequence we'll use for GalleryEntity ids
 */
define('DATABASE_SEQUENCE_ID', 'SequenceId');

/**
 * Name of the sequence we'll use for lock ids
 */
define('DATABASE_SEQUENCE_LOCK', 'SequenceLock');

/**
 * Default prefix to prepend to table names
 */
define('DATABASE_TABLE_PREFIX', 'g2_');

/**
 * Default prefix to prepend to column names
 */
define('DATABASE_COLUMN_PREFIX', 'g_');

/**
 * Database connection states
 */
define('DATABASE_STATUS_NOT_CONNECTED', 0);
define('DATABASE_STATUS_CONNECTED', 1);

/**
 * Database implementation of the GalleryStorage interface.
 *
 * This strategy implements the hooks for saving and restoring GalleryEntity
 * objects in a relational database.
 *
 * @package GalleryCore
 * @subpackage Storage
 */
class DatabaseStorage extends GalleryStorage {

    /**
     * Internal pointer to ADOdb database object
     *
     * @var object ADOdb $_db
     * @access private
     */
    var $_db;

    /**
     * Internal pointer to a non-transactional ADOdb database object
     *
     * @var object ADOdb $_nonTransactionalDb
     * @access private
     */
    var $_nonTransactionalDb;

    /**
     * Name of the database user
     * 
     * @var string $_username
     * @access private
     */
    var $_username;
    
    /**
     * Password for the database user
     * 
     * @var string $_password
     * @access private
     */
    var $_password;
    
    /**
     * Name of the database to use
     * 
     * @var string $_database
     * @access private
     */
    var $_database;

    /**
     * Host the database runs on
     * 
     * @var string $_hostname
     * @access private
     */
    var $_hostname;

    /**
     * A DatabaseSchema instance, used to check and update the schema
     * 
     * @var object DatabaseSchema an instance of the DatabaseSchema class
     * @access private
     */
    var $_databaseSchema;

    /**
     * Are we attempting to be transactional?
     *
     * @var string $_transactional
     * @access private
     */
    var $_isTransactional;

    /**
     * A string to prepend to table names
     *
     * @var string $_tablePrefix
     * @access private
     */
    var $_tablePrefix;

    /**
     * A string to prepend to column names
     *
     * @var string $_columnPrefix
     * @access private
     */
    var $_columnPrefix;

    /**
     * Constructor.
     *
     * @param array database configuration values
     */
    function DatabaseStorage($config) {
	$this->GalleryStorage();
	$this->_username = $config['username'];
	$this->_password = $config['password'];
	$this->_hostname = $config['hostname'];
	$this->_database = $config['database'];
	$this->_isTransactional = false;

	if (isset($config['tablePrefix'])) {
	    $this->_tablePrefix = $config['tablePrefix'];
	} else {
	    $this->_tablePrefix = DATABASE_TABLE_PREFIX;
	}

	if (isset($config['columnPrefix'])) {
	    $this->_columnPrefix = $config['columnPrefix'];
	} else {
	    $this->_columnPrefix = DATABASE_COLUMN_PREFIX;
	}
    }

    /**
     * Do any initialization that is required by this class
     *
     * @return object GallerySatus a status code
     */
    function init() {
	return $this->_connect();
    }
    
    /**
     * Connect to the database
     *
     * @return object GalleryStatus a status code
     * @access private
     */
    function _connect() {
	global $gallery;

	list ($ret, $this->_db) = $this->_getConnection();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * Connect to the database
     *
     * @return array object GalleryStatus a status code
     *               object a database resource
     * @access private
     */
    function _getConnection($forceNew=false) {
	global $gallery;
	
	if (empty($this->_username) || empty($this->_hostname)) {
	    return array(GalleryStatus::error(ERROR_MISSING_VALUE, __FILE__, __LINE__), null);
	}

	$this->_traceStart();
	$db = ADONewConnection($this->getAdoDbType());
	$this->_traceStop();
	if (empty($db)) {
	    return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	}

	/*
	 * Turn on debugging in the database connection if Gallery is in debug
	 * mode
	 */
	if ($gallery->getDebug()) {
	    $db->debug = true;
	}

	$this->_traceStart();
	if ($forceNew) {
	    $connectMethod = 'NConnect';
	} else {
	    $connectMethod = 'PConnect';
	}
	$ret = $db->$connectMethod($this->_hostname,
				   $this->_username,
				   $this->_password,
				   $this->_database);
	$this->_traceStop();

	if (!$ret) {
	    return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	}


	return array(GalleryStatus::success(), $db);
    }
    
    /**
     * Turn debugging on or off.
     */
    function setDebug($bool) {
	parent::setDebug($bool);

	/* Flip the switch in the ADOdb class, also */
	if ($this->_debug) {
	    $this->_db->debug = true;
	} else {
	    $this->_db->debug = false;
	}
    }

    /**
     * Return a non transactional database connection
     *
     * @return array object GalleryStatus a status code
     *               object ADOdb a database connection
     */
    function _getNonTransactionalDatabaseConnection() {
	/*
	 * If we're transactional, then we need another connection to
	 * manipulate our locks, since they have to operate outside of a
	 * transaction.
	 */
	if ($this->_isTransactional) {
	    if (empty($this->_nonTransactionalDb)) {
		list ($ret, $this->_nonTransactionalDb) = $this->_getConnection();
		if ($ret->isError()) {
		    return array($ret->wrap(__FILE__, __LINE__), null);
		}
	    }
	    return array(GalleryStatus::success(), $this->_nonTransactionalDb);
	} else {
	    return array(GalleryStatus::success(), $this->_db);
	}
    }
	
    /**
     * Load the GalleryEntities with the ids specified
     *
     * @param array the ids of the GalleryEntities to load
     * @return array object GalleryStatus a status code,
     *               mixed one GalleryEntity or an array of GalleryEntities
     */
    function loadEntities($ids) {
	global $gallery;

	if (empty($this->_db)) {
	    return array(GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__), null);
	}

	/* Identify all the ids at once */
	list ($ret, $types) = $this->_identifyEntities($ids);
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	/* Separate the ids by type */
	$classNames = array();
	$gallery->guaranteeTimeLimit(5);
	for ($i = 0; $i < sizeof($ids); $i++) {
	    if (empty($types[$i])) {
		return array(GalleryStatus::error(ERROR_MISSING_OBJECT, __FILE__, __LINE__,
						  "Missing object for id $ids[$i]"), null);
	    }
	    $classNames[$types[$i]][$ids[$i]] = 1;
	}

	/* Load them in groups */
	foreach ($classNames as $className => $targetIdHash) {
	    $gallery->guaranteeTimeLimit(5);

	    /* Get unique target ids */
	    $targetIds = array_keys($targetIdHash);
	    
	    /* Get our member info for this class */
	    list ($ret, $memberInfo) = $this->_describeEntityMembers($className);
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	    
	    $idCol = $this->_translateColumnName('id');

	    /* Build up our query */
	    $columns = array();
	    $tables = array();
	    $where = array();
	    $types = array();
	    $callbacks = array();
	    $markers = GalleryUtilities::makeMarkers(sizeof($targetIds));
	    foreach ($memberInfo['members'] as $columnName => $columnInfo) {
		list ($tableName, $unused) = $this->_translateTableName($columnInfo['class']);
		$types[] = $columnInfo['type'];
		$callbacks[] = 'set' . ucFirst($columnName);
		$columns[$tableName . '.' . $this->_translateColumnName($columnName)] = 1;
		$tables[$tableName] = 1;
	    }
	    $tables = array_keys($tables);
	    $columns = array_keys($columns);
	    
	    for ($i = 0; $i < sizeof($tables); $i++) {
		if ($i == 0) {
		    $where[] = $tables[$i] . '.' . $idCol . ' IN (' . $markers . ')';
		} else {
		    $where[] = $tables[$i] . '.' . $idCol . '=' . $tables[0] . '.' . $idCol;
		}
	    }

	    $query = 'SELECT ';
	    $query .= join(', ', $columns);
	    $query .= ' FROM ';
	    $query .= join(', ', $tables);
	    $query .= ' WHERE ';
	    $query .= join(' AND ', $where);

	    /* Execute the query */
	    $GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;
	    $this->_traceStart();
	    $recordSet = $this->_db->Execute($query, $targetIds);
	    $this->_traceStop();
	    if ($recordSet) {
		if ($recordSet->RecordCount() != sizeof($targetIds)) {
		    return array(GalleryStatus::error(ERROR_MISSING_OBJECT, __FILE__, __LINE__), null);
		}

		/* Process all the results */
		$j = 0;
		while ($row = $recordSet->FetchRow()) {
		    if (++$j % 20 == 0) {
			$gallery->guaranteeTimeLimit(5);
		    }
		    $entity = new $className;
		    if (empty($entity)) {
			return array(GalleryStatus::error(ERROR_BAD_DATA_TYPE, __FILE__, __LINE__), null);
		    }

		    for ($i = 0; $i < sizeof($callbacks); $i++) {
			$value = $row[$i];
		    
			/* Convert the database representation to a timestamp */
			if ($types[$i] & STORAGE_TYPE_TIMESTAMP) {
			    $value = $this->_db->UnixTimeStamp($value);
			}
			
			/* Store the value in the object */
			$entity->$callbacks[$i]($value);
		    }

		    $entity->clearModifiedFlags();
		    $entities[$entity->getId()] = $entity;
		}
		
		$recordSet->Close();
	    } else {
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	    }
	}

	/* Assemble the entities in the right order and return them */
	$result = array();
	foreach ($ids as $id) {
	    $result[] = $entities[$id];
	}

	/* Let each entity do its post-load procedure */
	foreach (array_keys($result) as $key) {
	    $ret = $result[$key]->onLoad();
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	}

	return array(GalleryStatus::success(), $result);
    }

    /**
     * Save the changes to the GalleryEntity.
     *
     * @access public
     * @param object GalleryEntity reference to the GalleryEntity to save
     * @return object GalleryStatus a status code
     */
    function saveEntity(&$entity) {
	if (empty($this->_db)) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__);
	}

	/*
	 * Update the serial number, but remember the original one
	 */
	$originalSerialNumber = $entity->getSerialNumber();
	$entity->setSerialNumber($originalSerialNumber + 1);

	/*
	 * Get our member info for this class
	 */
	list ($ret, $memberInfo) = $this->_describeEntityMembers(get_class($entity));
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}
	$idColumn = null;

	/*
	 * Build up a complete picture of all the various changed fields, so
	 * that we can do an insert or update.
	 */
	$dataTable = array();
	$id = array();
	foreach ($memberInfo['members'] as $memberName => $memberData) {
	    $type = $memberData['type'];
	    $class = $memberData['class'];
	    list ($tableName, $unused) = $this->_translateTableName($class);

	    /* If the member is modified, record the new value in our table */
	    if ($entity->getModifiedFlag($memberName) & MEMBER_MODIFIED) {
		$getFunc = 'get' . $memberName;
		$value = $entity->$getFunc();

		/* Convert empty values to null */
		if (!is_numeric($value) && empty($value)) {
		    $value = null;
		}

		/* Convert timestamps to the database representation */
		if ($type & STORAGE_TYPE_TIMESTAMP) {
		    $value = $this->_db->DBTimeStamp($value);
		}

		$columnName = $this->_translateColumnName($memberName);
		$dataTable[$tableName][$columnName] = $value;
	    } else {
		/*
		 * If we haven't set up a table for this class, do so now.
		 * Otherwise we don't have a complete list of tables that we
		 * need to insert into in order for this class to be completely
		 * serialized.
		 */
		
		if (!isset($dataTable[$tableName])) {
		    $dataTable[$tableName] = array();
		}
	    }

	    if ($type & STORAGE_TYPE_ID) {
		$getFunc = 'get' . $memberName;
		$value = $entity->$getFunc();

		$id['column'] = $this->_translateColumnName($memberName);
		$id['value'] = $value;
	    }
	}

	if ($entity->testPersistentFlag(STORAGE_FLAG_NEWLY_CREATED)) {
	    /*
	     * Iterate through the data table and make up an INSERT statement
	     * for each table that requires one. 
	     */
	    foreach ($dataTable as $tableName => $columnChanges) {

		/* Make sure that the id column is set for each table */
		if (empty($columnChanges[$id['column']])) {
		    $columnChanges[$id['column']] = $id['value'];
		}

		$columns = array_keys($columnChanges);
		$data = array_values($columnChanges);
		$markers = GalleryUtilities::makeMarkers(sizeof($columnChanges));
		$query = 'INSERT INTO ' . $tableName . ' (';
		$query .= join(', ', $columns);
		$query .= ') VALUES (' . $markers . ')';

		$this->_traceStart();
		$recordSet = $this->_db->Execute($query, $data);
		$this->_traceStop();

		if (!$recordSet) {
		    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
		}
	    }
	} else {

	    /*
	     * Iterate through the data table and make an UPDATE statement for
	     * each table that requires one.  Make sure that we do the table
	     * that has the serial number in it first, as we use the serial
	     * number to make sure that we're not hitting a concurrency issue.
	     */
	    $serialNumberClass = $memberInfo['members']['serialNumber']['class'];
	    list ($serialNumberTable, $unused) = $this->_translateTableName($serialNumberClass);

	    $queryList = array();
	    foreach ($dataTable as $tableName => $columnChanges) {
		$changeList = array();
		$data = array();
		
		foreach ($columnChanges as $columnName => $value) {
		    $changeList[] = $columnName . '=?';
		    $data[] = $value;
		}

		if (sizeof($changeList)) {
		    $query = 'UPDATE ' . $tableName  .  ' SET';
		    $query .= ' ' . join(',', $changeList);
		    $query .= ' WHERE ' . $id['column'] . '=?';
		    $data[] = $id['value'];

		    if (!strcmp($tableName, $serialNumberTable)) {
			$query .= ' AND ' .
				$this->_translateColumnName('serialNumber') .
				'=?';
			$data[] = $originalSerialNumber;
			array_unshift($queryList, array($query, $data));
		    } else {
			array_push($queryList, array($query, $data));
		    }
		}
	    }

	    /*
	     * Now apply each UPDATE statement in turn.  Make sure that we're
	     * only affecting one row each time.
	     *
	     */
	    foreach ($queryList as $queryAndData) {
		list($query, $data) = $queryAndData;

		$this->_traceStart();
		$recordSet = $this->_db->Execute($query, $data);
		$this->_traceStop();

		if (!$recordSet) {
		    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
		} else {
		    $affectedRows = $this->_db->Affected_Rows();
		    if ($affectedRows == 0) {
			return GalleryStatus::error(ERROR_OBSOLETE_DATA, __FILE__, __LINE__);
		    } else if ($affectedRows > 1) {
			/*
			 * Holy shit, we just updated more than one row!  What do
			 * we do now?
			 */
			return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
		    }
		}
	    }
	}

	$entity->clearPersistentFlag(STORAGE_FLAG_NEWLY_CREATED);
	$entity->clearModifiedFlags();
	$ret = $entity->onSave();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * Delete the GalleryEntity.
     *
     * @access public
     * @param object GalleryEntity the GalleryEntity to delete
     * @return object GalleryStatus a status code
     */
    function deleteEntity(&$entity) {
	if (empty($this->_db)) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__);
	}

	/*
	 * If this object has not yet been saved in the database, don't bother
	 * saving it.
	 */
	if ($entity->testPersistentFlag(STORAGE_FLAG_NEWLY_CREATED)) {
	    $entity->clearPersistentFlag(STORAGE_FLAG_NEWLY_CREATED);
	    $entity->setPersistentFlag(STORAGE_FLAG_DELETED);
	    return;
	}

	/*
	 * Get our persistent and member info for this class
	 */
	list ($ret, $memberInfo) =
	    $this->_describeEntityMembers($entity->getEntityType());
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}
	
	$idCol = $this->_translateColumnName('id');

	$tables = array();
	foreach ($memberInfo['members'] as $columnName => $columnInfo) {
	    list ($tableName, $unused) = $this->_translateTableName($columnInfo['class']);
	    $tables[$tableName] = 1;
	}

	/*
	 * XXX OPT:  Override this for specific database implementations that
	 * allow multi-table delete.
	 */
	foreach ($tables as $tableName => $junk) {
	    $query = 'DELETE FROM ' . $tableName .
		    ' WHERE ' . $idCol . '=?';
	    $data = array($entity->getId());
	    $this->_traceStart();
	    $recordSet = $this->_db->Execute($query, $data);
	    $this->_traceStop();
	    if (!$recordSet) {
		return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	    }
	}

	$entity->setPersistentFlag(STORAGE_FLAG_DELETED);
	    
	return GalleryStatus::success();
    }

    /**
     * Create a new GalleryEntity 
     *
     * @access public
     * @param object GalleryEntity the GalleryEntity to put the data in
     * @return object GalleryStatus a status code
     */
    function newEntity(&$entity) {
	if (empty($this->_db)) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__);
	}

	/*
	 * Get the id of the next object from our sequence.
	 */
	$this->_traceStart();
	$id = $this->_db->GenId($this->_tablePrefix . DATABASE_SEQUENCE_ID);
	$this->_traceStop();

	$entity->setId($id);
	$entity->setSerialNumber(0);
	$entity->setPersistentFlag(STORAGE_FLAG_NEWLY_CREATED);
	
	return GalleryStatus::success();
    }

    /**
     * @see GalleryStorage::refreshEntity
     */
    function refreshEntity($entity) {
	if (empty($this->_db)) {
	    return array(GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__), null);
	}

	/*
	 * We could check the serial number against the database, or check to see if the entity is modified in
	 * order to figure out whether or not we should refresh.  But either way that requires a database hit
	 * so we might as well just retrieve the record every time
	 */
	list ($ret, list($freshEntity)) = $this->loadEntities(array($entity->getId()));
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	return array(GalleryStatus::success(), $freshEntity);
    }

    /**
     * Acquire read locks on the given items
     *
     * @access public
     * @param int timeout before giving up on the lock
     * @return array object GalleryStatus a status code
     *               object a GalleryLock instance
     */
    function acquireReadLock($entityIds, $timeout) {
	/* It's ok to pass in a single id */
	if (!is_array($entityIds)) {
	    $entityIds = array($entityIds);
	}

	/* Acquire a non-transactional connection to use for this request */
	list ($ret, $db) = $this->_getNonTransactionalDatabaseConnection();
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	/* Know when to call it quits */
	$cutoffTime = time() + $timeout;

	/* Get the true name of the lock table */
	list ($lockTable, $unused) = $this->_translateTableName('Lock');

	/*
	 * Algorithm:
	 * 1. Get clearance to acquire locks (and get the lock id)
	 * 2. If any of the entities that we want to lock are currently write
	 *    locked, then clear the request and go back to step 1.
	 * 3. Acquire our read locks
	 */
	while (true) {
	    list($ret, $lockId) = $this->_getLockClearance($cutoffTime);
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }

	    /*
	     * Check to see if any of the ids that we care about are write
	     * locked.
	     */
	    $writeEntityIdCol = $this->_translateColumnName('writeEntityId');
	    $markers = GalleryUtilities::makeMarkers(sizeof($entityIds));
	    $query = 'SELECT COUNT(*) FROM ' . $lockTable . ' ' .
		    'WHERE ' . $writeEntityIdCol . ' IN (' . $markers . ') ';
	    $data = $entityIds;

	    $GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;
	    $this->_traceStart();
	    $recordSet = $db->Execute($query, $data);
	    $this->_traceStop();
	    if (!$recordSet) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	    }

	    $row = $recordSet->FetchRow();
	    if ($row[0] == 0 ) {
		/* Success */
		break;
	    } else {
		/* An entity that we want is write locked */
		$this->_releaseLockById($lockId);

		if (time() > $cutoffTime) {
		    return array(GalleryStatus::error(ERROR_LOCK_TIMEOUT, __FILE__, __LINE__), null);
		}

		/* Wait a second and try again */
		sleep(1);

		/* Expire any bogus locks */
		$ret = $this->_expireLocks();
		if ($ret->isError()) {
		    return array($ret->wrap(__FILE__, __LINE__), null);
		}
	    }
	}
	    
	/* Put in a read lock for every entity id */
	$lockIdCol = $this->_translateColumnName('lockId');
	$readEntityIdCol = $this->_translateColumnName('readEntityId');
	$freshUntilCol = $this->_translateColumnName('freshUntil');
	$freshUntil = time() + 30;
	foreach ($entityIds as $entityId) {
	    $query = sprintf('INSERT INTO %s (%s, %s, %s) VALUES (?, ?, ?)',
			     $lockTable, $lockIdCol, $readEntityIdCol, $freshUntilCol);
	    $data = array($lockId, $entityId, $freshUntil);
	    $this->_traceStart();
	    $recordSet = $db->Execute($query, $data);
	    $this->_traceStop();
	    if (!$recordSet) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	    }
	}

	/* Drop the lock request, now that we've got the write locks */
	$requestCol = $this->_translateColumnName('request');
	$query = 'DELETE FROM ' . $lockTable . ' ' .
		'WHERE ' . $lockIdCol . '=? AND ' . $requestCol . '=1';
	$data = array($lockId);
	$this->_traceStart();
	$recordSet = $db->execute($query, $data);
	$this->_traceStop();
	if (!$recordSet) {
	    $this->_releaseLockById($lockId);
	    return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	}

	/*
	 * Create a GalleryLock object and initialize it with the relevant
	 * data.
	 */
	require_once(dirname(__FILE__) . '/../GalleryLock.class');
	$lock = new GalleryLock();
	$lock->acquireLock($lockId, LOCK_READ, $entityIds);

	/* Declare victory */
	return array(GalleryStatus::success(), $lock);
    }

    /**
     * Acquire write locks on the given items
     *
     * @access public
     * @param array or integer a set of ids
     * @param int timeout before giving up on the lock
     * @return array object GalleryStatus a status code
     *               object a GalleryLock instance
     */
    function acquireWriteLock($entityIds, $timeout) {

	/* It's ok to pass in a single id */
	if (!is_array($entityIds)) {
	    $entityIds = array($entityIds);
	}

	/* Acquire a non-transactional connection to use for this request */
	list ($ret, $db) = $this->_getNonTransactionalDatabaseConnection();
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}
	
	/* Know when to call it quits */
	$cutoffTime = time() + $timeout;

	/* Get the true name of the lock table */
	list ($lockTable, $unused) = $this->_translateTableName('Lock');

	/*
	 * Algorithm:
	 * 1. Get clearance to acquire locks (and get the lock id)
	 * 2. If any of the entities that we want to lock are currently locked,
	 *    then clear the request and go back to step 1.
	 * 3. Acquire our write locks
	 */
	while (true) {
	    list($ret, $lockId) = $this->_getLockClearance($cutoffTime);
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	
	    /*
	     * Check to see if any of the ids that we care about are locked.
	     */
	    $readEntityIdCol = $this->_translateColumnName('readEntityId');
	    $writeEntityIdCol = $this->_translateColumnName('writeEntityId');
	    $markers = GalleryUtilities::makeMarkers(sizeof($entityIds));
	    $query = 'SELECT COUNT(*) FROM ' . $lockTable . ' ' .
		    'WHERE ' . $readEntityIdCol . ' IN (' . $markers . ') ' .
		    'OR ' . $writeEntityIdCol . ' IN (' . $markers . ')';
	    $data = $entityIds;
	    $data = array_merge($data, $entityIds);

	    $GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;
	    $this->_traceStart();
	    $recordSet = $db->Execute($query, $data);
	    $this->_traceStop();
	    if (!$recordSet) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	    }

	    $row = $recordSet->FetchRow();
	    if ($row[0] == 0 ) {
		/* Success */
		break;
	    } else {
		/* An entity that we want is still locked */
		$this->_releaseLockById($lockId);

		if (time() > $cutoffTime) {
		    return array(GalleryStatus::error(ERROR_LOCK_TIMEOUT, __FILE__, __LINE__), null);
		}

		/* Wait a second and try again */
		sleep(1);

		/* Expire any bogus locks */
		$ret = $this->_expireLocks();
		if ($ret->isError()) {
		    return array($ret->wrap(__FILE__, __LINE__), null);
		}
	    }
	}

	/*
	 * We are approved to acquire our write locks.
	 */
	$lockIdCol = $this->_translateColumnName('lockId');
	$writeEntityIdCol = $this->_translateColumnName('writeEntityId');
	$freshUntilCol = $this->_translateColumnName('freshUntil');
	$freshUntil = time() + 30;
	foreach ($entityIds as $entityId) {
	    $query = sprintf('INSERT INTO %s (%s, %s, %s) VALUES (?, ?, ?)',
			     $lockTable, $lockIdCol, $writeEntityIdCol, $freshUntilCol);
	    $data = array($lockId, $entityId, $freshUntil);
	    $this->_traceStart();
	    $recordSet = $db->execute($query, $data);
	    $this->_traceStop();
	    if (!$recordSet) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	    }
	}

	/* Drop the lock request, now that we've got the write locks */
	$requestCol = $this->_translateColumnName('request');
	$query = 'DELETE FROM ' . $lockTable . ' ' .
		'WHERE ' . $lockIdCol . '=? AND ' . $requestCol . '=1';
	$data = array($lockId);
	$this->_traceStart();
	$recordSet = $db->execute($query, $data);
	$this->_traceStop();
	if (!$recordSet) {
	    $this->_releaseLockById($lockId);
	    return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	}

	/*
	 * Create a GalleryLock object and initialize it with the relevant
	 * data.
	 */
	require_once(dirname(__FILE__) . '/../GalleryLock.class');
	$lock = new GalleryLock();
	$lock->acquireLock($lockId, LOCK_WRITE, $entityIds);

	/* Declare victory */
	return array(GalleryStatus::success(), $lock);
    }

    /**
     * Refresh all the locks that we hold so that they aren't accidentally considered expired
     *
     * @param array the lock ids
     * @param int the new "fresh until" timestamp
     * @return object GalleryStatus a status code
     * @static
     */
    function refreshLocks($lockIds, $freshUntil) {
	list ($lockTable, $unused) = $this->_translateTableName('Lock');
	$lockIdCol = $this->_translateColumnName('lockId');
	$freshUntilCol = $this->_translateColumnName('freshUntil');
	$lockIdMarkers = GalleryUtilities::makeMarkers(sizeof($lockIds));
	$query = sprintf('UPDATE %s SET %s = ? WHERE %s in (%s)',
			 $lockTable, $freshUntilCol, $lockIdCol, $lockIdMarkers);

	$this->_traceStart();
	$data = array_merge(array($freshUntil), $lockIds);
	$recordSet = $this->_db->Execute($query, $data);
	$this->_traceStop();
	
	if (!$recordSet) {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	}
	
	return GalleryStatus::success();
    }

    /**
     * Refresh all the locks that we hold so that they aren't accidentally considered expired
     *
     * @param array the lock ids
     * @param int the new "fresh until" timestamp
     * @return object GalleryStatus a status code
     * @static
     */
    function _expireLocks() {
	list ($lockTable, $unused) = $this->_translateTableName('Lock');
	$freshUntilCol = $this->_translateColumnName('freshUntil');
	$query = sprintf('DELETE FROM %s WHERE %s < ?',
			 $lockTable, $freshUntilCol);

	$this->_traceStart();
	$recordSet = $this->_db->Execute($query, array(time()));
	$this->_traceStop();
	
	if (!$recordSet) {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	}
	
	return GalleryStatus::success();
    }

    /**
     * Internal function to release a lock by id.  Outsiders should use
     * releaseLock()
     *
     * @access private
     * @param int the lock id
     * @return object GalleryStatus a status code
     */
    function releaseLock($lock) {
	$ret = $this->_releaseLockById($lock->getAllIds());
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * Internal function to release a lock by id.  Outsiders should use
     * releaseLock()
     *
     * @access private
     * @param mixed the lock id, or an array of lock ids
     * @return object GalleryStatus a status code
     */
    function _releaseLockById($lockIds) {
	if (!is_array($lockIds)) {
	    $lockIds = array($lockIds);
	}
	
	/* Acquire a non-transactional connection to use for this request */
	list ($ret, $db) = $this->_getNonTransactionalDatabaseConnection();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}
	
	/* Get the true name of the lock table */
	list ($lockTable, $unused) = $this->_translateTableName('Lock');

	$lockIdCol = $this->_translateColumnName('lockId');
	$markers = GalleryUtilities::makeMarkers(sizeof($lockIds));
	$query = 'DELETE FROM ' . $lockTable . ' ' .
		'WHERE ' . $lockIdCol . ' IN (' . $markers . ')';
	$data = $lockIds;
	$this->_traceStart();
	$recordSet = $db->execute($query, $data);
	$this->_traceStop();
	if ($recordSet) {
	    return GalleryStatus::success();
	} else {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	}
    }

    /**
     * Search the persistent store for the target values matching the given
     * criteria
     *
     * This is a flexible and powerful search mechanism.  You specify which
     * class members you wish to search for, how you want to search them, and
     * which class members you want returned in a very SQL like syntax
     *
     * @access public
     * @param array the search query
     * @param array any explicit data values required by the query
     * @return array object GalleryStatus a status code,
     *               array the result values
     */
    function search($query, $data=array(), $optional=array()) {
	if (empty($this->_db)) {
	    return array(GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__), null);
	}

	$query = $this->_translateQuery($query);

	/* Run it with the right limits and return the results */
	$GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_BOTH;

	if (isset($optional['limit']) && sizeof($optional['limit'])) {
	    if (empty($optional['limit']['count'])) {
		$count = -1;
	    } else {
		$count = $optional['limit']['count'];
	    }
	    
	    if (empty($optional['limit']['offset'])) {
		$offset = -1;
	    } else {
		$offset = $optional['limit']['offset'];
	    }
	    
	    $this->_traceStart();
	    $recordSet = $this->_db->SelectLimit($query, $count, $offset, $data);
	    $this->_traceStop();
	} else {
	    $this->_traceStart();
	    $recordSet = $this->_db->Execute($query, $data);
	    $this->_traceStop();
	}
	
	if ($recordSet) {
	    return array(GalleryStatus::success(),
			 new DatabaseSearchResults($recordSet));
	} else {
	    return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	}
    }

    /**
     * @see GalleryStorage.execute
     */
    function execute($statement, $data=array()) {
	if (empty($this->_db)) {
	    return array(GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__), null);
	}

	/* Change '[Class::member]' to 'table.column' or 'alias.column' */
	while (ereg('\[([[:alnum:]=]*)::([[:alnum:]]*)\]', $statement, $regs)) {
	    $class = $regs[1];
	    $member = $regs[2];
	    list ($table, $alias) = $this->_translateTableName($class);

	    $column = $this->_translateColumnName($member);
	    if ($alias == null) {
		$statement = str_replace("[${class}::${member}]", "$table.$column", $statement);
	    } else {
		$statement = str_replace("[${class}::${member}]", "$alias.$column", $statement);
	    }
	}

	/* Change '[Class]' to 'table' */
	while (ereg('\[([[:alnum:]=]*)\]', $statement, $regs)) {
	    $class = $regs[1];
	    list ($table, $alias) = $this->_translateTableName($class);
	    if ($alias == null) {
		$statement = str_replace("[${class}]", "$table", $statement);
	    } else {
		$statement = str_replace("[${class}]", "$table as $alias", $statement);
	    }
	}

	$this->_traceStart();
	$recordSet = $this->_db->Execute($statement, $data);
	$this->_traceStop();
	
	if ($recordSet) {
	    return GalleryStatus::success();
	} else {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	}
    }

    /**
     * Add a new entry to a map
     *
     * @param object the map we're working on
     * @param array an associative array of data about the entry
     * @return object GalleryStatus a status code
     */
    function addMapEntry($mapName, $entry) {

	$mapInfo = $this->_describeMapMembers($mapName);
	list ($tableName, $unused) = $this->_translateTableName($mapName);
	$data = array();
	$columns = array();
	foreach ($mapInfo['members'] as $memberName => $memberType) {
	    $columns[] = $this->_translateColumnName($memberName);
	    $value = $entry[$memberName];

	    if ($memberType & STORAGE_TYPE_BIT) {
		$value = $this->convertIntToBits($value);
	    } else {
		if ($memberType & STORAGE_TYPE_TIMESTAMP) {
		    $value = $this->_db->DBTimeStamp($value);
		}
	    }
	    
	    $data[] = $value;
	}

	$markers = GalleryUtilities::makeMarkers(sizeof($columns));
	$query = 'INSERT INTO ' . $tableName . ' (';
	$query .= join(', ', $columns);
	$query .= ') VALUES (' . $markers . ')';

	$this->_traceStart();
	$recordSet = $this->_db->Execute($query, $data);
	$this->_traceStop();
	if (!$recordSet) {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * Remove an entry from a map
     *
     * This is dangerous, use very carefully!
     *
     * @param object the map we're working on
     * @param array an associative array of data about the entry
     */
    function removeMapEntry($mapName, $entry) {
	global $gallery;

	$mapInfo = $this->_describeMapMembers($mapName);
	list ($tableName, $unused) = $this->_translateTableName($mapName);
	$data = array();
	$where = array();
	foreach ($mapInfo['members'] as $memberName => $memberType) {
	    if (isset($entry[$memberName])) {
		if (is_array($entry[$memberName])) {
		    $qs = array();
		    foreach ($entry[$memberName] as $value) {
			$qs[] = '?';
			$data[] = $value;
		    }
		    $where[] = $this->_translateColumnName($memberName) . ' IN (' . implode(',', $qs) . ')';
		} else {
		    $where[] = $this->_translateColumnName($memberName) . '=?';
		    $data[] = $entry[$memberName];
		}
	    }
	}

	if (empty($where)) {
	    return GalleryStatus::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__,
					'Missing where clause');
	}

	$query = 'DELETE FROM ' . $tableName . ' ';
	$query .= 'WHERE '  . join(' AND ', $where);

	$this->_traceStart();
	$recordSet = $this->_db->Execute($query, $data);
	$this->_traceStop();
	if (!$recordSet) {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * Update an entry in this map
     *
     * @param array the entry to match
     * @param array the values to change
     * @return object GalleryStatus a status code
     */
    function updateMapEntry($mapName, $match, $change) {

	$mapInfo = $this->_describeMapMembers($mapName);
	list ($tableName, $unused) = $this->_translateTableName($mapName);
	$data = array();
	$set = array();
	$where = array();

	foreach ($mapInfo['members'] as $memberName => $memberType) {
	    if (isset($match[$memberName])) {
		if (is_array($match[$memberName])) {
		    $queryFragment = ' ' . $this->_translateQuery($match[$memberName][0]);
		    $value = $match[$memberName][1];
		} else {
		    $queryFragment = '=?';
		    $value = $match[$memberName];
		}

		$where[] = $this->_translateColumnName($memberName) . $queryFragment;

		if ($memberType & STORAGE_TYPE_BIT) {
		    $value = $this->convertIntToBits($value);
		}

		$wheredata[] = $value;
	    }

	    if (isset($change[$memberName])) {
		if (is_array($change[$memberName])) {
		    $queryFragment = ' ' . $this->_translateQuery($change[$memberName][0]);
		    $value = $change[$memberName][1];
		} else {
		    $queryFragment = '=?';
		    $value = $change[$memberName];
		}
		
		$set[] = $this->_translateColumnName($memberName) . $queryFragment;

		if ($memberType & STORAGE_TYPE_BIT) {
		    $value = $this->convertIntToBits($value);
		}
		
		$setdata[] = $value;
	    }
	}

	if (sizeof($set) == 0 || sizeof($where) == 0) {
	    return GalleryStatus::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__);
	}

	$query = 'UPDATE ' . $tableName . ' ';
	$query .= 'SET ' . join(', ', $set) . ' ';
	$data = array_merge($data, $setdata);
	
	$query .= 'WHERE '  . join(' AND ', $where);
	$data = array_merge($data, $wheredata);

	$this->_traceStart();
	$recordSet = $this->_db->Execute($query, $data);
	$this->_traceStop();
	if (!$recordSet) {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * Install or update the database schema for the given module
     *
     * Note that the database connection must not be attached to a specific
     * database for this to work.
     *
     * @return object GalleryStatus a status code
     */
    function configureStore($moduleId) {
	global $gallery;
	
	if (empty($this->_db)) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__);
	}
	
	/*
	 * Find the SQL files for this platform
	 */
	$sqlDir = dirname(__FILE__) . '/../../../../modules/' . $moduleId .
	    '/classes/GalleryStorage/DatabaseStorage/schema/platform/' .
	    $this->getType();
	$platform = $gallery->getPlatform();

	$sqlFiles = array();
	if ($dir = $platform->opendir($sqlDir)) {
	    while (($file = $platform->readdir($dir)) !== false) {
		/*
		 * There are two classes of files here, distinguished by name.
		 *   "Foo.sql" -- the definition for table "Foo"
		 *   "A_Foo_1.0.sql" -- an alteration to the 1.0 version of table "Foo"
		 *
		 * We need to parse these file names and group them together
		 * such that once we figure out what version of the Foo table
		 * we have in the database we can figure out which file to
		 * apply to install/update it.
		 */
		if (preg_match('/^A_(.*)_(\d+).(\d+).sql$/', $file, $matches)) {
		    $tableAlter[$matches[1]][$matches[2]][$matches[3]] = $sqlDir . '/' . $file;
		} else if (preg_match('/^(.*).sql$/', $file, $matches)) {
		    $tableDefinition[$matches[1]] = $sqlDir . '/' . $file;
		}
	    }
	    $platform->closedir($dir);
	} else {
	    return GalleryStatus::error(ERROR_BAD_PATH, __FILE__, __LINE__);
	}

	/* Get the metabase info about this database */
	$this->_traceStart();
	$metatables = $this->_db->MetaTables();
	$this->_traceStop();

	/*
	 * Some databases (notably MySQL on Win32) don't support mixed case
	 * table names.  So, when we get the meta table list back, it's lower
	 * case.  Force all metatable listings to lower case and then expect
	 * them to be lowercase so that we're consistent.
	 */
	for ($i = 0; $i < sizeof($metatables); $i++) {
	    $metatables[$i] = strtolower($metatables[$i]);
	}

	/* Do the schema table first */
	list ($schemaTableName, $unused) = $this->_translateTableName('Schema');
	if (!in_array(strtolower($schemaTableName), $metatables)) {
	    $ret = $this->_executeSqlFile($tableDefinition['Schema']);
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }

	    /* Create our sequences now */
	    foreach (array(DATABASE_SEQUENCE_LOCK, DATABASE_SEQUENCE_ID)
		     as $sequenceId) {

		$this->_traceStart();
		$recordSet = $this->_db->CreateSequence($this->_tablePrefix . $sequenceId);
		$this->_traceStop();
		if (empty($recordSet)) {
		    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
		}
	    }
	}

	/* Load all table versions */
	list ($ret, $tableVersions) = $this->_loadTableVersions();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	/*
	 * Now take care of the rest of the tables.  If the table doesn't
	 * exist, apply the current table definition.  If it already exists,
	 * check to see if there is an upgrade available for the given table
	 * version.  If so, apply it.
	 */
	foreach ($tableDefinition as $rawTableName => $sqlFile) {
	    if ($rawTableName == 'Schema') {
		continue;
	    }

	    list ($tableName, $unused) = $this->_translateTableName($rawTableName);
	    if (!in_array(strtolower($tableName), $metatables)) {
		$ret = $this->_executeSqlFile($sqlFile);
		if ($ret->isError()) {
		    return $ret->wrap(__FILE__, __LINE__);
		}
	    } else {
		while (1) {
		    /* The table exists -- see if we have an upgrade for it */
		    if (empty($tableVersions[$rawTableName])) {
			/*
			 * We've found a SQL file that matches a table in the
			 * database, but has no matching version info in the
			 * schema table.  How can this be?  Leave it alone.
			 */
			if ($gallery->getDebug()) {
			    $gallery->debug("Table $rawTableName: missing entry in Schema table");
			}
			break;
		    }

		    /* If we locate an appropriate upgrade, apply it. */
		    list ($major,  $minor) = $tableVersions[$rawTableName];
		    if (!empty($tableAlter[$rawTableName][$major][$minor])) {
			$sqlFile = $tableAlter[$rawTableName][$major][$minor];
			$ret = $this->_executeSqlFile($sqlFile);
			if ($ret->isError()) {
			    return $ret->wrap(__FILE__, __LINE__);
			}

			/* Reload all table versions, cause one has now changed */
			list ($ret, $tableVersions) = $this->_loadTableVersions();
			if ($ret->isError()) {
			    return $ret->wrap(__FILE__, __LINE__);
			}
		    } else {
			/* No upgrade available */
			break;
		    }
		}
	    }
	}

	return GalleryStatus::success();
    }

    /**
     * Examine the schema table and return the version of all the Gallery tables
     *
     * @return array object GalleryStatus a status code
     *               array (name => (major, minor))
     */
    function _loadTableVersions() {
	global $gallery;
	
	$GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;
	$this->_traceStart();
	list ($schemaTableName, $unused) = $this->_translateTableName('Schema');
	$recordSet = $this->_db->Execute('SELECT ' .
					 $this->_translateColumnName('name') . ', ' .
					 $this->_translateColumnName('major') . ', ' .
					 $this->_translateColumnName('minor') .
					 ' FROM ' .
					 $schemaTableName);
	$this->_traceStop();
	
	if (empty($recordSet)) {
	    return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__,
					      'Error reading schema table'), null);
	}

	while ($row = $recordSet->FetchRow()) {
	    $tableVersions[$row[0]] = array($row[1], $row[2]);
	}

	return array(GalleryStatus::success(), $tableVersions);
    }

    /**
     * Execute a given SQL file against the database.  Prefix table and column
     * names as necessary.  Split multiple commands in the file into separate
     * Execute() calls.
     *
     * @return object GalleryStatus a status code
     */
    function _executeSqlFile($fileName) {
	global $gallery;
	
	$platform = $gallery->getPlatform();
	
	if ($fd = $platform->fopen($fileName, 'r')) {
	    $buffer = null;
	    while (!$platform->feof($fd)) {
		$buffer .= $platform->fgets($fd, 4096);
	    }
		
	    foreach (split(';', $buffer) as $query) {
		$query = trim($query);
		if (!empty($query)) {
		    $query = str_replace('DB_TABLE_PREFIX', $this->_tablePrefix, $query);
		    $query = str_replace('DB_COLUMN_PREFIX', $this->_columnPrefix, $query);

		    /* Perform database specific replacements */
		    foreach ($this->getSqlReplacements() as $key => $value) {
			$query = str_replace($key, $value, $query);
		    }
		    
		    $this->_traceStart();
		    $recordSet = $this->_db->Execute($query);
		    $this->_traceStop();
		    if (empty($recordSet)) {
			return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__,
						    "Error trying to load $fileName");
		    }
		}
	    }
	} else {
	    return GalleryStatus::error(ERROR_BAD_PATH, __FILE__, __LINE__,
					"Unable to read file $fileName");
	}

	return GalleryStatus::success();
    }

    /**
     * Clean out and reset the persistent store for this strategy.
     *
     * @return object GalleryStatus a status code
     */
    function cleanStore() {
	global $gallery;

	/* Get the metabase info about this database */
	$this->_traceStart();
	$metatables = $this->_db->MetaTables();
	$this->_traceStop();

	/*
	 * Some databases (notably MySQL on Win32) don't support mixed case
	 * table names.  So, when we get the meta table list back, it's lower
	 * case.  Force all metatable listings to lower case and then expect
	 * them to be lowercase so that we're consistent.
	 */
	for ($i = 0; $i < sizeof($metatables); $i++) {
	    $metatables[$i] = strtolower($metatables[$i]);
	}

	/* If the schema table exists then delete all the tables it lists */
	list ($schemaTableName, $unused) = $this->_translateTableName('Schema');
	if (in_array(strtolower($schemaTableName), $metatables)) {
	    /* Load all table versions */
	    list ($ret, $tableVersions) = $this->_loadTableVersions();
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }

	    foreach (array_keys($tableVersions) as $rawTableName) {
		list ($tableName, $unused) = $this->_translateTableName($rawTableName);
		$query = 'DROP TABLE ' . $tableName;
		$this->_traceStart();
		$recordSet = $this->_db->Execute($query);
		$this->_traceStop();
		if (empty($recordSet)) {
		    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
		}
	    }

	    /* Get rid of our sequences */
	    foreach (array(DATABASE_SEQUENCE_LOCK, DATABASE_SEQUENCE_ID)
		     as $sequenceId) {

		$this->_traceStart();
		$recordSet = $this->_db->DropSequence($this->_tablePrefix . $sequenceId);
		$this->_traceStop();
		if (empty($recordSet)) {
		    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
		}
	    }
	}

	return GalleryStatus::success();
    }
    
    /**
     * Begin a new transaction, if the storage layer supports them.
     *
     * @return object GalleryStatus a status code
     */
    function beginTransaction() {
	if (empty($this->_db)) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__);
	}

	if ($this->_isTransactional) {
	    $this->_traceStart();
	    $ok = $this->_db->BeginTrans();
	    $this->_traceStop();

	    if (!$ok) {
		return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	    }
	}
	
	return GalleryStatus::success();
    }

    /**
     * @see GalleryStorage::commitTransaction
     */
    function commitTransaction() {
	if (empty($this->_db)) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__);
	}

	if ($this->_isTransactional) {
	    $this->_traceStart();
	    $ok = $this->_db->CommitTrans();
	    $this->_traceStop();
	    
	    if (!$ok) {
		return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	    }
	}
	
	return GalleryStatus::success();
    }

    /**
     * @see GalleryStorage::rollbackTransaction
     */
    function rollbackTransaction() {
	if (empty($this->_db)) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__);
	}

	if ($this->_isTransactional) {
	    $this->_traceStart();
	    $ok = $this->_db->RollbackTrans();
	    $this->_traceStop();
	    
	    if (!$ok) {
		return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	    }
	}
	
	return GalleryStatus::success();
    }
    
    /**
     * Database specific string replacements in our SQL files.
     *
     * @return array(key => value, key => value) where we'll replace key with
     *         value in the SQL text.
     */
    function getSqlReplacements() {
	return array();
    }
	
    /**
     * Identify the type of entity associated with the id provided
     *
     * @param int a object id
     * @return array a GalleryStatus and a string class name
     */
    function _identifyEntities($ids) {
	assert('!empty($ids)');

	if (!is_array($ids)) {
	    $ids = array($ids);
	    $returnArray = false;
	} else {
	    $returnArray = true;
	}

	$checkIds = array();
	foreach ($ids as $id) {
	    if (!GalleryDataCache::containsKey("DatabaseStorage::_identifyEntities($id)")) {
		$checkIds[] = $id;
	    }
	}

	if (!empty($checkIds)) {
	    $idCol = $this->_translateColumnName('id');
	    $entityTypeCol = $this->_translateColumnName('entityType');
	    list ($table, $unused) = $this->_translateTableName('GalleryEntity');
	    $markers = GalleryUtilities::makeMarkers(sizeof($checkIds));
	    $query = 'SELECT ' . $idCol . ', ' . $entityTypeCol .
		    ' FROM ' . $table .
		    ' WHERE ' . $idCol . ' IN (' . $markers . ')';

	    $GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;
	    $this->_traceStart();
	    $recordSet = $this->_db->Execute($query, $checkIds);
	    $this->_traceStop();
	    
	    if ($recordSet) {
		while ($row = $recordSet->FetchRow()) {
		    if (empty($row[1])) {
			return array(GalleryStatus::error(ERROR_MISSING_OBJECT, __FILE__, __LINE__), null);
		    } else {
			GalleryDataCache::put("DatabaseStorage::_identifyEntities($row[0])", $row[1]);
		    }
		}
	    } else {
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	    }
	}

	if ($returnArray) {
	    $results = array();
	    foreach ($ids as $id) {
		if (!GalleryDataCache::containsKey("DatabaseStorage::_identifyEntities($id)")) {
		    return array(GalleryStatus::error(ERROR_MISSING_OBJECT, __FILE__, __LINE__,
						      "Missing object for $id"), null);
		}
		$results[] = GalleryDataCache::get("DatabaseStorage::_identifyEntities($id)");
	    }
	} else {
	    $results = GalleryDataCache::get("DatabaseStorage::_identifyEntities($ids[0])");
	}

	return array(GalleryStatus::success(), $results);
    }

    /**
     * Translate all table and column names from the [Entity::member] notation to
     * table.column notation.
     *
     * @param string the raw query
     * @param string the translated query
     */
    function _translateQuery($query) {
	/* Change '[Class::member]' to 'table.column' or 'alias.column' */
	while (ereg('\[([[:alnum:]=]*)::([[:alnum:]]*)\]', $query, $regs)) {
	    $class = $regs[1];
	    $member = $regs[2];
	    list ($table, $alias) = $this->_translateTableName($class);

	    $column = $this->_translateColumnName($member);
	    if ($alias == null) {
		$query = str_replace("[${class}::${member}]", "$table.$column", $query);
	    } else {
		$query = str_replace("[${class}::${member}]", "$alias.$column", $query);
	    }
	}

	/* Change '[Class]' to 'table' */
	while (ereg('\[([[:alnum:]=]*)\]', $query, $regs)) {
	    $class = $regs[1];
	    list ($table, $alias) = $this->_translateTableName($class);
	    if ($alias == null) {
		$query = str_replace("[${class}]", "$table", $query);
	    } else {
		$query = str_replace("[${class}]", "$table as $alias", $query);
	    }
	}

	return $query;
    }

    /**
     * Translate a potentially unsafe column name into a safe one
     *
     * @param string the name of a column
     * @return string a safe column name
     * @access private
     */
    function _translateColumnName($columnName) {
	return $this->_columnPrefix . $columnName;
    }

    /**
     * Translate a potentially unsafe table name into a safe one
     *
     * @param string the name of a table
     * @return string a safe table name
     * @access private
     */
    function _translateTableName($tableName) {

	/*
	 * Remove the the ubiquitous "Gallery" prefix, since it's not part of
	 * the schema name.  For now we automatically translate the class name
	 * into the schema name by doing this.  If this ever becomes a problem,
	 * we should start hand-writing the schema name instead and then
	 * pushing that into the interface classes so that we don't have to
	 * automatically generate the schema name (and get it wrong).
	 */
	$tableName = str_replace('Gallery', '', $tableName);

	/*
	 * Deal with aliases, which will be in the form of "table=1", "table=2",
	 * etc.  Translate "1" into "A", "2" into "B", etc.
	 */
	$split = split('=', $tableName);
	$alias = '';
	if (sizeof($split) > 1) {
	    list ($tableName, $number) = $split;
	    for ($i = 0; $i < strlen($tableName); $i++) {
		$chr = $tableName[$i];
		if ($chr >= 'A' && $chr <= 'Z') {
		    $alias .= $chr;
		}
	    }
	    $alias = strtolower($alias) . ($number - 1);
	} else {
	    $tableName = $split[0];
	    $alias = null;
	}

	return array($this->_tablePrefix . $tableName, $alias);
    }

    /**
     * Internal function to get clearance to acquire locks
     *
     * Request clearance to acquire locks and then wait until it's our turn.
     *
     * @param int the time to stop trying to get clearance
     * @return object GalleryStatus a status code
     */
    function _getLockClearance($cutoffTime) {
	/* Get the true name of the lock table */
	list ($lockTable, $unused) = $this->_translateTableName('Lock');
	
	/* Acquire a non-transactional connection to use for this request */
	list ($ret, $db) = $this->_getNonTransactionalDatabaseConnection();
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	/* Get a new lock id */
	$this->_traceStart();
	$lockId = $db->GenId($this->_tablePrefix . DATABASE_SEQUENCE_LOCK);
	$this->_traceStop();

	/* Put in a lock request */
	$lockIdCol = $this->_translateColumnName('lockId');
	$requestCol = $this->_translateColumnName('request');
	$query = 'INSERT INTO ' . $lockTable .
		'(' . $lockIdCol . ', ' . $requestCol .
		') VALUES (?, 1)';
	$data = array($lockId);
	$this->_traceStart();
	$recordSet = $db->Execute($query, $data);
	$this->_traceStop();
	if (!$recordSet) {
	    $this->_releaseLockById($lockId);
	    return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	}
    
	/* Wait till it's our turn */
	while (true) {
	    $query = 'SELECT ' . $lockIdCol . ' FROM ' . $lockTable . ' ' .
		    'WHERE ' . $requestCol . '=1 ORDER BY ' .
		    $lockIdCol . ' ASC';

	    $GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;
	    $this->_traceStart();
	    $recordSet = $db->SelectLimit($query, 1);
	    $this->_traceStop();
	    if (!$recordSet) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	    }

	    $row = $recordSet->FetchRow();
	    if ($row[0] == $lockId) {
		break;
	    }

	    /* Wait a second and try again */
	    sleep(1);

	    /* Expire any bogus locks */
	    $ret = $this->_expireLocks();
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	    
	    if (time() > $cutoffTime) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_LOCK_TIMEOUT, __FILE__, __LINE__), null);
	    }
	}

	return array(GalleryStatus::success(), $lockId);
    }
}
?>
