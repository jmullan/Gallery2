<?php
/*
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2002 Bharat Mediratta
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

/*
 * Require the ADOdb libraries
 */
require_once(dirname(__FILE__) . '/adodb/adodb.inc.php');
require_once(dirname(__FILE__) . '/ErrorHandler.inc');

/**
 * Name of the sequence we'll use for GalleryEntity ids
 */
define('DATABASE_SEQUENCE_ID', 'sequence_id');

/**
 * Name of the sequence we'll use for lock ids
 */
define('DATABASE_SEQUENCE_LOCK', 'sequence_lock');

/**
 * Prefix to prepend to table names
 */
define('DATABASE_TABLE_PREFIX', 'g2_');

/**
 * Prefix to prepend to column names
 */
define('DATABASE_COLUMN_PREFIX', 'g_');

/**
 * Database connection states
 */
define('DATABASE_STATUS_NOT_CONNECTED', 0);
define('DATABASE_STATUS_PARTIALLY_CONNECTED', 1);
define('DATABASE_STATUS_FULLY_CONNECTED', 2);

/**
 * Database implementation of the GalleryStorage interface.
 *
 * This strategy implements the hooks for saving and restoring GalleryEntity
 * objects in a relational database.
 *
 * @version $Id$
 * @package GalleryStorage
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class DatabaseStorage extends GalleryStorage {

    /**
     * Internal pointer to ADOdb database object
     *
     * @var object ADOdb $_db
     * @access private
     */
    var $_db;

    /**
     * Name of the database user
     * 
     * @var string $_username
     * @access private
     */
    var $_username;
    
    /**
     * Password for the database user
     * 
     * @var string $_password
     * @access private
     */
    var $_password;
    
    /**
     * Name of the database to use
     * 
     * @var string $_database
     * @access private
     */
    var $_database;

    /**
     * Host the database runs on
     * 
     * @var string $_hostname
     * @access private
     */
    var $_hostname;

    /**
     * A DatabaseSchema instance, used to check and update the schema
     * 
     * @var object DatabaseSchema an instance of the DatabaseSchema class
     * @access private
     */
    var $_databaseSchema;

    /**
     * Status of the database connection
     * 
     * @var int status
     * @access private
     */
    var $_connectionStatus;

    /**
     * The capabilities available in this version of the database software
     *
     * @var array $_capabilities
     * @access private
     */
    var $_capabilities;

    /**
     * A mapping of id to object type, useful when we are going to do multiple
     * lookups on the same object.
     *
     * @var array $_entityTypeCache
     * @access private
     */
    var $_entityTypeCache;

    /**
     * Constructor.
     *
     * @param array database configuration values
     */
    function DatabaseStorage($config) {
	$this->GalleryStorage();
	$this->_connectionStatus = DATABASE_STATUS_NOT_CONNECTED;

	$this->_username = $config['username'];
	$this->_password = $config['password'];
	$this->_hostname = $config['hostname'];
	$this->_database = $config['database'];
	$this->_useDefault = $config['useDefaultDatabase'];
	if (isset($config['capabilities'])) {
	    $this->_capabilities = $config['capabilities'];
	} else {
	    $this->_capabilities = array();
	}
    }

    /**
     * Do any initialization that is required by this class
     *
     * @return object GallerySatus a status code
     */
    function init() {
	return $this->_connect();
    }
    
    /**
     * Connect to the database
     *
     * @return object GalleryStatus a status code
     * @access private
     */
    function _connect() {
	global $gallery;
	
	if (empty($this->_username) || empty($this->_hostname)) {
	    return GalleryStatus::error(ERROR_MISSING_VALUE,
					__FILE__, __LINE__);
	}

	$this->_traceStart();
	$this->_db = ADONewConnection($this->getType());
	if (empty($this->_db)) {
	    return GalleryStatus::error(ERROR_DATABASE_FAILURE,
					__FILE__, __LINE__);
	}

	/*
	 * Turn on debugging in the database connection if Gallery is in debug
	 * mode
	 */
	if ($gallery->getDebug()) {
	    $this->_db->debug = true;
	}

	if ($this->_useDefault) {
	    $ret = $this->_db->PConnect($this->_hostname,
					$this->_username,
					$this->_password,
					$this->_database);
	    $this->_connectionStatus = DATABASE_STATUS_FULLY_CONNECTED;
	} else {
	    $ret = $this->_db->PConnect($this->_hostname,
					$this->_username,
					$this->_password);
	    $this->_connectionStatus = DATABASE_STATUS_PARTIALLY_CONNECTED;
	}
	$this->_traceStop();

	if (!$ret) {
	    $this->_connectionStatus = DATABASE_STATUS_NOT_CONNECTED;
	    $this->_db = null;
	    return GalleryStatus::error(ERROR_DATABASE_FAILURE,
					__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * Turn debugging on or off.
     */
    function setDebug($bool) {
	parent::setDebug($bool);

	/* Flip the switch in the ADOdb class, also */
	if ($this->_debug) {
	    $this->_db->debug = true;
	} else {
	    $this->_db->debug = false;
	}
    }

    /**
     * Load a new GalleryEntity from storage
     *
     * @access public
     * @param string the id of the stored GalleryEntity
     * @return array object GalleryStatus a status code, object GalleryEntity
     */
    function loadEntity($id) {
	if ($this->_connectionStatus != DATABASE_STATUS_FULLY_CONNECTED) {
	    return array(GalleryStatus::error(ERROR_DATABASE_CONNECTION,
					      __FILE__, __LINE__),
			 null);
	}

	$this->_traceStart();
	
	/*
	 * Figure out what kind of entity this is
	 */
	list($ret, $className) = $this->_identifyEntity($id);
	if ($ret->isError()) {
	    $this->_traceStop();
	    return array($ret, null);
	}

	/*
	 * Create a new instance of the class.
	 */
	$entity = new $className;
	if (empty($entity)) {
	    return array(GalleryStatus::error(ERROR_BAD_DATA,
					      __FILE__, __LINE__),
			 null);
	}


	/*
	 * Get our member info for this class
	 */
	$memberInfo = $this->_describeEntityMembers($className);
	$idCol = $this->_prefixColumnName('id');

	$columns = array();
	$tables = array();
	$where = array();
	$types = array();
	$data = array();
	foreach ($memberInfo['members'] as $columnName => $columnInfo) {
	    $tableName = $this->_prefixTableName($columnInfo['class']);
	    $types[] = $columnInfo['type'];
	    $callbacks[] = 'set' . ucFirst($columnName);
	    $columns[$tableName . '.' . $this->_prefixColumnName($columnName)] = 1;

	    if (empty($tables[$tableName])) {
		$tables[$tableName] = 1;
		$where[] = $tableName . '.' . $idCol . '=?';
		$data[] = $id;
	    }
	}

	$query = 'SELECT ';
	$query .= join(', ', array_keys($columns));
	$query .= ' FROM ';
	$query .= join(', ', array_keys($tables));
	$query .= ' WHERE ';
	$query .= join(' AND ', $where);

	$GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;
	$recordSet = $this->_db->Execute($query, $data);
	if ($recordSet) {
	    if ($recordSet->RecordCount() == 0) {
		return array(GalleryStatus::error(ERROR_MISSING_OBJECT,
						  __FILE__, __LINE__),
			     null);
	    }

	    $row = $recordSet->FetchRow();
	    for ($i = 0; $i < sizeof($callbacks); $i++) {
		$value = $row[$i];

		/* Convert the database representation to a timestamp */
		if ($types[$i] & STORAGE_TYPE_TIMESTAMP) {
		    $value = $this->_db->UnixTimeStamp($value);
		}

		/* Store the value in the object */
		$entity->$callbacks[$i]($value);
	    }
	    $recordSet->Close();

	    $entity->clearModifiedFlags();
	    $this->_traceStop();
	    return array(GalleryStatus::success(), $entity);
	} else {
	    $this->_traceStop();
	    return array(GalleryStatus::error(ERROR_DATABASE_FAILURE,
					      __FILE__, __LINE__),
			 null);
	}
    }

    /**
     * Save the changes to the GalleryEntity.
     *
     * @access public
     * @param object GalleryEntity reference to the GalleryEntity to save
     * @return object GalleryStatus a status code
     */
    function saveEntity(&$entity) {
	if ($this->_connectionStatus != DATABASE_STATUS_FULLY_CONNECTED) {
	    return GalleryStatus::error(ERROR_DATABASE_CONNECTION,
					__FILE__, __LINE__);
	}

	$this->_traceStart();
	
	/*
	 * Update the serial number, but remember the original one
	 */
	$originalSerialNumber = $entity->getSerialNumber();
	$entity->setSerialNumber($originalSerialNumber + 1);

	/*
	 * Get our member info for this class
	 */
	$memberInfo = $this->_describeEntityMembers(get_class($entity));
	$idColumn = null;

	/*
	 * Build up a complete picture of all the various changed fields, so
	 * that we can do an insert or update.
	 */
	$dataTable = array();
	$id = array();
	foreach ($memberInfo['members'] as $memberName => $memberData) {
	    $type = $memberData['type'];
	    $class = $memberData['class'];
	    $tableName = $this->_prefixTableName($class);

	    /* If the member is modified, record the new value in our table */
	    if ($entity->getModifiedFlag($memberName) & MEMBER_MODIFIED) {
		$getFunc = 'get' . $memberName;
		$value = $entity->$getFunc();

		/* Convert empty values to null */
		if (empty($value)) {
		    $value = null;
		}

		/* Convert timestamps to the database representation */
		if ($type & STORAGE_TYPE_TIMESTAMP) {
		    $value = $this->_db->DBTimeStamp($value);
		}

		$columnName = $this->_prefixColumnName($memberName);
		$dataTable[$tableName][$columnName] = $value;
	    } else {
		/*
		 * If we haven't set up a table for this class, do so now.
		 * Otherwise we don't have a complete list of tables that we
		 * need to insert into in order for this class to be completely
		 * serialized.
		 */
		
		if (!isset($dataTable[$tableName])) {
		    $dataTable[$tableName] = array();
		}
	    }

	    if ($type & STORAGE_TYPE_ID) {
		$getFunc = 'get' . $memberName;
		$value = $entity->$getFunc();

		$id['column'] = $this->_prefixColumnName($memberName);
		$id['value'] = $value;
	    }
	}

	if ($entity->testPersistentFlag(STORAGE_FLAG_NEWLY_CREATED)) {
	    /*
	     * Iterate through the data table and make up an INSERT statement
	     * for each table that requires one. 
	     */
	    foreach ($dataTable as $tableName => $columnChanges) {

		/* Make sure that the id column is set for each table */
		if (empty($columnChanges[$id['column']])) {
		    $columnChanges[$id['column']] = $id['value'];
		}

		$columns = array_keys($columnChanges);
		$data = array_values($columnChanges);
		$markers = $this->_makeMarkers(sizeof($columnChanges));
		$query = 'INSERT INTO ' . $tableName . ' (';
		$query .= join(', ', $columns);
		$query .= ') VALUES (' . $markers . ')';

		$recordSet = $this->_db->Execute($query, $data);
		if (!$recordSet) {
		    $this->_traceStop();
		    return GalleryStatus::error(ERROR_DATABASE_FAILURE,
						__FILE__, __LINE__);
		}
	    }
	} else {

	    /*
	     * Iterate through the data table and make an UPDATE statement for
	     * each table that requires one.  Make sure that we do the table
	     * that has the serial number in it first, as we use the serial
	     * number to make sure that we're not hitting a concurrency issue.
	     */
	    $serialNumberClass = $memberInfo['members']['serialNumber']['class'];
	    $serialNumberTable = $this->_prefixTableName($serialNumberClass);

	    $queryList = array();
	    foreach ($dataTable as $tableName => $columnChanges) {
		$changeList = array();
		$data = array();
		
		foreach ($columnChanges as $columnName => $value) {
		    $changeList[] = $columnName . '=?';
		    $data[] = $value;
		}

		if (sizeof($changeList)) {
		    $query = 'UPDATE ' . $tableName  .  ' SET';
		    $query .= ' ' . join(',', $changeList);
		    $query .= ' WHERE ' . $id['column'] . '=?';
		    $data[] = $id['value'];

		    if (!strcmp($tableName, $serialNumberTable)) {
			$query .= ' AND ' .
				$this->_prefixColumnName('serialNumber') .
				'=?';
			$data[] = $originalSerialNumber;
			array_unshift($queryList, array($query, $data));
		    } else {
			array_push($queryList, array($query, $data));
		    }
		}
	    }

	    /*
	     * Now apply each UPDATE statement in turn.  Make sure that we're
	     * only affecting one row each time.
	     *
	     */
	    foreach ($queryList as $queryAndData) {
		list($query, $data) = $queryAndData;
		$recordSet = $this->_db->Execute($query, $data);

		if (!$recordSet) {
		    $this->_traceStop();
		    return GalleryStatus::error(ERROR_DATABASE_FAILURE,
						__FILE__, __LINE__);
		} else {
		    $affectedRows = $this->_db->Affected_Rows();
		    if ($affectedRows == 0) {
			$this->_traceStop();
			return GalleryStatus::error(ERROR_OBSOLETE_DATA,
						    __FILE__, __LINE__);
		    } else if ($affectedRows > 1) {
			/*
			 * Holy shit, we just updated more than one row!  What do
			 * we do now?
			 */
			$this->_traceStop();
			return GalleryStatus::error(ERROR_DATABASE_FAILURE,
						    __FILE__, __LINE__);
		    }
		}
	    }
	}
	
	$entity->clearPersistentFlag(STORAGE_FLAG_NEWLY_CREATED);
	$entity->clearModifiedFlags();

	$this->_traceStop();
	
	return GalleryStatus::success();
    }

    /**
     * Delete the GalleryEntity.
     *
     * @access public
     * @param object GalleryEntity the GalleryEntity to delete
     * @return object GalleryStatus a status code
     */
    function deleteEntity(&$entity) {
	if ($this->_connectionStatus != DATABASE_STATUS_FULLY_CONNECTED) {
	    return GalleryStatus::error(ERROR_DATABASE_CONNECTION,
					__FILE__, __LINE__);
	}

	/*
	 * If this object has not yet been saved in the database, don't bother
	 * saving it.
	 */
	if ($entity->testPersistentFlag(STORAGE_FLAG_NEWLY_CREATED)) {
	    $entity->clearPersistentFlag(STORAGE_FLAG_NEWLY_CREATED);
	    $entity->setPersistentFlag(STORAGE_FLAG_DELETED);
	    return;
	}

	$this->_traceStart();
	
	/*
	 * Get our persistent and member info for this class
	 */
	$memberInfo = $this->_describeEntityMembers($entity->getEntityType());
	$idCol = $this->_prefixColumnName('id');

	$tables = array();
	foreach ($memberInfo['members'] as $columnName => $columnInfo) {
	    $tables[$this->_prefixTableName($columnInfo['class'])] = 1;
	}

	/*
	 * XXX OPT:  Override this for specific database implementations that
	 * allow multi-table delete.
	 */
	foreach ($tables as $tableName => $junk) {
	    $query = 'DELETE FROM ' . $tableName .
		    ' WHERE ' . $idCol . '=?';
	    $data = array($entity->getId());
	    $recordSet = $this->_db->Execute($query, $data);
	    if (!$recordSet) {
		$this->_traceStop();
		return GalleryStatus::error(ERROR_DATABASE_FAILURE,
					    __FILE__, __LINE__);
	    }
	}

	$entity->setPersistentFlag(STORAGE_FLAG_DELETED);
	    
	$this->_traceStop();
	return GalleryStatus::success();
    }

    /**
     * Create a new GalleryEntity 
     *
     * @access public
     * @param object GalleryEntity the GalleryEntity to put the data in
     * @return object GalleryStatus a status code
     */
    function newEntity(&$entity) {
	if ($this->_connectionStatus != DATABASE_STATUS_FULLY_CONNECTED) {
	    return GalleryStatus::error(ERROR_DATABASE_CONNECTION,
					__FILE__, __LINE__);
	}

	/*
	 * Get the id of the next object from our sequence.
	 */
	$this->_traceStart();
	$id = $this->_db->GenId(DATABASE_SEQUENCE_ID);
	$this->_traceStop();

	$entity->setId($id);
	$entity->setSerialNumber(0);
	$entity->setPersistentFlag(STORAGE_FLAG_NEWLY_CREATED);
	
	return GalleryStatus::success();
    }

    /**
     * Refresh a new GalleryEntity
     *
     * Refresh a GalleryEntity from the database, if it has changed.
     * Return the new object.
     *
     * @access public
     * @param object GalleryEntity the object to refresh
     * @return array object GalleryStatus a status code,
     *               GalleryEntity the refreshed entity
     */
    function refreshEntity($entity) {
	if ($this->_connectionStatus != DATABASE_STATUS_FULLY_CONNECTED) {
	    return GalleryStatus::error(ERROR_DATABASE_CONNECTION,
					__FILE__, __LINE__);
	}

	$this->_traceStart();
	
	/*
	 * Check the serial number to see if the current entity is up to
	 * date
	 */
	$tableName = $this->_prefixTableName('GalleryEntity');
	$serialNumberCol = $this->_prefixColumnName('serialNumber');
	$idCol = $this->_prefixColumnName('id');
	$query = 'SELECT ' . $serialNumberCol .
		' FROM ' . $tableName .
		' WHERE ' . $idCol . '=?';
	$data = array($entity->getId());
		
	$GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;
	$recordSet = $this->_db->Execute($query, $data);
	if (!$recordSet || $recordSet->RecordCount() == 0) {
	    $this->_traceStop();
	    return array(GalleryStatus::error(ERROR_MISSING_OBJECT,
					      __FILE__, __LINE__),
			 null);
	}

	if ($recordSet->FetchField(0) == $entity->getSerialNumber()) {
	    $this->_traceStop();
	    return array(GalleryStatus::success(), $entity);
	}

	/* Serial number didn't match -- reload the entity */
	return $this->loadEntity($entity->getId());
    }

    /**
     * Acquire read locks on the given items
     *
     * @access public
     * @param int timeout before giving up on the lock
     * @return array object GalleryStatus a status code
     *               object a GalleryLock instance
     */
    function acquireReadLock($entityIds, $timeout) {

	/* It's ok to pass in a single id */
	if (!is_array($entityIds)) {
	    $entityIds = array($entityIds);
	}

	/* Know when to call it quits */
	$cutoffTime = time() + $timeout;

	/* Get the true name of the lock table */
	$lockTable = $this->_prefixTableName("Lock");

	/*
	 * Algorithm:
	 * 1. Get clearance to acquire locks (and get the lock id)
	 * 2. If any of the entities that we want to lock are currently write
	 *    locked, then clear the request and go back to step 1.
	 * 3. Acquire our read locks
	 */
	while (true) {
	    list($ret, $lockId) = $this->_getLockClearance($cutoffTime);
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }

	    /*
	     * Check to see if any of the ids that we care about are write
	     * locked.
	     */
	    $writeEntityIdCol = $this->_prefixColumnName('writeEntityId');
	    $markers = $this->_makeMarkers(sizeof($entityIds));
	    $query = 'SELECT COUNT(*) FROM ' . $lockTable . ' ' .
		    'WHERE ' . $writeEntityIdCol . ' IN (' . $markers . ') ';
	    $data = $entityIds;

	    $GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;
	    $this->_traceStart();
	    $recordSet = $this->_db->Execute($query, $data);
	    $this->_traceStop();
	    if (!$recordSet) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_DATABASE_FAILURE,
						  __FILE__, __LINE__),
			     null);
	    }

	    $row = $recordSet->FetchRow();
	    if ($row[0] == 0 ) {
		/* Success */
		break;
	    } else {
		/* An entity that we want is write locked */
		$this->_releaseLockById($lockId);

		if (time() > $cutoffTime) {
		    return array(GalleryStatus::error(ERROR_LOCK_TIMEOUT,
						      __FILE__, __LINE__),
				 null);
		}

		/* Wait a second and try again */
		sleep(1);
	    }
	}
	    
	/* Put in a read lock for every entity id */
	$lockIdCol = $this->_prefixColumnName('lockId');
	$readEntityIdCol = $this->_prefixColumnName('readEntityId');
	foreach ($entityIds as $entityId) {
	    $query = 'INSERT INTO ' . $lockTable .
		    '(' . $lockIdCol . ', ' . $readEntityIdCol . ') VALUES (?, ?)';
	    $data = array($lockId, $entityId);
	    $this->_traceStart();
	    $recordSet = $this->_db->Execute($query, $data);
	    $this->_traceStop();
	    if (!$recordSet) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_DATABASE_FAILURE,
						  __FILE__, __LINE__),
			     null);
	    }
	}

	/* Drop the lock request, now that we've got the write locks */
	$requestCol = $this->_prefixColumnName('request');
	$query = 'DELETE FROM ' . $lockTable . ' ' .
		'WHERE ' . $lockIdCol . '=? AND ' . $requestCol . '=1';
	$data = array($lockId);
	$recordSet = $this->_db->execute($query, $data);
	if (!$recordSet) {
	    $this->_releaseLockById($lockId);
	    return array(GalleryStatus::error(ERROR_DATABASE_FAILURE,
					      __FILE__, __LINE__),
			 null);
	}

	/*
	 * Create a GalleryLock object and initialize it with the relevant
	 * data.
	 */
	$lock = new GalleryLock();
	$lock->acquireLock($lockId, LOCK_READ, $entityIds);

	/* Declare victory */
	return array(GalleryStatus::success(), $lock);
    }

    /**
     * Acquire write locks on the given items
     *
     * @access public
     * @param array or integer a set of ids
     * @param int timeout before giving up on the lock
     * @return array object GalleryStatus a status code
     *               object a GalleryLock instance
     */
    function acquireWriteLock($entityIds, $timeout) {

	/* It's ok to pass in a single id */
	if (!is_array($entityIds)) {
	    $entityIds = array($entityIds);
	}

	/* Know when to call it quits */
	$cutoffTime = time() + $timeout;

	/* Get the true name of the lock table */
	$lockTable = $this->_prefixTableName("Lock");

	/*
	 * Algorithm:
	 * 1. Get clearance to acquire locks (and get the lock id)
	 * 2. If any of the entities that we want to lock are currently locked,
	 *    then clear the request and go back to step 1.
	 * 3. Acquire our write locks
	 */
	while (true) {
	    list($ret, $lockId) = $this->_getLockClearance($cutoffTime);
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	
	    /*
	     * Check to see if any of the ids that we care about are locked.
	     */
	    $readEntityIdCol = $this->_prefixColumnName('readEntityId');
	    $writeEntityIdCol = $this->_prefixColumnName('writeEntityId');
	    $markers = $this->_makeMarkers(sizeof($entityIds));
	    $query = 'SELECT COUNT(*) FROM ' . $lockTable . ' ' .
		    'WHERE ' . $readEntityIdCol . ' IN (' . $markers . ') ' .
		    'OR ' . $writeEntityIdCol . ' IN (' . $markers . ')';
	    $data = $entityIds;
	    $data = array_merge($data, $entityIds);

	    $GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;
	    $this->_traceStart();
	    $recordSet = $this->_db->Execute($query, $data);
	    $this->_traceStop();
	    if (!$recordSet) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_DATABASE_FAILURE,
						  __FILE__, __LINE__),
			     null);
	    }

	    $row = $recordSet->FetchRow();
	    if ($row[0] == 0 ) {
		/* Success */
		break;
	    } else {
		/* An entity that we want is still locked */
		$this->_releaseLockById($lockId);

		if (time() > $cutoffTime) {
		    return array(GalleryStatus::error(ERROR_LOCK_TIMEOUT,
						      __FILE__, __LINE__),
				 null);
		}

		/* Wait a second and try again */
		sleep(1);
	    }
	}

	/*
	 * We are approved to acquire our write locks.
	 */
	$lockIdCol = $this->_prefixColumnName('lockId');
	$writeEntityIdCol = $this->_prefixColumnName('writeEntityId');
	foreach ($entityIds as $entityId) {
	    $query = 'INSERT INTO ' . $lockTable .
		    '(' . $lockIdCol . ', ' . $writeEntityIdCol .
		    ') VALUES (?, ?)';
	    $data = array($lockId, $entityId);
	    $recordSet = $this->_db->execute($query, $data);
	    if (!$recordSet) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_DATABASE_FAILURE,
						  __FILE__, __LINE__),
			     null);
	    }
	}

	/* Drop the lock request, now that we've got the write locks */
	$requestCol = $this->_prefixColumnName('request');
	$query = 'DELETE FROM ' . $lockTable . ' ' .
		'WHERE ' . $lockIdCol . '=? AND ' . $requestCol . '=1';
	$data = array($lockId);
	$recordSet = $this->_db->execute($query, $data);
	if (!$recordSet) {
	    $this->_releaseLockById($lockId);
	    return array(GalleryStatus::error(ERROR_DATABASE_FAILURE,
					      __FILE__, __LINE__),
			 null);
	}

	/*
	 * Create a GalleryLock object and initialize it with the relevant
	 * data.
	 */
	$lock = new GalleryLock();
	$lock->acquireLock($lockId, LOCK_WRITE, $entityIds);

	/* Declare victory */
	return array(GalleryStatus::success(), $lock);
    }

    /**
     * Internal function to release a lock by id.  Outsiders should use
     * releaseLock()
     *
     * @access private
     * @param int the lock id
     * @return object GalleryStatus a status code
     */
    function releaseLock($lock) {
	return $this->_releaseLockById($lock->getId());
    }

    /**
     * Internal function to release a lock by id.  Outsiders should use
     * releaseLock()
     *
     * @access private
     * @param int the lock id
     * @return object GalleryStatus a status code
     */
    function _releaseLockById($lockId) {
	/* Get the true name of the lock table */
	$lockTable = $this->_prefixTableName("Lock");

	$lockIdCol = $this->_prefixColumnName('lockId');
	$query = 'DELETE FROM ' . $lockTable . ' ' .
		'WHERE ' . $lockIdCol . ' = ?';
	$data = array($lockId);
	$this->_traceStart();
	$recordSet = $this->_db->execute($query, $data);
	$this->_traceStop();
	if ($recordSet) {
	    return GalleryStatus::success();
	} else {
	    return array(GalleryStatus::error(ERROR_DATABASE_FAILURE,
					      __FILE__, __LINE__),
			 null);
	}
    }

    /**
     * Search the persistent store for the target values matching the given
     * criteria
     *
     * This is a flexible and powerful search mechanism.  You specify which
     * class members you wish to search for, how you want to search them, and
     * which class members you want returned in a very SQL like syntax
     *
     * @access public
     * @param array the search query
     * @param array any explicit data values required by the query
     * @return array object GalleryStatus a status code,
     *               array the result values
     */
    function search($query, $data=array()) {
	if ($this->_connectionStatus != DATABASE_STATUS_FULLY_CONNECTED) {
	    return array(GalleryStatus::error(ERROR_DATABASE_CONNECTION,
					      __FILE__, __LINE__),
			 null);
	}

	/*
	 * Convert the generic query to a specific one.  Luckily, the
	 * generic query language is very close to standard SQL.  Isn't
	 * that convenient!
	 *
	 * Convert:
	 * array(
	 *   'select'   => '[Class1.member1] [Class2.member2]',
	 *   'where'    => '[Class3.member3] is NULL',
	 *   'order-by' => '[Class1.member1] ASC',
	 *   'limit'    => array('offset' => 0, 'count' => 10),
	 *
	 * Into:
	 *
	 * SELECT   table1.column1, table2.column2, table3.column3
	 * FROM     table1, table2, table3
	 * WHERE    table3.member3 IS NULL
	 *          AND ((table1.id = table2.id) AND (table1.id = table3.id))
	 * ORDER BY table1.member1 ASC
	 *
	 * Which would then be called like this:
	 *
	 * $db->SelectLimit($query, limit['count'], limit['offset']);
	 *
	 */
	$allTables = array();
	$entityTables = array();
	foreach (array('select', 'where', 'order-by') as $elementName) {
	    if (empty($query[$elementName])) {
		/* XXX: We should verify that 'select' exists here */
		continue;
	    }

	    $elementValue = $query[$elementName];
	    while (ereg("(\[[[:alnum:]]*::[[:alnum:]]*\])", $elementValue, $regs)) {
		$outer = $regs[1];
		ereg("([[:alnum:]]*)::([[:alnum:]]*)", $outer, $regs);
		list($class, $member) = array($regs[1], $regs[2]);
		
		$table = $this->_prefixTableName($class);
		$column = $this->_prefixColumnName($member);

		$allTables[$table] = 1;
		if (!strcmp($this->_getClassType($class), 'entity')) {
		    $entityTables[$table] = 1;
		}
		    
		$elementValue = str_replace($outer, "$table.$column", $elementValue);
	    }

	    /* Replace the element in the query */
	    $query[$elementName] = $elementValue;
	}

	/*
	 * Now that we know 'tables' is unique, convert it to a list for easier
	 * processing.
	 */
	$entityTables = array_keys($entityTables);
	$allTables = array_keys($allTables);

	if (sizeof($allTables)) {
	    $query['from'] = join(", ", $allTables);

	    if (sizeof($entityTables) > 1) {
		$query['where'] .= ' AND (';
		$idCol = $this->_prefixColumnName('id');
		for ($i = 1; $i < sizeof($entityTables); $i++) {
		    $query['where'] .= "($entityTables[0].$idCol = $entityTables[$i].$idCol)";
		    if ($i < (sizeof($entityTables)-1)) {
			$query['where'] .= ' AND ';
		    }
		}
		$query['where'] .= ')';
	    }
	}

	/* Assemble the query */
	$finalQuery = 'SELECT ' . $query['select'];
	$finalQuery .= ' FROM ' . $query['from'];
	if (isset($query['where'])) {
	    $finalQuery .= ' WHERE ' . $query['where'];
	}
	if (isset($query['order-by'])) {
	    $finalQuery .= ' ORDER BY ' . $query['order-by'];
	}

	/* Run it with the right limits and return the results */
	$GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_BOTH;
	$this->_traceStart();

	if (isset($query['limit']) && sizeof($query['limit'])) {
	    if (empty($query['limit']['count'])) {
		$count = -1;
	    } else {
		$count = $query['limit']['count'];
	    }
	    
	    if (empty($query['limit']['offset'])) {
		$offset = -1;
	    } else {
		$offset = $query['limit']['offset'];
	    }
	    
	    $recordSet = $this->_db->SelectLimit($finalQuery, $count, $offset, $data);
	} else {
	    $recordSet = $this->_db->Execute($finalQuery, $data);
	}
	$this->_traceStop();
	if ($recordSet) {
	    return array(GalleryStatus::success(),
			 new DatabaseSearchResults($recordSet));
	} else {
	    return array(GalleryStatus::error(ERROR_DATABASE_FAILURE,
					      __FILE__, __LINE__),
			 null);
	}
    }

    /**
     * Add a new entry to a map
     *
     * @param object the map we're working on
     * @param array an associative array of data about the entry
     * @return object GalleryStatus a status code
     */
    function addMapEntry($mapName, $entry) {

	$mapInfo = $this->_describeMapMembers($mapName);
	$tableName = $this->_prefixTableName($mapName);
	$data = array();
	$markers = array();
	$columns = array();
	foreach ($mapInfo['members'] as $memberName => $memberType) {
	    $markers[] = '?';
	    $columns[] = $this->_prefixColumnName($memberName);

	    $value = $entry[$memberName];
	    if ($memberType & STORAGE_TYPE_TIMESTAMP) {
		$value = $this->_db->DBTimeStamp($value);
	    }
	    $data[] = $value;
	}

	$markers = $this->_makeMarkers(sizeof($columns));
	$query = 'INSERT INTO ' . $tableName . ' (';
	$query .= join(', ', $columns);
	$query .= ') VALUES (' . $markers . ')';

	$this->_traceStart();
	$recordSet = $this->_db->Execute($query, $data);
	$this->_traceStop();
	if (!$recordSet) {
	    return GalleryStatus::error(ERROR_DATABASE_FAILURE,
					__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * Remove an entry from a map
     *
     * This is dangerous, use very carefully!
     *
     * @param object the map we're working on
     * @param array an associative array of data about the entry
     */
    function removeMapEntry($mapName, $entry) {

	$mapInfo = $this->_describeMapMembers($mapName);
	$tableName = $this->_prefixTableName($mapName);
	$data = array();
	$where = array();
	foreach ($mapInfo['members'] as $memberName => $memberType) {
	    if (isset($entry[$memberName])) {
		$where[] = $this->_prefixColumnName($memberName) . '=?';
		$data[] = $entry[$memberName];
	    }
	}

	if (sizeof($where) == 0) {
	    return GalleryStatus::error(ERROR_BAD_DATA,
					__FILE__, __LINE__);
	}

	$query = 'DELETE FROM ' . $tableName . ' ';
	$query .= 'WHERE '  . join(' AND ', $where);

	$this->_traceStart();
	$recordSet = $this->_db->Execute($query, $data);
	$this->_traceStop();
	if (!$recordSet) {
	    return GalleryStatus::error(ERROR_DATABASE_FAILURE,
					__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * Create the database.
     *
     * Note that the database connection must not be attached to a specific
     * database for this to work.
     *
     * @return object GalleryStatus a status code
     */
    function createStore() {
	global $gallery;
	
	if ($this->_connectionStatus != DATABASE_STATUS_PARTIALLY_CONNECTED) {
	    return GalleryStatus::error(ERROR_DATABASE_CONNECTION,
					__FILE__, __LINE__);
	}

	$query = 'CREATE DATABASE ' . $this->_database;
	$this->_traceStart();
	$recordSet = $this->_db->Execute($query);
	$this->_traceStop();
	
	if (empty($recordSet)) {
	    return GalleryStatus::error(ERROR_DATABASE_FAILURE,
					__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * Install or update the database schema.
     *
     * Note that the database connection must not be attached to a specific
     * database for this to work.
     *
     * @return object GalleryStatus a status code
     */
    function configureStore() {
	global $gallery;
	
	if ($this->_connectionStatus != DATABASE_STATUS_FULLY_CONNECTED) {
	    return GalleryStatus::error(ERROR_DATABASE_CONNECTION,
					__FILE__, __LINE__);
	}
	
	/*
	 * Find the SQL files for this platform
	 */
	$sqlDir = dirname(__FILE__) . '/schema/platform/' . $this->getType();
	list ($ret, $platform) = $gallery->getPlatform();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	$sqlFiles = array();
	if ($dir = $platform->opendir($sqlDir)) {
	    while (($file = readdir($dir)) !== false) {
		if (ereg(".sql$", $file)) {
		    if (!strcmp($file, "Schema.sql")) {
			array_unshift($sqlFiles, $file);
		    } else {
			array_push($sqlFiles, $file);
		    }
		}
	    }
	    closedir($dir);
	} else {
	    return GalleryStatus::error(ERROR_BAD_PATH,
					__FILE__, __LINE__);
	}

	/**
	 * Install the Schema table first, then do the rest.
	 */
	foreach ($sqlFiles as $fileName) {
	    $fileName = $sqlDir . '/' . $fileName;
	    print "> $fileName<br>";
	    
	    if ($fd = $platform->fopen($fileName, "r")) {
		$buffer = null;
		while (!feof($fd)) {
		    $buffer .= fgets($fd, 4096);
		}
		
		foreach (split(";", $buffer) as $query) {
		    $query = trim($query);
		    if (!empty($query)) {
			$recordSet = $this->_db->Execute($query);
			if (empty($recordSet)) {
			    $gallery->debug("Error trying to load $fileName");
			    return GalleryStatus::error(ERROR_DATABASE_FAILURE,
							__FILE__, __LINE__);
			}
		    }
		}
	    } else {
		$gallery->debug("Unable to read file $fileName");
		return GalleryStatus::error(ERROR_BAD_PATH,
					    __FILE__, __LINE__);
	    }
	}
	
	$this->_traceStart();
	$this->_traceStop();

	return $ret->wrap(__FILE__, __LINE__);
    }

    /**
     * Remove the database.
     *
     * Use this very carefully!
     *
     * Note that the database connection must not be attached to a specific
     * database for this to work.
     *
     * @return object GalleryStatus a status code
     */
    function removeStore() {
	if ($this->_connectionStatus != DATABASE_STATUS_PARTIALLY_CONNECTED) {
	    return GalleryStatus::error(ERROR_DATABASE_CONNECTION,
					__FILE__, __LINE__);
	}

	$query = 'DROP DATABASE ' . $this->_database;
	$this->_traceStart();
	$recordSet = $this->_db->Execute($query);
	$this->_traceStop();
	
	if (empty($recordSet)) {
	    return GalleryStatus::error(ERROR_DATABASE_FAILURE,
					__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }
	
    /**
     * Identify the type of entity associated with the id provided
     *
     * @param int a object id
     * @return array a GalleryStatus and a string class name
     */
    function _identifyEntity($id) {
	assert('!empty($id)');

	if (empty($this->_entityTypeCache[$id])) {
	    $idCol = $this->_prefixColumnName('id');
	    $entityTypeCol = $this->_prefixColumnName('entityType');
	    $table = $this->_prefixTableName('GalleryEntity');
	    $query = 'SELECT ' . $entityTypeCol .
		    ' FROM ' . $table .
		    ' WHERE ' . $idCol . '=?';
	    $data = array($id);

	    $GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;
	    $recordSet = $this->_db->Execute($query, $data);
	    
	    if ($recordSet) {
		if ($recordSet->RecordCount() == 1) {
		    $type = $recordSet->fields[0];
		    $recordSet->Close();
		}
		
		if (empty($type)) {
		    return array(GalleryStatus::error(ERROR_MISSING_OBJECT,
						      __FILE__, __LINE__), null);
		} else {
		    $this->_entityTypeCache[$id] = $type;
		}
	    } else {
		return array(GalleryStatus::error(ERROR_DATABASE_FAILURE,
						  __FILE__, __LINE__),
			     null);
	    }
	}

	return array(GalleryStatus::success(), $this->_entityTypeCache[$id]);
    }

    /**
     * Translate a potentially unsafe column name into a safe one
     *
     * @param string the name of a column
     * @return string a safe column name
     * @access private
     */
    function _prefixColumnName($columnName) {
	return DATABASE_COLUMN_PREFIX . $columnName;
    }

    /**
     * Translate a potentially unsafe table name into a safe one
     *
     * @param string the name of a table
     * @return string a safe table name
     * @access private
     */
    function _prefixTableName($tableName) {
	return DATABASE_TABLE_PREFIX . $tableName;
    }

    /**
     * Does the database software have the desired capability?
     *
     * @param string the name of the capability
     * @return bool true if yes
     * @access private
     */
    function _hasCapability($capabilityName) {
	return !empty($this->_capabilities[$capabilityName]);
    }

    /**
     * Return a string of ? markers
     *
     * @param int the number of markers to return
     * @access private
     */
    function _makeMarkers($count) {
	$markers = array();
	for ($i = 0; $i < $count; $i++) {
	    $markers[$i] = '?';
	}
	return join(', ', $markers);
    }

    /**
     * Internal function to get clearance to acquire locks
     *
     * Request clearance to acquire locks and then wait until it's our turn.
     *
     * @param int the time to stop trying to get clearance
     * @return object GalleryStatus a status code
     */
    function _getLockClearance($cutoffTime) {
	/* Get the true name of the lock table */
	$lockTable = $this->_prefixTableName("Lock");
	
	/* Get a new lock id */
	$this->_traceStart();
	$lockId = $this->_db->GenId(DATABASE_SEQUENCE_LOCK);
	$this->_traceStop();

	/* Put in a lock request */
	$lockIdCol = $this->_prefixColumnName('lockId');
	$requestCol = $this->_prefixColumnName('request');
	$query = 'INSERT INTO ' . $lockTable .
		'(' . $lockIdCol . ', ' . $requestCol .
		') VALUES (?, 1)';
	$data = array($lockId);
	$this->_traceStart();
	$recordSet = $this->_db->Execute($query, $data);
	$this->_traceStop();
	if (!$recordSet) {
	    $this->_releaseLockById($lockId);
	    return array(GalleryStatus::error(ERROR_DATABASE_FAILURE,
					      __FILE__, __LINE__),
			 null);
	}
    
	/* Wait till it's our turn */
	while (true) {
	    $query = 'SELECT ' . $lockIdCol . ' FROM ' . $lockTable . ' ' .
		    'WHERE ' . $requestCol . '=1 ORDER BY ' .
		    $lockIdCol . ' ASC';

	    $GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;
	    $recordSet = $this->_db->SelectLimit($query, 1);
	    if (!$recordSet) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_DATABASE_FAILURE,
						  __FILE__, __LINE__),
			     null);
	    }

	    $row = $recordSet->FetchRow();
	    if ($row[0] == $lockId) {
		break;
	    }

	    /* Wait a second and try again */
	    sleep(1);

	    if (time() > $cutoffTime) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_LOCK_TIMEOUT,
						  __FILE__, __LINE__),
			     null);
	    }
	}

	return array(GalleryStatus::success(), $lockId);
    }
}
?>
