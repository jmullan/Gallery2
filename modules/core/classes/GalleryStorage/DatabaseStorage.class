<?php
/*
 * $RCSfile$
 *
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2005 Bharat Mediratta
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA  02110-1301, USA.
 */
/**
 * @version $Revision$ $Date$
 * @package GalleryCore
 * @author Bharat Mediratta <bharat@menalto.com>
 */

/**
 * Require the ADOdb libraries
 */
GalleryCoreApi::relativeRequireOnce('lib/adodb/adodb.inc.php');
GalleryCoreApi::relativeRequireOnce(
    'modules/core/classes/GalleryStorage/DatabaseStorage/ErrorHandler.inc');

/**
 * Name of the sequence we'll use for GalleryEntity ids
 */
define('DATABASE_SEQUENCE_ID', 'SequenceId');

/**
 * Name of the sequence we'll use for lock ids
 */
define('DATABASE_SEQUENCE_LOCK', 'SequenceLock');

/**
 * Default prefix to prepend to table names
 */
define('DATABASE_TABLE_PREFIX', 'g2_');

/**
 * Default prefix to prepend to column names
 */
define('DATABASE_COLUMN_PREFIX', 'g_');

/**
 * Database implementation of the GalleryStorage interface.
 *
 * This strategy implements the hooks for saving and restoring GalleryEntity
 * objects in a relational database.
 *
 * @package GalleryCore
 * @subpackage Storage
 */
class DatabaseStorage /* implements GalleryStorage */ {

    /**
     * Internal pointer to ADOdb database object
     *
     * @var object ADOdb $_db
     * @access private
     */
    var $_db;

    /**
     * Internal pointer to our DatabaseStorageExtras object
     *
     * @var object DatabaseStorageExtras $_extras
     * @access private
     */
    var $_extras;

    /**
     * Internal pointer to a non-transactional ADOdb database object
     *
     * @var object ADOdb $_nonTransactionalDb
     * @access private
     */
    var $_nonTransactionalDb;

    /**
     * Name of the database user
     *
     * @var string $_username
     * @access private
     */
    var $_username;

    /**
     * Password for the database user
     *
     * @var string $_password
     * @access private
     */
    var $_password;

    /**
     * Name of the database to use
     *
     * @var string $_database
     * @access private
     */
    var $_database;

    /**
     * Host the database runs on
     *
     * @var string $_hostname
     * @access private
     */
    var $_hostname;

    /**
     * Are we attempting to be transactional?
     *
     * @var string $_transactional
     * @access private
     */
    var $_isTransactional;

    /**
     * A string to prepend to table names
     *
     * @var string $_tablePrefix
     * @access private
     */
    var $_tablePrefix;

    /**
     * A string to prepend to column names
     *
     * @var string $_columnPrefix
     * @access private
     */
    var $_columnPrefix;

    /**
     * A cache of member info that we've discovered about various classes
     *
     * @var array $_entityInfoCache
     * @access private
     */
    var $_entityInfoCache;

    /**
     * A cache of member info that we've discovered about various maps
     *
     * @var array $_mapInfoCache
     * @access private
     */
    var $_mapInfoCache;


    /**
     * Whether or not we should use persistent database connections
     *
     * @var array $_usePersistentConnections
     * @access private
     */
    var $_usePersistentConnections;

    /**
     * Constructor.
     *
     * @param array database configuration values
     */
    function DatabaseStorage($config) {
	$this->_username = $config['username'];
	$this->_password = $config['password'];
	$this->_hostname = $config['hostname'];
	$this->_database = $config['database'];
	$this->_isTransactional = false;

	/*
	 * We use persistent connections if the value is left out, or if it's
	 * non empty.
	 */
	$this->_usePersistentConnections = !isset($config['usePersistentConnections']) ||
	    !empty($config['usePersistentConnections']);

	if (isset($config['tablePrefix'])) {
	    $this->_tablePrefix = $config['tablePrefix'];
	} else {
	    $this->_tablePrefix = DATABASE_TABLE_PREFIX;
	}

	if (isset($config['columnPrefix'])) {
	    $this->_columnPrefix = $config['columnPrefix'];
	} else {
	    $this->_columnPrefix = DATABASE_COLUMN_PREFIX;
	}
    }

    /**
     * Do any initialization that is required by this class
     *
     * @return object GallerySatus a status code
     */
    function init() {
	global $gallery;

	list ($ret, $this->_db) = $this->_getConnection();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * Connect to the database
     *
     * @return array object GalleryStatus a status code
     *               object a database resource
     * @access private
     */
    function _getConnection($forceNew=false) {
	global $gallery;

	$this->_traceStart();
	$db =& ADONewConnection($this->getAdoDbType());
	$this->_traceStop();
	if (empty($db)) {
	    return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	}

	/* Turn on debugging in the database connection if Gallery is in debug mode */
	if ($gallery->getDebug()) {
	    $db->debug = true;
	}

	$this->_traceStart();
	if ($forceNew || !$this->_usePersistentConnections) {
	    $connectMethod = 'NConnect';
	} else {
	    $connectMethod = 'PConnect';
	}
	$ret = $db->$connectMethod($this->_hostname,
				   $this->_username,
				   $this->_password,
				   $this->_database);
	$this->_traceStop();

	if (!$ret) {
	    return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	}

	if ($gallery->isProfiling('sql')) {
	    $this->_traceStart();
	    $db->LogSQL();
	    $this->_traceStop();
	}

	return array(GalleryStatus::success(), $db);
    }

    /**
     * @see GalleryStorage::search
     */
    function search($query, $data=array(), $optional=array()) {
	if (empty($this->_db)) {
	    return array(GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__), null);
	}

	$query = $this->_translateQuery($query);

	/* Run it with the right limits and return the results */
	$GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;

	if (isset($optional['limit']) && sizeof($optional['limit'])) {
	    if (empty($optional['limit']['count'])) {
		$count = -1;
	    } else {
		$count = $optional['limit']['count'];
	    }

	    if (empty($optional['limit']['offset'])) {
		$offset = -1;
	    } else {
		$offset = $optional['limit']['offset'];
	    }

	    $this->_traceStart();
	    $recordSet = $this->_db->SelectLimit($query, $count, $offset, $data);
	    $this->_traceStop();
	} else {
	    $this->_traceStart();
	    $recordSet = $this->_db->Execute($query, $data);
	    $this->_traceStop();
	}

	if ($recordSet) {
	    return array(GalleryStatus::success(),
			 new DatabaseSearchResults($recordSet));
	} else {
	    return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	}
    }

    /**
     * @see GalleryStorage::getSqlReplacements
     */
    function getSqlReplacements() {
	return array();
    }

    /**
     * @see GalleryStorage::getOptimizeStatement
     */
    function getOptimizeStatement() {
	return null;
    }

    /**
     * Get the reference to our DatabaseStorageExtras instance where we put all
     * the storage code that's used to modify the database.
     *
     * @return object DatabaseStorageExtras
     */
    function &_getExtras() {
	if (!isset($this->_extras)) {
	    GalleryCoreApi::relativeRequireOnce(
		'modules/core/classes/GalleryStorage/DatabaseStorageExtras.class');
	    $this->_extras =& new DatabaseStorageExtras($this);
	}
	return $this->_extras;
    }

    /**
     * @see GalleryStorage::loadEntities
     */
    function loadEntities($ids) {
	$extras =& $this->_getExtras();
	return $extras->loadEntities($ids);
    }

    /**
     * @see GalleryStorage::saveEntity
     */
    function saveEntity(&$entity) {
	$extras =& $this->_getExtras();
	return $extras->saveEntity($entity);
    }

    /**
     * @see GalleryStorage::deleteEntity
     */
    function deleteEntity(&$entity) {
	$extras =& $this->_getExtras();
	return $extras->deleteEntity($entity);
    }

    /**
     * @see GalleryStorage::newEntity
     */
    function newEntity(&$entity) {
	$extras =& $this->_getExtras();
	return $extras->newEntity($entity);
    }

    /**
     * @see GalleryStorage::getUniqueId
     */
    function getUniqueId() {
	$extras =& $this->_getExtras();
	return $extras->getUniqueId();
    }

    /**
     * @see GalleryStorage::refreshEntity
     */
    function refreshEntity($entity) {
	$extras =& $this->_getExtras();
	return $extras->refreshEntity($entity);
    }

    /**
     * @see GalleryStorage::acquireReadLock
     */
    function acquireReadLock($entityIds, $timeout) {
	$extras =& $this->_getExtras();
	return $extras->acquireReadLock($entityIds, $timeout);
    }

    /**
     * @see GalleryStorage::acquireWriteLock
     */
    function acquireWriteLock($entityIds, $timeout) {
	$extras =& $this->_getExtras();
	return $extras->acquireWriteLock($entityIds, $timeout);
    }

    /**
     * @see GalleryStorage::refreshLocks
     */
    function refreshLocks($lockIds, $freshUntil) {
	$extras =& $this->_getExtras();
	return $extras->refreshLocks($lockIds, $freshUntil);
    }

    /**
     * @see GalleryStorage::releaseLocks
     */
    function releaseLocks($lockIds) {
	$extras =& $this->_getExtras();
	return $extras->releaseLocks($lockIds);
    }

    /**
     * @see GalleryStorage::execute
     */
    function execute($statement, $data=array()) {
	$extras =& $this->_getExtras();
	return $extras->execute($statement, $data);
    }

    /**
     * @see GalleryStorage::addMapEntry
     */
    function addMapEntry($mapName, $entry) {
	$extras =& $this->_getExtras();
	return $extras->addMapEntry($mapName, $entry);
    }

    /**
     * @see GalleryStorage::removeMapEntry
     */
    function removeMapEntry($mapName, $entry) {
	$extras =& $this->_getExtras();
	return $extras->removeMapEntry($mapName, $entry);
    }

    /**
     * @see GalleryStorage::removeAllMapEntries
     */
    function removeAllMapEntries($mapName) {
	$extras =& $this->_getExtras();
	return $extras->removeAllMapEntries($mapName);
    }

    /**
     * @see GalleryStorage::updateMapEntry
     */
    function updateMapEntry($mapName, $match, $change) {
	$ret = $this->_guaranteeTransaction();
	if ($ret->isError()) {
	    return $ret;
	}

	$mapInfo = $this->_describeMapMembers($mapName);
	list ($tableName, $unused) = $this->_translateTableName($mapName);
	$data = array();
	$set = array();
	$where = array();
	$wheredata = array();

	foreach ($mapInfo['members'] as $memberName => $memberType) {
	    if (array_key_exists($memberName, $match)) {
		if (GalleryUtilities::isA($match[$memberName], 'DatabaseSqlFragment')) {
		    $where[] = $this->_translateColumnName($memberName) . ' ' .
				$this->_translateQuery($match[$memberName]->getFragment());
		    foreach ($match[$memberName]->getValues() as $value) {
			$wheredata[] = $value;
		    }
		} else if (is_array($match[$memberName])) {
		    $qs = array();
		    foreach ($match[$memberName] as $value) {
			$qs[] = '?';
			if ($memberType & STORAGE_TYPE_BIT) {
			    $value = $this->convertIntToBits($value);
			}
			$wheredata[] = $value;
		    }
		    $where[] = $this->_translateColumnName($memberName) . ' IN ('
			     . implode(',', $qs) . ')';
		} else if (is_null($match[$memberName])) {
		    $where[] = $this->_translateColumnName($memberName) . ' IS NULL';
		} else {
		    $where[] = $this->_translateColumnName($memberName) . '=?';
		    $value = $match[$memberName];
		    if ($memberType & STORAGE_TYPE_BIT) {
			$value = $this->convertIntToBits($value);
		    }
		    $wheredata[] = $value;
		}
	    }

	    if (array_key_exists($memberName, $change)) {
		if (GalleryUtilities::isA($change[$memberName], 'DatabaseSqlFragment')) {
		    $set[] = $this->_translateColumnName($memberName) . ' ' .
				$this->_translateQuery($change[$memberName]->getFragment());
		    foreach ($change[$memberName]->getValues() as $value) {
			$setdata[] = $value;
		    }
		} else {
		    $set[] = $this->_translateColumnName($memberName) . '=?';
		    $value = $change[$memberName];
		    if ($memberType & STORAGE_TYPE_BIT) {
			$value = $this->convertIntToBits($value);
		    }
		    $setdata[] = $value;
		}
	    }
	}

	if (sizeof($set) == 0 || sizeof($where) == 0) {
	    return GalleryStatus::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__);
	}

	$query = 'UPDATE ' . $tableName . ' ';
	$query .= 'SET ' . join(', ', $set) . ' ';
	$data = array_merge($data, $setdata);

	$query .= 'WHERE '  . join(' AND ', $where);
	$data = array_merge($data, $wheredata);

	$this->_traceStart();
	$recordSet = $this->_db->Execute($query, $data);
	$this->_traceStop();
	if (!$recordSet) {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * @see GalleryStorage::configureStore
     */
    function configureStore($moduleId) {
	$extras =& $this->_getExtras();
	return $extras->configureStore($moduleId);
    }

    /**
     * @see GalleryStorage::configureStoreCleanup
     */
    function configureStoreCleanup($moduleId) {
	$extras =& $this->_getExtras();
	return $extras->configureStoreCleanup($moduleId);
    }

    /**
     * @see GalleryStorage::unconfigureStore
     */
    function unconfigureStore($moduleId) {
	$extras =& $this->_getExtras();
	return $extras->unconfigureStore($moduleId);
    }

    /**
     * @see GalleryStorage::cleanStore
     */
    function cleanStore() {
	$extras =& $this->_getExtras();
	return $extras->cleanStore();
    }

    /**
     * @see GalleryStorage::beginTransaction
     */
    function beginTransaction() {
	if (empty($this->_db)) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__);
	}

	if ($this->_isTransactional) {
	    $this->_traceStart();
	    $ok = $this->_db->BeginTrans();
	    $this->_traceStop();

	    if (!$ok) {
		return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	    }
	}

	return GalleryStatus::success();
    }

    /**
     * @see GalleryStorage::commitTransaction
     */
    function commitTransaction() {
	if (empty($this->_db)) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__);
	}

	if ($this->_isTransactional && $this->_db->transCnt > 0) {
	    $this->_traceStart();
	    $ok = $this->_db->CommitTrans();
	    $this->_traceStop();

	    if (!$ok) {
		return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	    }
	}

	return GalleryStatus::success();
    }

    /**
     * @see GalleryStorage::guaranteeTransaction
     */
    function _guaranteeTransaction() {
	if ($this->_isTransactional && !$this->_db->transCnt) {
	    $ret = $this->beginTransaction();
	    if ($ret->isError()) {
		return $ret;
	    }
	}

	return GalleryStatus::success();
    }

    /**
     * @see GalleryStorage::rollbackTransaction
     */
    function rollbackTransaction() {
	if (empty($this->_db)) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__);
	}

	if ($this->_isTransactional && $this->_db->transCnt > 0) {
	    $this->_traceStart();
	    $ok = $this->_db->RollbackTrans();
	    $this->_traceStop();

	    if (!$ok) {
		return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	    }
	}

	return GalleryStatus::success();
    }

    /**
     * @see GalleryStorage::getProfilingHtml
     */
    function getProfilingHtml() {
	$extras =& $this->_getExtras();
	return $extras->getProfilingHtml();
    }

    /**
     * @see GalleryStorage::isInstalled
     */
    function isInstalled() {
	$extras =& $this->_getExtras();
	return $extras->isInstalled();
    }

    /**
     * Optimize the back end.
     *
     * @return object GalleryStatus a status code
     */
    function optimize() {
	$extras =& $this->_getExtras();
	return $extras->optimize();
    }

    /**
     * Translate all table and column names from the [Entity::member] notation to
     * table.column notation.
     *
     * @param string the raw query
     * @param string the translated query
     */
    function _translateQuery($query) {
	/* Change '[Class::member]' to 'table.column' or 'alias.column' */
	while (ereg('\[([[:alnum:]_=]*)::([[:alnum:]_]*)\]', $query, $regs)) {
	    $class = $regs[1];
	    $member = $regs[2];
	    list ($table, $alias) = $this->_translateTableName($class);

	    $column = $this->_translateColumnName($member);
	    if ($alias) {
		$query = str_replace("[${class}::${member}]", "$alias.$column", $query);
	    } else if ($class) {
		$query = str_replace("[${class}::${member}]", "$table.$column", $query);
	    } else {
		$query = str_replace("[::${member}]", "$column", $query);
	    }
	}

	/* Change '[Class]' to 'table' */
	while (ereg('\[([[:alnum:]_=]*)\]', $query, $regs)) {
	    $class = $regs[1];
	    list ($table, $alias) = $this->_translateTableName($class);
	    if ($alias == null) {
		$query = str_replace("[${class}]", "$table", $query);
	    } else {
		list ($ret, $as) = $this->getFunctionSql('AS', array());
		if ($ret->isError()) {
		    /* TODO: propagate this back up as a GalleryStatus */
		    return 'QUERY ERROR';
		}
		$query = str_replace("[${class}]", "$table $as $alias", $query);
	    }
	}

	return $query;
    }

    /**
     * Translate a potentially unsafe column name into a safe one
     *
     * @param string the name of a column
     * @return string a safe column name
     * @access private
     */
    function _translateColumnName($columnName) {
	return $this->_columnPrefix . $columnName;
    }

    /**
     * Translate a potentially unsafe table name into a safe one by adding
     * a prefix or suffix to avoid conflicting with a reserved word.
     *
     * eg:
     * Comment   => array(g2_Comment, null, Comment)
     * Comment=1 => array(g2_Comment, C0, Comment)
     *
     * @param string the name of a table
     * @return array string a safe table name
     *               an alias for this table
     *               the unsafe, but translated, table name
     * @access private
     */
    function _translateTableName($tableName) {
	/*
	 * Remove the the ubiquitous "Gallery" prefix, since it's not part of
	 * the schema name.  For now we automatically translate the class name
	 * into the schema name by doing this.  If this ever becomes a problem,
	 * we should start hand-writing the schema name instead and then
	 * pushing that into the interface classes so that we don't have to
	 * automatically generate the schema name (and get it wrong).
	 */
	$tableName = str_replace('Gallery', '', $tableName);

	/*
	 * Other abbreviations to keep table names under Oracle's 30 character limit.
	 */
	$tableName = str_replace('Preferences', 'Prefs', $tableName);
	$tableName = str_replace('Toolkit', 'Tk', $tableName);
	$tableName = str_replace('TkOperation', 'TkOperatn', $tableName);

	/*
	 * Deal with aliases, which will be in the form of "table=1", "table=2",
	 * etc.  Translate "1" into "A", "2" into "B", etc.
	 */
	$split = explode('=', $tableName);
	$alias = '';
	if (sizeof($split) > 1) {
	    list ($tableName, $number) = $split;
	    for ($i = 0; $i < strlen($tableName); $i++) {
		$chr = $tableName[$i];
		if ($chr >= 'A' && $chr <= 'Z') {
		    $alias .= $chr;
		}
	    }
	    $alias = strtolower($alias) . ($number - 1);
	} else {
	    $tableName = $split[0];
	    $alias = null;
	}

	return array($this->_tablePrefix . $tableName, $alias, $tableName);
    }

    /**
     * Describe all the members of a entity
     *
     * @param string a class name
     * @access protected
     * @return array object GalleryStatus a status code
     *               member => info associative array
     */
    function _describeEntityMembers($entityName) {
	global $gallery;

	if (empty($this->_entityInfoCache[$entityName])) {
	    if (class_exists($entityName)) {
		$entity = new $entityName();
	    } else {
		list ($ret, $entity) =
		    GalleryCoreApi::newFactoryInstance('GalleryEntity', $entityName);
		if ($ret->isError()) {
		    return array($ret->wrap(__FILE__, __LINE__), null);
		}
	    }
	    if (!isset($entity)) {
		return array(GalleryStatus::error(ERROR_MISSING_OBJECT, __FILE__, __LINE__,
						  $entityName), null);
	    }
	    $this->_entityInfoCache[$entityName] = $entity->getPersistentMemberInfo();
	}

	return array(GalleryStatus::success(),
		     $this->_entityInfoCache[$entityName]);
    }

    /**
     * Describe all the members of a map
     *
     * @param string a class name
     * @return array member name => member type
     * @access protected
     */
    function _describeMapMembers($mapName) {
	if (empty($this->_mapInfoCache[$mapName])) {
	    eval("\$info = $mapName::getMapInfo();");
	    $this->_mapInfoCache[$mapName] = $info;
	}

	return $this->_mapInfoCache[$mapName];
    }

    /**
     * Start tracing
     *
     * This method is for use by GalleryStorage subclasses only.  If Gallery is
     * in debug, this method will begin storing all output and routing it into
     * Gallery's debug system
     *
     * @access protected
     */
    function _traceStart() {
	global $gallery;
	if ($gallery->getDebug()) {
	    ob_start();
	}
    }

    /**
     * Stop tracing
     *
     * This method is for use by GalleryStorage subclasses only.  If Gallery is
     * in debug, this will method will stop tracing.
     */
    function _traceStop() {
	global $gallery;
	if ($gallery->getDebug()) {
	    $buf = ob_get_contents();
	    ob_end_clean();
	    $gallery->debug($buf);
	}
    }
}

/**
 * Database implementation of the GallerySearchResult interface.
 *
 * @package GalleryCore
 * @subpackage Storage
 */
class DatabaseSearchResults {

    /**
     * Internal record set object
     *
     * @var object ADORecordSet $_recordSet
     * @access private
     */
    var $_recordSet;

    function DatabaseSearchResults($recordSet) {
	$this->_recordSet = $recordSet;
    }

    /**
     * The number of results from this search
     *
     * @return int the number of results
     */
    function resultCount() {
	return $this->_recordSet->RecordCount();
    }

    /**
     * Return the next search result, as an associative array
     *
     * @return array the next result or false if EOF
     */
    function nextResult() {
	return $this->_recordSet->FetchRow();
    }
}
?>
