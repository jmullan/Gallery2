<?php
/*
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2007 Bharat Mediratta
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA  02110-1301, USA.
 */
/* This class is extensively based on the adodb-sxmlschema03 class developed by Richard Tango-Lowy &
 * Dan Cech, Released under both BSD license and Lesser GPL library license.  Whenever there is any
 * discrepancy between the two licenses, the BSD license will take precedence.  The orignal class
 * was copyright: Copyright (c) 2004-2005 ars Cognita Inc., all rights reserved.
 */

/**
 * Current Schema Version
 */
if (!defined('EXPORT_SCHEMA_VERSION')) {
    define('EXPORT_SCHEMA_VERSION', '1.0');
}

/**
 * GalleryDatabaseExport provides the functionality to export the gallery database.
 * Creating an GalleryDatabaseExport object is the first step in exporting the information store in
 * the Gallery databases.  The export function exports all the versions.dat file, the config.php
 * file, the tables for the modules and all the data contianed in a Gallery installation.  The
 * actual albums and items are not exported as part of this process.
 *
 * For a complete backup, perform this export and then use the operating system faclities to
 * back up both the g2data/album and g2data/backups directory.
 *
 * @package GalleryCore
 * @subpackage Storage
 * @author Tim Almdal <tnalmdal@shaw.ca>
 * @version $Revision$
 */
class GalleryDatabaseExport {
    /**
     * Defines the number of rows to be read before letting the user know that we are still working.
     */
    var $_rowChunkSize = 200;

    /**
     * This array contains a list of tables that are transitory in nature and do not need to have
     * the data in them backed up
     */
    var $_ignoreTables = array('cachemap' => 1, 'lock' => 1, 'sessionmap' => 1, 'schema' => 1);

    /**
     * This variable contains the call back information and contains the follwoing keys
     * 'progress' current progress
     * 'total' total work involved
     * 'callback' progress bar notification callback
     */
    var $_callBack;

    /*
     * This variable contains the length of the column prefix.
     */
    var $_fieldPrefixLength;

    /**
     * Extracts an XML schema from an existing database.
     *
     * Call this method to create an XML schema string from an existing database.
     * @param array $progressCallback Callback for progress Reports. This callback function should
     *      update the progress bar that is being used. Currently, the upgrader uses a different
     *      mechanism to update the progress bar than the maintenance screens.
     *      @see DatabaseBackupTask::progressCallBack and DatabaseBackupStep::backupCallback.
     * @param string $fileName (optional) Name of the file to write the database extract xml to,
     *      if not supplied will default to g2data/backups/backup_date.xml.
     * @return array object GalleryStatus a status code
     *		     string Path name of the backup file
     *		     array of warning messages to be displayed to the administrator.
     * @todo When the progress bar handling is standardized for both upgrades and maintenance
     * 	     screens, then replace the call back function with a StatusMonitor object.
     */
    function exportToXmlFile($progressCallback, $fileName=null) {
	global $gallery;
	$platform =& $gallery->getPlatform();
	$storage =& $gallery->getStorage();

	$warnings = array();

	$this->_callBack = array('callback' => $progressCallback, 'progress' => 0, 'total' => 100);

	$storageConfig = $gallery->getConfig('storage.config');
    	$this->_fieldPrefixLength = strlen($storageConfig['columnPrefix']);

	list ($ret, $fileHandle, $filepath) = $this->_openBackupFileForWriting($fileName);
	if ($ret) {
	    return array($ret, null, null);
	}

	/* Calculate the number of tables that will probably be exported */
	list ($tableName, $unused) = $storage->_translateTableName('Schema');

	list ($ret, $results) = $storage->search('SELECT COUNT(*) FROM ' . $tableName);
	if ($ret) {
	    return array($ret, null, null);
	}

	$tableCount = 0;
	if ($results->resultCount() > 0) {
	    $row = $results->nextResult();
	    $tableCount = $row[0];
	}

	list ($ret, $coreModule) = GalleryCoreApi::loadPlugin('module', 'core', true);
	if ($ret) {
	    return array($ret, null, null);
	}

	$versions = $coreModule->getInstalledVersions();

	$string = '<?xml version="1.0"?>' . "\n";
	$written = $platform->fwrite($fileHandle, $string);
	if (!$written) {
	    return array(GalleryCoreApi::error(ERROR_PLATFORM_FAILURE, __FILE__, __LINE__,
								'Unable to write to export file'),
			 null, null);
	}

	$written = $platform->fwrite($fileHandle,
				     '<export schema-version="' . EXPORT_SCHEMA_VERSION
				     . '" tables="' . $tableCount .'" core-version="'
				     . $versions['core'] . '" gallery-version="'
				     . $versions['gallery'] . '">' . "\n");

	if (!$written) {
	    return array(GalleryCoreApi::error(ERROR_PLATFORM_FAILURE, __FILE__, __LINE__,
						'Unable to write to export file'),
			 null, null);
	}

	$written = $platform->fwrite($fileHandle, '  <plugin-status-list>' . "\n");
	if (!$written) {
	    return array(GalleryCoreApi::error(ERROR_PLATFORM_FAILURE, __FILE__, __LINE__,
						'Unable to write to export file'),
			 null, null);
	}

	foreach (array('module', 'theme') as $pluginType) {
	    list ($ret, $plugins) = GalleryCoreApi::fetchPluginStatus($pluginType, true);
	    if ($ret) {
		return array($ret, null, null);
	    }
	    $this->_callBack['total'] = $this->_callBack['progress'] + count($plugins);

	    list ($ret, $pluginsList) = GalleryCoreApi::fetchPluginlist($pluginType, true);
	    if ($ret) {
		return array($ret, null, null);
	    }

	    foreach ($plugins as $pluginId => $unused) {
	    	if ($pluginId != 'core' && !array_key_exists($pluginId, $pluginsList)) {
		    /* This plugin is not installed so issue a warning message. */
		    $msg = $coreModule->translate(array('text' => 'The %s "%s" is not available'
								. ' and the will not be backed up.',
							'arg1' => $pluginType,
							'arg2' => $pluginId));
		    $warnings[] = $msg;
	    	}
	    }

	    $ret = $this->_exportPluginStatus($fileHandle, $pluginType, $plugins);
	    if ($ret) {
		return array($ret, null, null);
	    }
	    $this->updateStatus();
	}

	$written = $platform->fwrite($fileHandle, '  </plugin-status-list>' . "\n");
	if (!$written) {
	    return array(GalleryCoreApi::error(ERROR_PLATFORM_FAILURE, __FILE__, __LINE__,
							  'Unable to write to export file'),
			 null, null);
	}

	$ret = $this->_exportConfigFile($fileHandle);
	if ($ret) {
	    return array($ret, null, null);
	}

	$this->updateStatus();

	list ($ret, $plugins) = GalleryCoreApi::fetchPluginStatus('module', true);
	if ($ret) {
	    return array($ret, null, null);
	}

	$ret = $this->_exportModule($fileHandle, 'core', $plugins['core']);
	if ($ret) {
	    return array($ret, null, null);
	}
	unset($plugins['core']);
	$this->updateStatus();

	$this->_callBack['total'] = $this->_callBack['progress'] + count($plugins);
	foreach ($plugins as $pluginId => $plugin) {
	    /* If the plugin version isn't set in the plugin data array, it's not installed */
	    if (empty($plugin['version'])) {
		continue;
	    }

	    $ret = $this->_exportModule($fileHandle, $pluginId);
	    if ($ret) {
		return array($ret, null, null);
	    }
	}

	$written = $platform->fwrite($fileHandle, '</export>' . "\n");
	if (!$written) {
	    return array(GalleryCoreApi::error(ERROR_PLATFORM_FAILURE, __FILE__, __LINE__,
								'Unable to write to export file'),
			 null, null);
	}

	if (!$platform->fclose($fileHandle)) {
	    return array(GalleryCoreApi::error(ERROR_PLATFORM_FAILURE, __FILE__, __LINE__,
								'Unable to write to export file'),
			 null, null);
	}

	$platform->chmod($filepath, 0444);
	return array(null, $filepath, $warnings);
    }

    /**
     * Export the list of installed plugins.  For each plugin include whether it is active or not,
     * the module version number, the required core version and the required gallery version.
     * @param resource $handle Handle to output export file.
     * @param string $pluginType What type of plugin is it (module or theme)
     * @param array $plugins A Gallery Plugin status array
     * @return GalleryStatus object
     */
    function _exportPluginStatus($handle, $pluginType, $plugins) {
	global $gallery;
	$platform =& $gallery->getPlatform();

	foreach ($plugins as $pluginId => $plugin) {
	    /* If the plugin version isn't set in the plugin data array, it's not installed */
	    if (empty($plugin['version'])) {
		continue;
	    }

	    $coreApi = $plugin['requiredCoreApi'];
	    $coreApi = $coreApi[0] . '.' . $coreApi[1];

	    $api = ($pluginType == 'module') ? $plugin['requiredModuleApi']
	    				     : $plugin['requiredThemeApi'];
	    $api = $api[0] . '.' . $api[1];

	    $active = isset($plugin['active']) ? $plugin['active'] : 0;

	    $line = '    <plugin-status id="' . $pluginId . '" required-core-api="' . $coreApi
			. '" required-api="' . $api . '" version="' . $plugin['version']
			. '" active="' . $active . '" type="' . $pluginType . '"/>' . "\n";
	    $written = $platform->fwrite($handle, $line);
	    if (!$written) {
		return GalleryCoreApi::error(ERROR_PLATFORM_FAILURE, __FILE__, __LINE__,
					                    'Unable to write to export file');
	    }
	}

	return null;
    }

    /**
     * Simulate calling htmlspecialchars($value, ENT_COMPAT, 'UTF-8') We avoid using
     * htmlspecialchars directly because on some versions of PHP (notable PHP 4.1.2) it
     * changes the character set of the input data (in one environment it converted the
     * UTF-8 data to ISO-8859-1)
     * @param $string $valueToConvert String to escape the html special characters.
     * @return string The escaped string.
     * @todo After the acceptance of this change, create a small one to move this routine to
     *       GalleryUtilities as a common function.
     */
    function _htmlSpecialChars($valueToConvert) {
    	return str_replace(array('&', '"', '<', '>'), array('&amp;', '&quot;', '&lt;', '&gt;'),
			   $valueToConvert);
    }

    /**
     * Export the config.php file to the exported stream.
     * @param resource $handle Handle to output export file.
     * @return object GalleryStatus
     */
    function _exportConfigFile($handle) {
	global $gallery;
	$platform =& $gallery->getPlatform();

	$file = GALLERY_CONFIG_DIR . '/config.php';
	$contents = $platform->file_get_contents($file);

	$written = $platform->fwrite($handle,
			   '  <config>' . $this->_htmlSpecialChars($contents) . '</config>' . "\n");
	if (!$written) {
	    return GalleryCoreApi::error(ERROR_PLATFORM_FAILURE, __FILE__, __LINE__,
					                    'Unable to write to export file');
	}

	return null;
    }

    /**
     * Export a module to the export file.
     * @param resource $handle Handle to output export file
     * @param string $pluginId A plugin id
     * @return GalleryStatus object
     */
    function _exportModule($handle, $pluginId) {
	global $gallery;
	$platform =& $gallery->getPlatform();
	$storage =& $gallery->getStorage();

	$extras =& $storage->_getExtras();
	$sql = $extras->getModuleSql($pluginId);
	if (count($sql['table']) == 0){
	    $this->updateStatus();
	    return null;
	}

	$line = '  <plugin id="' . $this->_htmlSpecialChars($pluginId) . '" type="module">' . "\n";
	$written = $platform->fwrite($handle, $line);
	if (!$written) {
	    return GalleryCoreApi::error(ERROR_PLATFORM_FAILURE, __FILE__, __LINE__,
					                    'Unable to write to export file');
	}

	$this->_callBack['total'] += count($sql['table']);
	/* If the core module then export schema and sequence tables first */
	if ($pluginId == 'core') {
	    $this->_callBack['total'] += 3;

	    $ret = $this->_exportTable($handle, 'Schema', $sql);
	    if ($ret) {
		return $ret;
	    }
	    unset($sql['table']['Schema']);
	    $this->updateStatus();

	    /* Create our sequences now */
	    foreach (array(DATABASE_SEQUENCE_LOCK, DATABASE_SEQUENCE_ID,
			   DATABASE_SEQUENCE_EVENT_LOG) as $sequenceId) {
		$ret = $this->_exportSequence($handle, $sequenceId);
		if ($ret) {
		    return $ret;
		}
		$this->updateStatus();
	    }
	}

	foreach ($sql['table'] as $table => $unused) {
	    $ret = $this->_exportTable($handle, $table, $sql);
	    if ($ret) {
		return $ret;
	    }
	}

	$written = $platform->fwrite($handle, '  </plugin>' . "\n");
	if (!$written) {
	    return GalleryCoreApi::error(ERROR_PLATFORM_FAILURE, __FILE__, __LINE__,
					                    'Unable to write to export file');
	}
	$this->updateStatus();

	return null;
    }

    /**
     * Export the a sequence. Sequences are not defined by the schema.tpl file but are created by
     * calling adoDB directly.
     * @param resource $handle Handle to output export file
     * @param string $sequenceId The sequence Id to export.
     * @return GalleryStatus object
     */
    function _exportSequence($handle, $sequenceId) {
	global $gallery;
	$storage =& $gallery->getStorage();
	$platform =& $gallery->getPlatform();

	list ($ret, $sequenceValue) = $storage->getUniqueId($storage->_tablePrefix . $sequenceId);
	if ($ret) {
	    return GalleryCoreApi::error(ERROR_STORAGE_FAILURE);
	}

	$line = '    <sequence name="' . $sequenceId . '" seq="'. $sequenceValue . '" />' . "\n";
	$written = $platform->fwrite($handle, $line);
	if (!$written) {
	    return GalleryCoreApi::error(ERROR_PLATFORM_FAILURE, __FILE__, __LINE__,
					                    'Unable to write to export file');
	}

	$this->updateStatus();

	return null;
    }

    /**
     * Export a gallery table to the output stream
     * @param resource $handle Handle to output export file
     * @param string $table The table to export.
     * @param array $sql The database definitions from the shema.tpl file..
     * @return GalleryStatus object
     */
    function _exportTable($handle, $table, $sql) {
	global $gallery;
	$storage =& $gallery->getStorage();
	$platform =& $gallery->getPlatform();

	$written = $platform->fwrite($handle, '    <table name="' . $table . '">' . "\n");
	if (!$written) {
	    return GalleryCoreApi::error(ERROR_PLATFORM_FAILURE, __FILE__, __LINE__,
					                    'Unable to write to export file');
	}

	$line = '      <create-sql>' . "\n" . '<![CDATA['
			. $this->_htmlSpecialChars($sql['table'][$table])
			. ']]>'  . "\n" . '      </create-sql>' . "\n";
	$written = $platform->fwrite($handle, $line);
	if (!$written) {
	    return GalleryCoreApi::error(ERROR_PLATFORM_FAILURE, __FILE__, __LINE__,
					                    'Unable to write to export file');
	}

	/*
	 * Some databases (notably MySQL on Win32) don't support mixed case
	 * table names.  So, when we get the meta table list back, it's lower
	 * case.  Force all metatable listings to lower case and then expect
	 * them to be lowercase so that we're consistent.
	 */
	$tableLower = GalleryUtilities::strToLower($table);

	/* Check to see if we want to skip the data. */
	if (!array_key_exists($tableLower, $this->_ignoreTables)) {
	    $ret = $this->_exportData($handle, $table);
	    if ($ret) {
		return $ret;
	    }
	}

	$written = $platform->fwrite($handle, '    </table>' . "\n");
	if (!$written) {
	    return GalleryCoreApi::error(ERROR_PLATFORM_FAILURE, __FILE__, __LINE__,
					                    'Unable to write to export file');
	}

	$this->updateStatus();
	return null;
    }

    /**
     * Export the table data to the output stream
     * @param resource $handle Handle to output export file
     * @param string $table The table to export.
     * @return GalleryStatus object
     * @todo Need to at some point identify fields that contain binary data and
     */
    function _exportData($handle, $table) {
	global $gallery;
	$storage =& $gallery->getStorage();
	$platform =& $gallery->getPlatform();

	list ($tableName, $unused) = $storage->_translateTableName($table);

	list ($ret, $results) = $storage->search('SELECT COUNT(*) FROM ' . $tableName);
	if ($ret) {
	    return $ret;
	}

	$rowCount = 0;
	if (is_object($results) && $results->resultCount() > 0) {
	    $row = $results->nextResult();
	    $rowCount = $row[0];
	}

	if ($rowCount > 0) {
	    /* Calculate the number of data chunks to read. */
	    $dataChunks = 1;

	    /*
	     * This table exceeds our chunk threshold, so let us split up the request
	     * and provides some feedback that we are actually working.
	     */
	    if ($rowCount > $this->_rowChunkSize) {
		/* Oops the amount of work just got bigger. */
		$dataChunks = ceil($rowCount / $this->_rowChunkSize);
		$this->_callBack['total'] += $dataChunks;
	    }

	    $written = $platform->fwrite($handle, "        <data>\n");
	    if (!$written) {
		return GalleryCoreApi::error(ERROR_PLATFORM_FAILURE, __FILE__, __LINE__,
					                    'Unable to write to export file');
	    }

	    $extras =& $storage->_getExtras();
	    list ($ret, $fields) = $extras->metaColumns($tableName);
	    if ($ret) {
		return $ret;
	    }

	    foreach ($fields as $fieldName) {
		$written = $platform->fwrite($handle,  '          <field name="'
			   . $this->_htmlSpecialChars(substr($fieldName, $this->_fieldPrefixLength))
			   . '" />' . "\n");
		if (!$written) {
		    return GalleryCoreApi::error(ERROR_PLATFORM_FAILURE, __FILE__, __LINE__,
					                    'Unable to write to export file');
		}
	    }

	    /* Create Query Statement.  Just use all the fields to create an order */
	    $query = 'SELECT ' . implode(', ', $fields) . ' FROM ' . $tableName
			. ' ORDER BY ' . implode(' ASC, ', $fields) . ' ASC';

	    $offset = 0;
	    $options = array('limit' => array('count' => $this->_rowChunkSize));
	    while (true) {
		$options['limit']['offset'] = $offset;
		list ($ret, $results) = $storage->search($query, array(), $options);
		if ($ret) {
		    return $ret;
		}

		if ($results->resultCount() == 0) {
		    break;
		}
		while ($row = $results->nextResult()) {
		    foreach ($row as $key => $val) {
			$row[$key] = $this->_htmlSpecialChars($val);
		    }
		    $written = $platform->fwrite($handle, '          <row><f>'
				. implode('</f><f>', $row) . '</f></row>' . "\n");
		    if (!$written) {
			return GalleryCoreApi::error(ERROR_PLATFORM_FAILURE, __FILE__, __LINE__,
					                    'Unable to write to export file');
		    }
		}
		$this->updateStatus();
		$offset += $results->resultCount();
	    }
	    $written = $platform->fwrite($handle, '        </data>' . "\n");
	    if (!$written) {
		return GalleryCoreApi::error(ERROR_PLATFORM_FAILURE, __FILE__, __LINE__,
					                    'Unable to write to export file');
	    }
	} else {
	    $this->updateStatus();
	}

	return null;
    }

    /**
     * This method calls the the status update method that was passwd by the caller to the Database
     * Exporter class.
     *
     * @todo At some future point, when the various progress bar methods are standardized, change
     * 	     this call to call the update progress bar of a common status notifier.
     */
    function updateStatus() {
	global $gallery;

	$this->_callBack['progress']++;
	$complete = $this->_callBack['progress'] / $this->_callBack['total'];
	call_user_func_array($this->_callBack['callback'], array($complete));

	$gallery->guaranteeTimeLimit(60);
    }

    /**
     * Creates the file name and opens the file to write the content of the backup.
     *
     * @param string $fileName (optional) Name of the file to write the database extract xml to,
     *		 if not supplied will default to g2data/backups/g2backup_date.txt
     * @return array object GalleryStatus a status code
     *	   fileHandle file handle to the open file
     *	   string path name of the backup file
     */
    function _openBackupFileForWriting($fileName=null) {
	global $gallery;
	$platform =& $gallery->getPlatform();

	if (empty($fileName)) {
	    $dirName = $gallery->getConfig('data.gallery.backup');
	    list ($exists, $unused) = GalleryUtilities::guaranteeDirExists($dirName);
	    if (!$exists) {
		return array(GalleryCoreApi::error(ERROR_BAD_PATH, __FILE__, __LINE__,
					'Unable to open the backup file for output'), null, null);
	    }

	    $storeConfig = $gallery->getConfig('storage.config');
	    $fileName = $dirName . $storeConfig['database'] . '_' . date('Y_m_d_Hi') . '.xml';
	}

	$handle = $platform->fopen($fileName, 'w');
	if (!$handle) {
	    return array(GalleryCoreApi::error(ERROR_BAD_PATH, __FILE__, __LINE__,
					'Unable to open the backup file for output'), null, null);
	}

	return array(null, $handle, $fileName);
    }
}
?>
