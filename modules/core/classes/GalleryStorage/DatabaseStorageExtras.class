<?php
/*
 * $RCSfile$
 *
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2005 Bharat Mediratta
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA  02110-1301, USA.
 */
/**
 * @version $Revision$ $Date$
 * @package GalleryCore
 * @author Bharat Mediratta <bharat@menalto.com>
 */

/**
 * Extended functionality in GalleryStorage that's not generally required for
 * simply viewing albums and photos.
 *
 * @package GalleryCore
 * @subpackage Storage
 */
class DatabaseStorageExtras /* the other half of DatabaseStorage */ {
    /**
     * Constructor
     * @param object DatabaseStorage the database storage instance
     */
    function DatabaseStorageExtras(&$databaseStorage) {
	$this->_ds =& $databaseStorage;
    }

    /**
     * Return a non transactional database connection
     *
     * @return array object GalleryStatus a status code
     *               object ADOdb a database connection
     */
    function _getNonTransactionalDatabaseConnection() {
	/*
	 * If we're transactional, then we need another connection to
	 * manipulate our locks, since they have to operate outside of a
	 * transaction.
	 */
	if ($this->_ds->_isTransactional) {
	    if (empty($this->_ds->_nonTransactionalDb)) {
		list ($ret, $this->_ds->_nonTransactionalDb) = $this->_ds->_getConnection(true);
		if ($ret->isError()) {
		    return array($ret->wrap(__FILE__, __LINE__), null);
		}
	    }
	    return array(GalleryStatus::success(), $this->_ds->_nonTransactionalDb);
	} else {
	    return array(GalleryStatus::success(), $this->_ds->_db);
	}
    }

    /**
     * @see GalleryStorage::saveEntity
     */
    function saveEntity(&$entity) {
	if (empty($this->_ds->_db)) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__);
	}

	$ret = $this->_ds->_guaranteeTransaction();
	if ($ret->isError()) {
	    return $ret;
	}

	/*
	 * Update the serial number, but remember the original one
	 */
	$originalSerialNumber = $entity->getSerialNumber();
	$entity->setSerialNumber($originalSerialNumber + 1);

	/*
	 * Get our member info for this class
	 */
	list ($ret, $memberInfo) = $this->_ds->_describeEntityMembers($entity->getEntityType());
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}
	$idColumn = null;

	/*
	 * Build up a complete picture of all the various changed fields, so
	 * that we can do an insert or update.
	 */
	$dataTable = array();
	$id = array();
	foreach ($memberInfo['members'] as $memberName => $memberData) {
	    $type = $memberData['type'];
	    $class = $memberData['class'];
	    list ($tableName, $unused) = $this->_ds->_translateTableName($class);

	    /* If the member is modified, record the new value in our table */
	    if ($entity->getModifiedFlag($memberName) & MEMBER_MODIFIED) {
		$getFunc = 'get' . $memberName;
		$value = $entity->$getFunc();

		/* Convert empty values to null */
		if (!is_numeric($value) && empty($value)) {
		    $value = null;
		}

		/* Convert timestamps to the database representation */
		if ($type & STORAGE_TYPE_TIMESTAMP) {
		    $value = $this->_ds->_db->DBTimeStamp($value);
		}

		$columnName = $this->_ds->_translateColumnName($memberName);
		$dataTable[$tableName][$columnName] = $value;
	    } else {
		/*
		 * If we haven't set up a table for this class, do so now.
		 * Otherwise we don't have a complete list of tables that we
		 * need to insert into in order for this class to be completely
		 * serialized.
		 */
		if (!isset($dataTable[$tableName])) {
		    $dataTable[$tableName] = array();
		}
	    }

	    if ($type & STORAGE_TYPE_ID) {
		$getFunc = 'get' . $memberName;
		$value = $entity->$getFunc();

		$id['column'] = $this->_ds->_translateColumnName($memberName);
		$id['value'] = $value;
	    }
	}

	if ($entity->testPersistentFlag(STORAGE_FLAG_NEWLY_CREATED)) {
	    /*
	     * Iterate through the data table and make up an INSERT statement
	     * for each table that requires one.
	     */
	    foreach ($dataTable as $tableName => $columnChanges) {

		/* Make sure that the id column is set for each table */
		if (empty($columnChanges[$id['column']])) {
		    $columnChanges[$id['column']] = $id['value'];
		}

		$columns = array_keys($columnChanges);
		$data = array_values($columnChanges);
		$markers = GalleryUtilities::makeMarkers(sizeof($columnChanges));
		$query = 'INSERT INTO ' . $tableName . ' (';
		$query .= join(', ', $columns);
		$query .= ') VALUES (' . $markers . ')';

		$this->_ds->_traceStart();
		$recordSet = $this->_ds->_db->Execute($query, $data);
		$this->_ds->_traceStop();

		if (!$recordSet) {
		    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
		}
	    }
	} else {
	    /*
	     * Iterate through the data table and make an UPDATE statement for
	     * each table that requires one.  Make sure that we do the table
	     * that has the serial number in it first, as we use the serial
	     * number to make sure that we're not hitting a concurrency issue.
	     */
	    $serialNumberClass = $memberInfo['members']['serialNumber']['class'];
	    list ($serialNumberTable, $unused) = $this->_ds->_translateTableName($serialNumberClass);

	    $queryList = array();
	    foreach ($dataTable as $tableName => $columnChanges) {
		$changeList = array();
		$data = array();

		foreach ($columnChanges as $columnName => $value) {
		    $changeList[] = $columnName . '=?';
		    $data[] = $value;
		}

		if (sizeof($changeList)) {
		    $query = 'UPDATE ' . $tableName  .  ' SET';
		    $query .= ' ' . join(',', $changeList);
		    $query .= ' WHERE ' . $id['column'] . '=?';
		    $data[] = $id['value'];

		    if (!strcmp($tableName, $serialNumberTable)) {
			$query .= ' AND ' .
				$this->_ds->_translateColumnName('serialNumber') .
				'=?';
			$data[] = $originalSerialNumber;
			array_unshift($queryList, array($query, $data));
		    } else {
			array_push($queryList, array($query, $data));
		    }
		}
	    }

	    /*
	     * Now apply each UPDATE statement in turn.  Make sure that we're
	     * only affecting one row each time.
	     */
	    foreach ($queryList as $queryAndData) {
		list($query, $data) = $queryAndData;

		$this->_ds->_traceStart();
		$recordSet = $this->_ds->_db->Execute($query, $data);
		$this->_ds->_traceStop();

		if (!$recordSet) {
		    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
		} else {
		    $affectedRows = $this->_ds->_db->Affected_Rows();
		    if ($affectedRows == 0) {
			return GalleryStatus::error(ERROR_OBSOLETE_DATA, __FILE__, __LINE__,
						    "$query (" . implode('|', $data) . ')');
		    } else if ($affectedRows > 1) {
			/* Holy shit, we just updated more than one row!  What do we do now? */
			return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__,
					      "$query (" . implode('|', $data) . ") $affectedRows");
		    }
		}
	    }
	}

	$entity->clearPersistentFlag(STORAGE_FLAG_NEWLY_CREATED);
	$entity->clearModifiedFlags();
	$ret = $entity->onSave();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * @see GalleryStorage::deleteEntity
     */
    function deleteEntity(&$entity) {
	if (empty($this->_ds->_db)) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__);
	}

	$ret = $this->_ds->_guaranteeTransaction();
	if ($ret->isError()) {
	    return $ret;
	}

	/*
	 * If this object has not yet been saved in the database, don't bother
	 * saving it.
	 */
	if ($entity->testPersistentFlag(STORAGE_FLAG_NEWLY_CREATED)) {
	    $entity->clearPersistentFlag(STORAGE_FLAG_NEWLY_CREATED);
	    $entity->setPersistentFlag(STORAGE_FLAG_DELETED);
	    return GalleryStatus::success();
	}

	/*
	 * Get our persistent and member info for this class
	 */
	list ($ret, $memberInfo) =
	    $this->_ds->_describeEntityMembers($entity->getEntityType());
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	$idCol = $this->_ds->_translateColumnName('id');

	$tables = array();
	foreach ($memberInfo['members'] as $columnName => $columnInfo) {
	    list ($tableName, $unused) = $this->_ds->_translateTableName($columnInfo['class']);
	    $tables[$tableName] = 1;
	}

	/*
	 * XXX OPT:  Override this for specific database implementations that
	 * allow multi-table delete.
	 */
	foreach ($tables as $tableName => $junk) {
	    $query = 'DELETE FROM ' . $tableName .
		    ' WHERE ' . $idCol . '=?';
	    $data = array($entity->getId());

	    $this->_ds->_traceStart();
	    $recordSet = $this->_ds->_db->Execute($query, $data);
	    $this->_ds->_traceStop();
	    if (!$recordSet) {
		return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	    }
	}

	$entity->setPersistentFlag(STORAGE_FLAG_DELETED);

	return GalleryStatus::success();
    }

    /**
     * @see GalleryStorage::loadEntities
     */
    function loadEntities($ids) {
	global $gallery;

	if (empty($this->_ds->_db)) {
	    return array(GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__), null);
	}

	/* Identify all the ids at once */
	list ($ret, $types) = $this->_identifyEntities($ids);
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	/* Separate the ids by type */
	$classNames = array();
	$gallery->guaranteeTimeLimit(5);
	for ($i = 0; $i < sizeof($ids); $i++) {
	    if (empty($types[$i])) {
		return array(GalleryStatus::error(ERROR_MISSING_OBJECT, __FILE__, __LINE__,
						  "Missing object for id $ids[$i]"), null);
	    }
	    $classNames[$types[$i]][$ids[$i]] = 1;
	}

	/* Load them in groups */
	foreach ($classNames as $className => $targetIdHash) {
	    $gallery->guaranteeTimeLimit(5);

	    /* Get unique target ids */
	    $targetIds = array_keys($targetIdHash);

	    /* Get our member info for this class */
	    list ($ret, $memberInfo) = $this->_ds->_describeEntityMembers($className);
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }

	    $idCol = $this->_ds->_translateColumnName('id');

	    /* Build up our query */
	    $columns = array();
	    $tables = array();
	    $where = array();
	    $types = array();
	    $callbacks = array();
	    $markers = GalleryUtilities::makeMarkers(sizeof($targetIds));
	    foreach ($memberInfo['members'] as $columnName => $columnInfo) {
		list ($tableName, $unused) = $this->_ds->_translateTableName($columnInfo['class']);
		$types[] = $columnInfo['type'];
		/* Don't use ucfirst as it may be affected by current locale */
		$callbacks[] = 'set' . strtr($columnName{0}, 'abcdefghijklmnopqrstuvwxyz',
		    'ABCDEFGHIJKLMNOPQRSTUVWXYZ') . substr($columnName, 1);
		$columns[$tableName . '.' . $this->_ds->_translateColumnName($columnName)] = 1;
		$tables[$tableName] = 1;
	    }
	    $tables = array_keys($tables);
	    $columns = array_keys($columns);

	    for ($i = 0; $i < sizeof($tables); $i++) {
		if ($i == 0) {
		    $where[] = $tables[$i] . '.' . $idCol . ' IN (' . $markers . ')';
		} else {
		    $where[] = $tables[$i] . '.' . $idCol . '=' . $tables[0] . '.' . $idCol;
		}
	    }

	    $query = 'SELECT ';
	    $query .= join(', ', $columns);
	    $query .= ' FROM ';
	    $query .= join(', ', $tables);
	    $query .= ' WHERE ';
	    $query .= join(' AND ', $where);

	    /* Execute the query */
	    $GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;

	    $this->_ds->_traceStart();
	    $recordSet = $this->_ds->_db->Execute($query, $targetIds);
	    $this->_ds->_traceStop();
	    if ($recordSet) {
		if ($recordSet->RecordCount() != sizeof($targetIds)) {
		    return array(GalleryStatus::error(ERROR_MISSING_OBJECT, __FILE__, __LINE__),
				 null);
		}

		/* Process all the results */
		$j = 0;
		while ($row = $recordSet->FetchRow()) {
		    if (++$j % 20 == 0) {
			$gallery->guaranteeTimeLimit(5);
		    }
		    $entity = new $className;
		    if (empty($entity)) {
			return array(GalleryStatus::error(ERROR_BAD_DATA_TYPE, __FILE__, __LINE__),
				     null);
		    }

		    for ($i = 0; $i < sizeof($callbacks); $i++) {
			$value = $row[$i];

			/* Convert the database representation to a timestamp */
			if ($types[$i] & STORAGE_TYPE_TIMESTAMP) {
			    $value = $this->_ds->_db->UnixTimeStamp($value);
			}

			/* Store the value in the object */
			$entity->$callbacks[$i]($value);
		    }

		    $entity->clearModifiedFlags();
		    $entities[$entity->getId()] = $entity;
		}

		$recordSet->Close();
	    } else {
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	    }
	}

	/* Assemble the entities in the right order and return them */
	$result = array();
	foreach ($ids as $id) {
	    $result[] = $entities[$id];
	}

	return array(GalleryStatus::success(), $result);
    }

    /**
     * @see GalleryStorage::newEntity
     */
    function newEntity(&$entity) {
	if (empty($this->_ds->_db)) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__);
	}

	list ($ret, $id) = $this->getUniqueId();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	$entity->setId($id);
	$entity->setSerialNumber(0);
	$entity->setPersistentFlag(STORAGE_FLAG_NEWLY_CREATED);

	return GalleryStatus::success();
    }

    /**
     * @see GalleryStorage::getUniqueId
     */
    function getUniqueId() {
	if (empty($this->_ds->_db)) {
	    return array(GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__), null);
	}

	/* In case we're embedded in an app that sets adodb hasGenID to false (xaraya/postnuke) */
	if (isset($this->_ds->_db->hasGenID) && !$this->_ds->_db->hasGenID) {
	    $this->_ds->_db->hasGenID = $setGenID = true;
	}

	/* Get the id of the next object from our sequence */
	$this->_ds->_traceStart();
	$id = (int)$this->_ds->_db->GenId($this->_ds->_tablePrefix . DATABASE_SEQUENCE_ID);
	$this->_ds->_traceStop();

	if (isset($setGenID)) {
	    $this->_ds->_db->hasGenID = false;
	}

	return array(GalleryStatus::success(), $id);
    }

    /**
     * @see GalleryStorage::refreshEntity
     */
    function refreshEntity($entity) {
	if (empty($this->_ds->_db)) {
	    return array(GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__), null);
	}

	/*
	 * We could check the serial number against the database, or check to
	 * see if the entity is modified in order to figure out whether or not
	 * we should refresh.  But either way that requires a database hit so we
	 * might as well just retrieve the record every time
	 */
	list ($ret, list($freshEntity)) = $this->_ds->loadEntities(array($entity->getId()));
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	/* Let entity do its post-load procedure */
	$ret = $freshEntity->onLoad();
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	return array(GalleryStatus::success(), $freshEntity);
    }

    /**
     * @see GalleryStorage::acquireReadLock
     */
    function acquireReadLock($entityIds, $timeout) {
	/* It's ok to pass in a single id */
	if (!is_array($entityIds)) {
	    $entityIds = array($entityIds);
	}

	/* Acquire a non-transactional connection to use for this request */
	list ($ret, $db) = $this->_getNonTransactionalDatabaseConnection();
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	/* Know when to call it quits */
	$cutoffTime = time() + $timeout;

	/* Get the true name of the lock table */
	list ($lockTable, $unused) = $this->_ds->_translateTableName('Lock');

	/*
	 * Algorithm:
	 * 1. Get clearance to acquire locks (and get the lock id)
	 * 2. If any of the entities that we want to lock are currently write
	 *    locked, then clear the request and go back to step 1.
	 * 3. Acquire our read locks
	 */
	while (true) {
	    list($ret, $lockId) = $this->_getLockClearance($cutoffTime);
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }

	    /*
	     * Check to see if any of the ids that we care about are write
	     * locked.
	     */
	    $writeEntityIdCol = $this->_ds->_translateColumnName('writeEntityId');
	    $markers = GalleryUtilities::makeMarkers(sizeof($entityIds));
	    $query = 'SELECT COUNT(*) FROM ' . $lockTable . ' ' .
		    'WHERE ' . $writeEntityIdCol . ' IN (' . $markers . ') ';
	    $data = $entityIds;

	    $GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;

	    $this->_ds->_traceStart();
	    $recordSet = $db->Execute($query, $data);
	    $this->_ds->_traceStop();
	    if (!$recordSet) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	    }

	    $row = $recordSet->FetchRow();
	    if ($row[0] == 0 ) {
		/* Success */
		break;
	    } else {
		/* An entity that we want is write locked */
		$this->_releaseLockById($lockId);

		if (time() > $cutoffTime) {
		    return array(GalleryStatus::error(ERROR_LOCK_TIMEOUT, __FILE__, __LINE__),
				 null);
		}

		/* Wait a second and try again */
		sleep(1);

		/* Expire any bogus locks */
		$ret = $this->_expireLocks();
		if ($ret->isError()) {
		    return array($ret->wrap(__FILE__, __LINE__), null);
		}
	    }
	}

	/* Put in a read lock for every entity id */
	$lockIdCol = $this->_ds->_translateColumnName('lockId');
	$readEntityIdCol = $this->_ds->_translateColumnName('readEntityId');
	$freshUntilCol = $this->_ds->_translateColumnName('freshUntil');
	$freshUntil = time() + 30;
	foreach ($entityIds as $entityId) {
	    $query = sprintf('INSERT INTO %s (%s, %s, %s) VALUES (?, ?, ?)',
			     $lockTable, $lockIdCol, $readEntityIdCol, $freshUntilCol);
	    $data = array($lockId, $entityId, $freshUntil);

	    $this->_ds->_traceStart();
	    $recordSet = $db->Execute($query, $data);
	    $this->_ds->_traceStop();
	    if (!$recordSet) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	    }
	}

	/* Drop the lock request, now that we've got the write locks */
	$requestCol = $this->_ds->_translateColumnName('request');
	$query = 'DELETE FROM ' . $lockTable . ' ' .
		'WHERE ' . $lockIdCol . '=? AND ' . $requestCol . '=1';
	$data = array($lockId);

	$this->_ds->_traceStart();
	$recordSet = $db->Execute($query, $data);
	$this->_ds->_traceStop();
	if (!$recordSet) {
	    $this->_releaseLockById($lockId);
	    return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	}

	return array(GalleryStatus::success(),
		     array($lockId, array('type' => LOCK_READ, 'ids' => $entityIds)));
    }

    /**
     * @see GalleryStorage::acquireWriteLock
     */
    function acquireWriteLock($entityIds, $timeout) {
	/* It's ok to pass in a single id */
	if (!is_array($entityIds)) {
	    $entityIds = array($entityIds);
	}

	/* Acquire a non-transactional connection to use for this request */
	list ($ret, $db) = $this->_getNonTransactionalDatabaseConnection();
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	/* Know when to call it quits */
	$cutoffTime = time() + $timeout;

	/* Get the true name of the lock table */
	list ($lockTable, $unused) = $this->_ds->_translateTableName('Lock');

	/*
	 * Algorithm:
	 * 1. Get clearance to acquire locks (and get the lock id)
	 * 2. If any of the entities that we want to lock are currently locked,
	 *    then clear the request and go back to step 1.
	 * 3. Acquire our write locks
	 */
	while (true) {
	    list($ret, $lockId) = $this->_getLockClearance($cutoffTime);
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }

	    /*
	     * Check to see if any of the ids that we care about are locked.
	     */
	    $readEntityIdCol = $this->_ds->_translateColumnName('readEntityId');
	    $writeEntityIdCol = $this->_ds->_translateColumnName('writeEntityId');
	    $markers = GalleryUtilities::makeMarkers(sizeof($entityIds));
	    $query = 'SELECT COUNT(*) FROM ' . $lockTable . ' ' .
		    'WHERE ' . $readEntityIdCol . ' IN (' . $markers . ') ' .
		    'OR ' . $writeEntityIdCol . ' IN (' . $markers . ')';
	    $data = $entityIds;
	    $data = array_merge($data, $entityIds);

	    $GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;

	    $this->_ds->_traceStart();
	    $recordSet = $db->Execute($query, $data);
	    $this->_ds->_traceStop();
	    if (!$recordSet) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	    }

	    $row = $recordSet->FetchRow();
	    if ($row[0] == 0 ) {
		/* Success */
		break;
	    } else {
		/* An entity that we want is still locked */
		$this->_releaseLockById($lockId);

		if (time() > $cutoffTime) {
		    return array(GalleryStatus::error(ERROR_LOCK_TIMEOUT, __FILE__, __LINE__),
				 null);
		}

		/* Wait a second and try again */
		sleep(1);

		/* Expire any bogus locks */
		$ret = $this->_expireLocks();
		if ($ret->isError()) {
		    return array($ret->wrap(__FILE__, __LINE__), null);
		}
	    }
	}

	/*
	 * We are approved to acquire our write locks.
	 */
	$lockIdCol = $this->_ds->_translateColumnName('lockId');
	$writeEntityIdCol = $this->_ds->_translateColumnName('writeEntityId');
	$freshUntilCol = $this->_ds->_translateColumnName('freshUntil');
	$freshUntil = time() + 30;
	foreach ($entityIds as $entityId) {
	    $query = sprintf('INSERT INTO %s (%s, %s, %s) VALUES (?, ?, ?)',
			     $lockTable, $lockIdCol, $writeEntityIdCol, $freshUntilCol);
	    $data = array($lockId, $entityId, $freshUntil);

	    $this->_ds->_traceStart();
	    $recordSet = $db->Execute($query, $data);
	    $this->_ds->_traceStop();
	    if (!$recordSet) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	    }
	}

	/* Drop the lock request, now that we've got the write locks */
	$requestCol = $this->_ds->_translateColumnName('request');
	$query = 'DELETE FROM ' . $lockTable . ' ' .
		'WHERE ' . $lockIdCol . '=? AND ' . $requestCol . '=1';
	$data = array($lockId);

	$this->_ds->_traceStart();
	$recordSet = $db->Execute($query, $data);
	$this->_ds->_traceStop();
	if (!$recordSet) {
	    $this->_releaseLockById($lockId);
	    return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	}

	return array(GalleryStatus::success(),
		     array($lockId, array('type' => LOCK_WRITE, 'ids' => $entityIds)));
    }

    /**
     * @see GalleryStorage::refreshLocks
     */
    function refreshLocks($lockIds, $freshUntil) {
	if (!empty($lockIds)) {
	    /* Acquire a non-transactional connection to use for this request */
	    list ($ret, $db) = $this->_getNonTransactionalDatabaseConnection();
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }

	    list ($lockTable, $unused) = $this->_ds->_translateTableName('Lock');
	    $lockIdCol = $this->_ds->_translateColumnName('lockId');
	    $freshUntilCol = $this->_ds->_translateColumnName('freshUntil');
	    $lockIdMarkers = GalleryUtilities::makeMarkers(sizeof($lockIds));
	    $query = sprintf('UPDATE %s SET %s = ? WHERE %s in (%s)',
			     $lockTable, $freshUntilCol, $lockIdCol, $lockIdMarkers);

	    $this->_ds->_traceStart();
	    $data = array_merge(array($freshUntil), $lockIds);
	    $recordSet = $db->Execute($query, $data);
	    $this->_ds->_traceStop();

	    if (!$recordSet) {
		return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	    }
	}

	return GalleryStatus::success();
    }

    /**
     * Delete all not-so-fresh locks.
     *
     * @return object GalleryStatus a status code
     * @static
     */
    function _expireLocks() {
	/* Acquire a non-transactional connection to use for this request */
	list ($ret, $db) = $this->_getNonTransactionalDatabaseConnection();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	list ($lockTable, $unused) = $this->_ds->_translateTableName('Lock');
	$freshUntilCol = $this->_ds->_translateColumnName('freshUntil');
	$query = sprintf('DELETE FROM %s WHERE %s < ?',
			 $lockTable, $freshUntilCol);

	$this->_ds->_traceStart();
	$recordSet = $db->Execute($query, array(time()));
	$this->_ds->_traceStop();

	if (!$recordSet) {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * @see GalleryStorage::releaseLocks
     */
    function releaseLocks($lockIds) {
	$ret = $this->_releaseLockById($lockIds);
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * Internal function to release a lock by id.  Outsiders should use
     * releaseLock()
     *
     * @access private
     * @param mixed the lock id, or an array of lock ids
     * @return object GalleryStatus a status code
     */
    function _releaseLockById($lockIds) {
	if (!is_array($lockIds)) {
	    $lockIds = array($lockIds);
	}

	/* Acquire a non-transactional connection to use for this request */
	list ($ret, $db) = $this->_getNonTransactionalDatabaseConnection();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	/* Get the true name of the lock table */
	list ($lockTable, $unused) = $this->_ds->_translateTableName('Lock');

	$lockIdCol = $this->_ds->_translateColumnName('lockId');
	$markers = GalleryUtilities::makeMarkers(sizeof($lockIds));
	$query = 'DELETE FROM ' . $lockTable . ' ' .
		'WHERE ' . $lockIdCol . ' IN (' . $markers . ')';
	$data = $lockIds;

	$this->_ds->_traceStart();
	$recordSet = $db->Execute($query, $data);
	$this->_ds->_traceStop();
	if ($recordSet) {
	    return GalleryStatus::success();
	} else {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	}
    }

    /**
     * @see GalleryStorage::execute
     */
    function execute($statement, $data=array()) {
	if (empty($this->_ds->_db)) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__);
	}

	$ret = $this->_ds->_guaranteeTransaction();
	if ($ret->isError()) {
	    return $ret;
	}

	$statement = $this->_ds->_translateQuery($statement);

	$this->_ds->_traceStart();
	$recordSet = $this->_ds->_db->Execute($statement, $data);
	$this->_ds->_traceStop();

	if ($recordSet) {
	    return GalleryStatus::success();
	} else {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	}
    }

    /**
     * @see GalleryStorage::addMapEntry
     */
    function addMapEntry($mapName, $entry) {
	$ret = $this->_ds->_guaranteeTransaction();
	if ($ret->isError()) {
	    return $ret;
	}

	$mapInfo = $this->_ds->_describeMapMembers($mapName);
	list ($tableName, $unused) = $this->_ds->_translateTableName($mapName);
	$data = array();
	$columns = array();
	foreach ($mapInfo['members'] as $memberName => $memberType) {
	    $columns[] = $this->_ds->_translateColumnName($memberName);
	    $value = $entry[$memberName];

	    if ($memberType & STORAGE_TYPE_BIT) {
		$value = $this->_ds->convertIntToBits($value);
	    } else {
		if ($memberType & STORAGE_TYPE_TIMESTAMP) {
		    $value = $this->_ds->_db->DBTimeStamp($value);
		}
	    }

	    $data[] = $value;
	}

	$markers = GalleryUtilities::makeMarkers(sizeof($columns));
	$query = 'INSERT INTO ' . $tableName . ' (';
	$query .= join(', ', $columns);
	$query .= ') VALUES (' . $markers . ')';

	$this->_ds->_traceStart();
	$recordSet = $this->_ds->_db->Execute($query, $data);
	$this->_ds->_traceStop();
	if ($recordSet === false) {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * @see GalleryStorage::removeMapEntry
     */
    function removeMapEntry($mapName, $entry) {
	global $gallery;

	$ret = $this->_ds->_guaranteeTransaction();
	if ($ret->isError()) {
	    return $ret;
	}

	$mapInfo = $this->_ds->_describeMapMembers($mapName);
	list ($tableName, $unused) = $this->_ds->_translateTableName($mapName);
	$data = array();
	$where = array();
	foreach ($mapInfo['members'] as $memberName => $memberType) {
	    if (isset($entry[$memberName])) {
		if (is_array($entry[$memberName])) {
		    $qs = array();
		    foreach ($entry[$memberName] as $value) {
			$qs[] = '?';
			$data[] = $value;
		    }
		    $where[] = $this->_ds->_translateColumnName($memberName) . ' IN ('
			     . implode(',', $qs) . ')';
		} else {
		    $where[] = $this->_ds->_translateColumnName($memberName) . '=?';
		    $data[] = $entry[$memberName];
		}
	    }
	}

	if (empty($where)) {
	    return GalleryStatus::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__,
					'Missing where clause');
	}

	$query = 'DELETE FROM ' . $tableName . ' ';
	$query .= 'WHERE '  . join(' AND ', $where);

	$this->_ds->_traceStart();
	$recordSet = $this->_ds->_db->Execute($query, $data);
	$this->_ds->_traceStop();
	if (!$recordSet) {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * @see GalleryStorage::removeAllMapEntries
     */
    function removeAllMapEntries($mapName) {
	list ($tableName, $unused) = $this->_ds->_translateTableName($mapName);
	$query = 'DELETE FROM ' . $tableName;

	$ret = $this->_ds->_guaranteeTransaction();
	if ($ret->isError()) {
	    return $ret;
	}

	$this->_ds->_traceStart();
	$recordSet = $this->_ds->_db->Execute($query);
	$this->_ds->_traceStop();
	if ($recordSet === false) {
	    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /*
     * Load up the table creation and alteration SQL files for the given module
     * @access private
     */
    function _getModuleSql($moduleId) {
	global $gallery;

	$platform = $gallery->getPlatform();
	$sqlFile = dirname(__FILE__) . '/../../../../modules/' . $moduleId .
	    '/classes/GalleryStorage/DatabaseStorage/schema/schema.tpl';

	if ($platform->file_exists($sqlFile)) {
	    $sqlData = explode("\n", $platform->file_get_contents($sqlFile));
	    $moduleSql = $this->_parseSqlTemplate($sqlData);
	} else {
	    /* Stop supporting this on the next major core api change */
	    list ($ret, $moduleSql) = $this->_loadOldStyleSqlFiles($moduleId);
	    if ($ret->isError()) {
		return array(GalleryStatus::success(), array());
	    }
	}

	return array(GalleryStatus::success(), $moduleSql);
    }

    /**
     * Old style of SQL files.  Deprecated; should be removed on the next core api bump.
     */
    function _loadOldStyleSqlFiles($moduleId) {
	global $gallery;

	$info = array('table' => array(), 'alter' => array(),
		      'remove' => array(), 'test' => array());
	$platform = $gallery->getPlatform();
	$sqlDir = dirname(__FILE__) . '/../../../../modules/' . $moduleId .
	    '/classes/GalleryStorage/DatabaseStorage/schema/platform/' .
	    $this->_ds->getType();
	if (!$platform->file_exists($sqlDir)) {
	    return array(GalleryStatus::success(), $info);
	}

	$results = array('## ' . $this->_ds->getType());
 	if ($dir = $platform->opendir($sqlDir)) {
 	    while (($file = $platform->readdir($dir)) !== false) {
 		/*
 		 * There are three classes of files here, distinguished by name.
 		 *   "Foo.sql" -- the definition for table "Foo"
 		 *   "A_Foo_1.0.sql" -- an alteration to upgrade the 1.0 version of
 		 *                      table "Foo" to the current version
 		 *   "R_Foo_1.0.sql" -- delete table Foo.sql if it's currently at version 1.0
 		 *   "T_Foo.sql"     -- test sql, used by the installer.
 		 *
 		 * We need to parse these file names and group them together
 		 * such that once we figure out what version of the Foo table
 		 * we have in the database we can figure out which file to
 		 * apply to install/update it.
 		 * In earlier versions (beta 3) we used the format R_Foo_1_0.sql), an underscore
 		 * instead of a dot as the version separator. If a user has still these old files
 		 * in his gallery2 dirs, they would be executed on each upgrade unless we accept
 		 * here the old 1_0 and the new 1.0 format.
 		 */
 		if (preg_match('/^([ART])_(.*)_(\d+)[\._](\d+)\.sql$/', $file, $matches)) {
 		    if ($matches[1] == 'R') {
 			$info['remove'][$matches[2]][$matches[3]][$matches[4]] =
			    $platform->file_get_contents($sqlDir . '/' . $file);
  		    } else if ($matches[1] == 'A') {
 			$info['alter'][$matches[2]][$matches[3]][$matches[4]] =
			    $platform->file_get_contents($sqlDir . '/' . $file);
  		    } else {
 			$info['test'][$matches[2]][$matches[3]][$matches[4]] =
			    $platform->file_get_contents($sqlDir . '/' . $file);
		    }
 		} else if (preg_match('/^(.*)\.sql$/', $file, $matches)) {
 		    if (!preg_match('/^T_/', $file)) {
 			$info['table'][$matches[1]] =
			    $platform->file_get_contents($sqlDir . '/' . $file);
  		    }
  		}
  	    }
 	    $platform->closedir($dir);
  	} else {
 	    return array(GalleryStatus::error(ERROR_BAD_PATH, __FILE__, __LINE__), array());
  	}

	return array(GalleryStatus::success(), $info);
    }

    /**
     * Parse the SQL template file and break it down by database and sql file type and return the
     * results in an array.  The best way to see how this is supposed to work is to look in the
     * unit test.
     *
     * @param array the raw template data
     * @param array the parsed results
     */
    function _parseSqlTemplate($sqlData) {
	$info = array('table' => array(), 'alter' => array(),
		      'remove' => array(), 'test' => array());
	$dbname = null;
	$tablename = null;
	$record = false;
	foreach ($sqlData as $line) {
	    if (preg_match('/^## (.*)$/', $line, $matches)) {
		if ($matches[1] == $this->_ds->getType()) {
		    $record = true;
		} else {
		    $record = false;
		}
		continue;
	    }
	    if (!$record) {
		continue;
	    }

	    /**
	     * In earlier versions (beta 3) we used the format R_Foo_1_0.sql), an underscore
	     * instead of a dot as the version separator. If a user has still these old files
	     * in his gallery2 dirs, they would be executed on each upgrade unless we accept
	     * here the old 1_0 and the new 1.0 format.
	     */
	    if (preg_match('/^# (.*)$/', $line, $matches)) {
		$tablename = $matches[1];
		if (preg_match('/^T_(.*)_(\d+)/', $tablename, $matches)) {
		    if (!isset($info['test'][$matches[1]][$matches[2]])) {
			$info['test'][$matches[1]][$matches[2]] = '';
		    }
		    $insertPointer =& $info['test'][$matches[1]][$matches[2]];
		} else if (preg_match('/^A_(.*)_(\d+)[\._](\d+)/', $tablename, $matches)) {
		    if (!isset($info['alter'][$matches[1]][$matches[2]][$matches[3]])) {
			$info['alter'][$matches[1]][$matches[2]][$matches[3]] = '';
		    }
		    $insertPointer =& $info['alter'][$matches[1]][$matches[2]][$matches[3]];
		} else if (preg_match('/^R_(.*)_(\d+)[\._](\d+)/', $tablename, $matches)) {
		    if (!isset($info['remove'][$matches[1]][$matches[2]][$matches[3]])) {
			$info['remove'][$matches[1]][$matches[2]][$matches[3]] = '';
		    }
		    $insertPointer =& $info['remove'][$matches[1]][$matches[2]][$matches[3]];
		} else {
		    if (!isset($info['table'][$tablename])) {
			$info['table'][$tablename] = '';
		    }
		    $insertPointer =& $info['table'][$tablename];
		}
		continue;
	    }
	    if (!empty($insertPointer)) {
		$insertPointer .= "\n";
	    }
	    $insertPointer .= $line;
	}

	return $info;
    }

    /**
     * @see GalleryStorage::configureStore
     */
    function configureStore($moduleId) {
	global $gallery;
	$gallery->guaranteeTimeLimit(20);

	if (empty($this->_ds->_db)) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__);
	}

	$ret = $this->_ds->_guaranteeTransaction();
	if ($ret->isError()) {
	    return $ret;
	}

	list ($ret, $moduleSql) = $this->_getModuleSql($moduleId);
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	/* Get the metabase info about this database */
	$this->_ds->_traceStart();
	$metatables = $this->_ds->_db->MetaTables();
	$this->_ds->_traceStop();

	/*
	 * Some databases (notably MySQL on Win32) don't support mixed case
	 * table names.  So, when we get the meta table list back, it's lower
	 * case.  Force all metatable listings to lower case and then expect
	 * them to be lowercase so that we're consistent.
	 */
	for ($i = 0; $i < sizeof($metatables); $i++) {
	    $metatables[$i] = strtolower($metatables[$i]);
	}

	/* Do the schema table first */
	list ($schemaTableName, $unused) = $this->_ds->_translateTableName('Schema');
	if (!in_array(strtolower($schemaTableName), $metatables)) {
	    $ret = $this->_executeSql($moduleSql['table']['Schema']);
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	    unset($moduleSql['table']['Schema']);

	    /* Create our sequences now */
	    foreach (array(DATABASE_SEQUENCE_LOCK, DATABASE_SEQUENCE_ID) as $sequenceId) {
		$this->_ds->_traceStart();
		$recordSet = $this->_ds->_db->CreateSequence($this->_ds->_tablePrefix . $sequenceId);
		$this->_ds->_traceStop();
		if (empty($recordSet)) {
		    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
		}
	    }
	}

	/* Load all table versions */
	list ($ret, $tableVersions) = $this->_loadTableVersions();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	/*
	 * Now take care of the rest of the tables.  If the table doesn't
	 * exist, apply the current table definition.  If it already exists,
	 * check to see if there is an upgrade available for the given table
	 * version.  If so, apply it.
	 */
	foreach ($moduleSql['table'] as $rawTableName => $sql) {
	    $gallery->guaranteeTimeLimit(20);
	    list ($tableName, $unused, $tableNameInSchema) =
		$this->_ds->_translateTableName($rawTableName);
	    if (!in_array(strtolower($tableName), $metatables)) {
		$ret = $this->_executeSql($sql);
		if ($ret->isError()) {
		    return $ret->wrap(__FILE__, __LINE__);
		}
	    } else {
		while (1) {
		    /* The table exists -- see if we have an upgrade for it */
		    if (empty($tableVersions[$tableNameInSchema])) {
			/*
			 * We've found a SQL file that matches a table in the
			 * database, but has no matching version info in the
			 * schema table.  How can this be?  Leave it alone.
			 */
			if ($gallery->getDebug()) {
			    $gallery->debug("Table $rawTableName: missing entry in Schema table");
			}
			break;
		    }

		    /* If we locate an appropriate upgrade, apply it. */
		    list ($major,  $minor) = $tableVersions[$tableNameInSchema];
		    if (!empty($moduleSql['alter'][$rawTableName][$major][$minor])) {
			$sql = $moduleSql['alter'][$rawTableName][$major][$minor];
			$ret = $this->_executeSql($sql);
			if ($ret->isError()) {
			    return $ret->wrap(__FILE__, __LINE__);
			}

			/* Reload all table versions, cause one has now changed */
			list ($ret, $tableVersions) = $this->_loadTableVersions();
			if ($ret->isError()) {
			    return $ret->wrap(__FILE__, __LINE__);
			}
		    } else {
			/* No upgrade available */
			break;
		    }
		}
	    }
	}

	return GalleryStatus::success();
    }

    /**
     * @see GalleryStorage::configureStoreCleanup
     */
    function configureStoreCleanup($moduleId) {
	global $gallery;

	if (empty($this->_ds->_db)) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__);
	}

	$ret = $this->_ds->_guaranteeTransaction();
	if ($ret->isError()) {
	    return $ret;
	}

	list ($ret, $moduleSql) = $this->_getModuleSql($moduleId);
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	/* Get the metabase info about this database */
	$this->_ds->_traceStart();
	$metatables = $this->_ds->_db->MetaTables();
	$this->_ds->_traceStop();

	/*
	 * Some databases (notably MySQL on Win32) don't support mixed case
	 * table names.  So, when we get the meta table list back, it's lower
	 * case.  Force all metatable listings to lower case and then expect
	 * them to be lowercase so that we're consistent.
	 */
	for ($i = 0; $i < sizeof($metatables); $i++) {
	    $metatables[$i] = strtolower($metatables[$i]);
	}

	/* Load all table versions */
	list ($ret, $tableVersions) = $this->_loadTableVersions();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	/* Now locate any existing tables that should be deleted and drop them. */
	foreach (array_keys($moduleSql['remove']) as $rawTableName) {
	    if ($rawTableName == 'Schema') {
		continue;
	    }

	    list ($tableName, $unused, $tableNameInSchema) =
		$this->_ds->_translateTableName($rawTableName);
	    if (in_array(strtolower($tableName), $metatables)) {
		/* The table exists -- see if we should delete it */
		if (empty($tableVersions[$tableNameInSchema])) {
		    /*
		     * We've found a SQL file that matches a table in the
		     * database, but has no matching version info in the
		     * schema table.  How can this be?  Leave it alone.
		     */
		    if ($gallery->getDebug()) {
			$gallery->debug("Table $rawTableName: missing entry in Schema table");
		    }
		} else {
		    $gallery->guaranteeTimeLimit(20);
		    list ($major,  $minor) = $tableVersions[$tableNameInSchema];
		    if (!empty($moduleSql['remove'][$rawTableName][$major][$minor])) {
			$ret = $this->_executeSql(
			    $moduleSql['remove'][$rawTableName][$major][$minor]);
			if ($ret->isError()) {
			    return $ret->wrap(__FILE__, __LINE__);
			}
		    }
		}
	    }
	}

	return GalleryStatus::success();
    }

    /**
     * @see GalleryStorage::unconfigureStore
     */
    function unconfigureStore($moduleId) {
	global $gallery;

	if (empty($this->_ds->_db)) {
	    return GalleryStatus::error(ERROR_STORAGE_CONNECTION, __FILE__, __LINE__);
	}

	$ret = $this->_ds->_guaranteeTransaction();
	if ($ret->isError()) {
	    return $ret;
	}

	list ($ret, $moduleSql) = $this->_getModuleSql($moduleId);
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	/* Get the metabase info about this database */
	$this->_ds->_traceStart();
	$metatables = $this->_ds->_db->MetaTables();
	$this->_ds->_traceStop();

	/*
	 * Some databases (notably MySQL on Win32) don't support mixed case
	 * table names.  So, when we get the meta table list back, it's lower
	 * case.  Force all metatable listings to lower case and then expect
	 * them to be lowercase so that we're consistent.
	 */
	for ($i = 0; $i < sizeof($metatables); $i++) {
	    $metatables[$i] = strtolower($metatables[$i]);
	}

	/*
	 * Now take care of the rest of the tables.  If the table doesn't
	 * exist, apply the current table definition.  If it already exists,
	 * check to see if there is an upgrade available for the given table
	 * version.  If so, apply it.
	 */
	list ($schemaTableName, $unused) = $this->_ds->_translateTableName('Schema');
	$schemaColumnName = $this->_ds->_translateColumnName('name');
	foreach ($moduleSql['table'] as $rawTableName => $ignored) {
	    /* Don't drop the schema table, it's part of the core. */
	    if ($rawTableName == 'Schema') {
		continue;
	    }

	    $this->_ds->_traceStart();
	    list ($tableName, $unused, $tableNameInSchema) =
		$this->_ds->_translateTableName($rawTableName);
	    if (in_array(strtolower($tableName), $metatables)) {
		/* Drop the table and yank it from the schema table */
		$dropQuery = sprintf('DROP TABLE %s', $tableName);
		$recordSet = $this->_ds->_db->Execute($dropQuery);
		if (empty($recordSet)) {
		    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
		}
	    }

	    $cleanQuery = sprintf('DELETE FROM %s where %s=?',
				  $schemaTableName, $schemaColumnName);
	    $recordSet = $this->_ds->_db->Execute($cleanQuery, array($tableNameInSchema));
	    if (empty($recordSet)) {
		return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
	    }
	    $this->_ds->_traceStop();
	}

	return GalleryStatus::success();
    }

    /**
     * Examine the schema table and return the version of all the Gallery tables
     *
     * @return array object GalleryStatus a status code
     *               array (name => (major, minor))
     */
    function _loadTableVersions() {
	global $gallery;

	$GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;

	$this->_ds->_traceStart();
	list ($schemaTableName, $unused) = $this->_ds->_translateTableName('Schema');
	$recordSet = $this->_ds->_db->Execute('SELECT ' .
					 $this->_ds->_translateColumnName('name') . ', ' .
					 $this->_ds->_translateColumnName('major') . ', ' .
					 $this->_ds->_translateColumnName('minor') .
					 ' FROM ' .
					 $schemaTableName);
	$this->_ds->_traceStop();

	if (empty($recordSet)) {
	    return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__,
					      'Error reading schema table'), null);
	}

	$tableVersions = array();
	while ($row = $recordSet->FetchRow()) {
	    $tableVersions[$row[0]] = array($row[1], $row[2]);
	}

	return array(GalleryStatus::success(), $tableVersions);
    }

    /**
     * Execute a given SQL against the database.  Prefix table and column
     * names as necessary.  Split multiple commands in the file into separate
     * Execute() calls.
     *
     * @return object GalleryStatus a status code
     */
    function _executeSql($buffer) {
	global $gallery;

	$ret = $this->_ds->_guaranteeTransaction();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	/*
	 * Split the file where semicolons are followed by a blank line..
	 * PL/SQL blocks will have other semicolons, so we can't split on every one.
	 */
	foreach (preg_split('/; *\r?\n *\r?\n/s', $buffer) as $query) {
	    $query = trim($query);
	    if (!empty($query)) {
		$query = str_replace('DB_TABLE_PREFIX', $this->_ds->_tablePrefix, $query);
		$query = str_replace('DB_COLUMN_PREFIX', $this->_ds->_columnPrefix, $query);

		/* Perform database specific replacements */
		foreach ($this->_ds->getSqlReplacements() as $key => $value) {
		    $query = str_replace($key, $value, $query);
		}

		$this->_ds->_traceStart();
		$recordSet = $this->_ds->_db->Execute($query);
		$this->_ds->_traceStop();
		if (empty($recordSet)) {
		    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__,
						"Error trying to run query: $query");
		}
	    }
	}

	return GalleryStatus::success();
    }

    /**
     * @see GalleryStorage::cleanStore
     */
    function cleanStore() {
	global $gallery;

	$ret = $this->_ds->_guaranteeTransaction();
	if ($ret->isError()) {
	    return $ret;
	}

	/* Get the metabase info about this database */
	$this->_ds->_traceStart();
	$metatables = $this->_ds->_db->MetaTables();
	$this->_ds->_traceStop();

	/*
	 * Some databases (notably MySQL on Win32) don't support mixed case
	 * table names.  So, when we get the meta table list back, it's lower
	 * case.  Force all metatable listings to lower case and then expect
	 * them to be lowercase so that we're consistent.
	 */
	for ($i = 0; $i < sizeof($metatables); $i++) {
	    $metatables[$i] = strtolower($metatables[$i]);
	}

	/* If the schema table exists then delete all the tables it lists */
	list ($schemaTableName, $unused) = $this->_ds->_translateTableName('Schema');
	if (in_array(strtolower($schemaTableName), $metatables)) {
	    /* Load all table versions */
	    list ($ret, $tableVersions) = $this->_loadTableVersions();
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }

	    foreach (array_keys($tableVersions) as $rawTableName) {
		list ($tableName, $unused) = $this->_ds->_translateTableName($rawTableName);
		$query = sprintf('DROP TABLE %s', $tableName);

		$this->_ds->_traceStart();
		$recordSet = $this->_ds->_db->Execute($query);
		$this->_ds->_traceStop();
		if (empty($recordSet)) {
		    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
		}
	    }

	    /* Get rid of our sequences */
	    foreach (array(DATABASE_SEQUENCE_LOCK, DATABASE_SEQUENCE_ID)
		     as $sequenceId) {

		$this->_ds->_traceStart();
		$recordSet = $this->_ds->_db->DropSequence($this->_ds->_tablePrefix . $sequenceId);
		$this->_ds->_traceStop();
		if (empty($recordSet)) {
		    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
		}
	    }
	}

	return GalleryStatus::success();
    }

    /**
     * @see GalleryStorage::getProfilingHtml
     */
    function getProfilingHtml() {
	$this->_ds->_traceStart();
	 $perf =& NewPerfMonitor($this->_ds->_db);
	 $buf = $perf->SuspiciousSQL();
	 $buf .= $perf->ExpensiveSQL();
	$this->_ds->_traceStop();
	 return $buf;
    }

    /**
     * @see GalleryStorage::isInstalled
     */
    function isInstalled() {
	/* Get the metabase info about this database */
	$this->_ds->_traceStart();
	$metatables = $this->_ds->_db->MetaTables();
	$this->_ds->_traceStop();

	list ($schemaTableName, $unused) = $this->_ds->_translateTableName('Schema');
	$isInstalled = preg_match("/\b$schemaTableName\b/i", join(' ', $metatables));
	return array(GalleryStatus::success(), $isInstalled);
    }

    /**
     * Optimize the back end.
     *
     * @return object GalleryStatus a status code
     */
    function optimize() {
	/* Load all table versions */
	list ($ret, $tableVersions) = $this->_loadTableVersions();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	$statement = $this->_ds->getOptimizeStatement();
	if (!empty($statement)) {
	    foreach (array_keys($tableVersions) as $tableName) {
		$query = sprintf($statement, $this->_ds->_tablePrefix . $tableName);
		$this->_ds->_traceStart();
		$recordSet = $this->_ds->_db->Execute($query);
		$this->_ds->_traceStop();

		if (!$recordSet) {
		    return GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__);
		}
	    }
	}

	return GalleryStatus::success();
    }

    /**
     * Internal function to get clearance to acquire locks
     *
     * Request clearance to acquire locks and then wait until it's our turn.
     *
     * @param int the time to stop trying to get clearance
     * @return object GalleryStatus a status code
     */
    function _getLockClearance($cutoffTime) {
	/* Get the true name of the lock table */
	list ($lockTable, $unused) = $this->_ds->_translateTableName('Lock');

	/* Acquire a non-transactional connection to use for this request */
	list ($ret, $db) = $this->_getNonTransactionalDatabaseConnection();
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	/* Get a new lock id */
	$this->_ds->_traceStart();
	$lockId = $db->GenId($this->_ds->_tablePrefix . DATABASE_SEQUENCE_LOCK);
	$this->_ds->_traceStop();

	/* Put in a lock request */
	$lockIdCol = $this->_ds->_translateColumnName('lockId');
	$requestCol = $this->_ds->_translateColumnName('request');
	$freshUntilCol = $this->_ds->_translateColumnName('freshUntil');
	$query = sprintf('INSERT INTO %s (%s, %s, %s) VALUES(?, 1, ?)',
			 $lockTable, $lockIdCol, $requestCol, $freshUntilCol);
	$data = array($lockId, time() + 30);

	$this->_ds->_traceStart();
	$recordSet = $db->Execute($query, $data);
	$this->_ds->_traceStop();
	if (!$recordSet) {
	    $this->_releaseLockById($lockId);
	    return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	}

	/* Wait till it's our turn */
	while (true) {
	    $query = 'SELECT ' . $lockIdCol . ' FROM ' . $lockTable . ' ' .
		    'WHERE ' . $requestCol . '=1 ORDER BY ' .
		    $lockIdCol . ' ASC';

	    $GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;
	    $this->_ds->_traceStart();
	    $recordSet = $db->SelectLimit($query, 1);
	    $this->_ds->_traceStop();
	    if (!$recordSet) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	    }

	    $row = $recordSet->FetchRow();
	    if ($row[0] == $lockId) {
		break;
	    }

	    /* Wait a second and try again */
	    sleep(1);

	    /* Expire any bogus locks */
	    $ret = $this->_expireLocks();
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }

	    if (time() > $cutoffTime) {
		$this->_releaseLockById($lockId);
		return array(GalleryStatus::error(ERROR_LOCK_TIMEOUT, __FILE__, __LINE__), null);
	    }
	}

	return array(GalleryStatus::success(), $lockId);
    }

    /**
     * Identify the type of entity associated with the id provided
     *
     * @param int a object id
     * @return array a GalleryStatus and a string class name
     */
    function _identifyEntities($ids) {
	assert('!empty($ids)');

	if (!is_array($ids)) {
	    $ids = array($ids);
	    $returnArray = false;
	} else {
	    $returnArray = true;
	}

	$checkIds = array();
	foreach ($ids as $id) {
	    if (!GalleryDataCache::containsKey("DatabaseStorage::_identifyEntities($id)")) {
		$checkIds[] = $id;
	    }
	}

	$local = array();
	if (!empty($checkIds)) {
	    $idCol = $this->_ds->_translateColumnName('id');
	    $entityTypeCol = $this->_ds->_translateColumnName('entityType');
	    list ($table, $unused) = $this->_ds->_translateTableName('GalleryEntity');
	    $markers = GalleryUtilities::makeMarkers(sizeof($checkIds));
	    $query = 'SELECT ' . $idCol . ', ' . $entityTypeCol .
		    ' FROM ' . $table .
		    ' WHERE ' . $idCol . ' IN (' . $markers . ')';

	    $GLOBALS['ADODB_FETCH_MODE'] = ADODB_FETCH_NUM;

	    $this->_ds->_traceStart();
	    $recordSet = $this->_ds->_db->Execute($query, $checkIds);
	    $this->_ds->_traceStop();

	    if ($recordSet) {
		while ($row = $recordSet->FetchRow()) {
		    if (empty($row[1])) {
			return array(GalleryStatus::error(ERROR_MISSING_OBJECT, __FILE__, __LINE__),
				     null);
		    } else {
			/*
			 * Save a copy locally, in case the global cache is disabled
			 * (like in the upgrader)
			 */
			$local[$row[0]] = $row[1];
			GalleryDataCache::put("DatabaseStorage::_identifyEntities($row[0])",
					      $row[1], true);
		    }
		}
	    } else {
		return array(GalleryStatus::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__), null);
	    }
	}

	if ($returnArray) {
	    $results = array();
	    foreach ($ids as $id) {
		if (isset($local[$id])) {
		    $results[] = $local[$id];
		} else if (GalleryDataCache::containsKey(
			       "DatabaseStorage::_identifyEntities($id)")) {
		    $results[] = GalleryDataCache::get("DatabaseStorage::_identifyEntities($id)");
		} else {
		    return array(GalleryStatus::error(ERROR_MISSING_OBJECT, __FILE__, __LINE__,
						      "Missing object for $id"), null);
		}
	    }
	} else {
	    $results = GalleryDataCache::get("DatabaseStorage::_identifyEntities($ids[0])");
	}

	return array(GalleryStatus::success(), $results);
    }
}
?>
