<?php
/*
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2007 Bharat Mediratta
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA  02110-1301, USA.
 */
/* This class is extensively based on the adodb-sxmlschema03 class developed by Richard Tango-Lowy &
 * Dan Cech, Released under both BSD license and Lesser GPL library license.  Whenever there is any
 * discrepancy between the two licenses, the BSD license will take precedence.  The orignal class
 * was copyright: Copyright (c) 2004-2005 ars Cognita Inc., all rights reserved.
 */

GalleryCoreApi::requireOnce('modules/core/classes/GalleryTheme.class');

/**
 * Current Schema Version
 */
if (!defined('EXPORT_SCHEMA_VERSION')) {
    define('EXPORT_SCHEMA_VERSION', '1.0');
}

/**
 * GalleryDatabaseExport provides the functionality to export the Gallery database.
 * @package GalleryCore
 * @subpackage Storage
 * @author Tim Almdal <tnalmdal@shaw.ca>
 * @version $Revision$
 */
class GalleryDatabaseImport extends GalleryImportObject {
    /**
     * Defines the number of bytes to read before letting the user know that we haven't forgotten
     * them.
     */
    var $_fileReadChunkSize = 8192;

    function GalleryDatabaseImport() {
	parent::GalleryImportObject();
    }

    /**
     * This method prescans the exported Gallery database before doing an upload
     * @param string $fileName Filename to be imported.
     * @return array List of error messages and warning messages generated by status check.  Errors
     *      are contained in the key 'errors' and the warnings are contained in the key 'warnings'.
     */
    function verifyVersions($fileName) {
	global $gallery;

	$parseString = '#<plugin-status\s+id="(.*?)"\s+required-core-api="(.*?)"\s+required-api="'
			. '(.*?)"\s+version="(.*?)"\s+active="(1|0)"\s+type="(module|theme)"#';

	$platform =& $gallery->getPlatform();

	$errors = array('errors' => array(), 'warnings' => array());

	$this->_installedModuleVersion = GalleryModule::getApiVersion();
	$this->_installedCoreVersion = GalleryCoreApi::getApiVersion();
	$this->_installedThemeVersion = GalleryTheme::getApiVersion();

	list ($ret, $coreModule) = GalleryCoreApi::loadPlugin('module', 'core', true);
	if ($ret) {
	    $errors['errors'][] = $ret->getAsHtml();
	    return $errors;
	}

	if (!function_exists('xml_parse')) {
	    $errors['errors'][] = $coreModule->translate('Unable to find the XML parser.  The PHP'
			. ' XML parsing extension must be loaded.  Terminating database import.');
	} else {
	    if ($platform->file_exists($fileName)) {
		$handle = $platform->fopen($fileName, 'r');
		if ($handle) {
		    while (!$platform->feof($handle)) {
			$line = rtrim($platform->fgets($handle, 4096));
			$versions = array();
			if (preg_match('#<export schema-version="(.*?)"#', $line, $versions)) {
			    if (EXPORT_SCHEMA_VERSION != $versions[1]) {
				$errors['errors'][] = $coreModule->translate(
				    array('text' => 'The exported file is not the correct '
							. 'version. Expecting %s recieved %s.',
					  'arg1' => EXPORT_SCHEMA_VERSION, 'arg2' => $versions[1]));
			    }
			    continue;
			}
			if (strpos($line, '</plugin-status-list>') !== false) {
			    break;
			}
			/* Find the module definition lines. */
			if (preg_match($parseString, $line, $versions)) {
		    	    $this->_doStatusCheck($versions, $errors);
			}
		    }
		    if (!$platform->fclose($handle)) {
			$errors['errors'][] =
			    $coreModule->translate(array('text' => 'Unable to close import file: '
								   . '%s', 'arg1' => $fileName));
		    }
		} else {
		    $errors['errors'][] =
			$coreModule->translate(array('text' => 'Unable to open import file: %s',
						     'arg1' => $fileName));
		}
	    } else {
		$errors['errors'][] =
		    $coreModule->translate(array('text' => 'Import file doesn\'t exist: %s',
						 'arg1' => $fileName));
	    }
	}

	return $errors;
    }

    /**
     * Do the version validation prior actually reloading the Gallery installation
     * @param array $versions The plugin status as extracted from the <plugin-status> tag.
     * 				$versions[1] - The plugin id
     * 				$versions[2] - Required Core Api
     * 				$versions[3] - Require Api (Module or Theme)
     * 				$versions[4] - Plugin Version number
     * 				$versions[5] - The plugin active flag.
     * 				$versions[6] - The plugin type module | theme.
     * @param array A keyed array for errors and warnings. Keys are 'errors' and 'warnings'.
     */
    function _doStatusCheck($versions, &$errors) {
    	$pluginType = $versions[6];
	list ($ret, $pluginStatus) = GalleryCoreApi::fetchPluginStatus($pluginType);
	if ($ret) {
	    $errors['errors'][] = $ret->getAsHtml();
	    return;
	}

	list ($ret, $coreModule) = GalleryCoreApi::loadPlugin('module', 'core', true);
	if ($ret) {
	    $errors['errors'][] = $ret->getAsHtml();
	    return;
	}

	if (!isset($pluginStatus[$versions[1]])) {
	    $errors['warnings'][] =
		$coreModule->translate(array('text' => 'Plugin %s is not currently available.',
					     'arg1' => $versions[1]));
	    return;
	}

	list ($ret, $plugin) = GalleryCoreApi::loadPlugin($pluginType, $versions[1], true);
	if ($ret) {
	    $errors['errors'][] = $ret->getAsHtml();
	    return;
	}

	$availableVersion =  $plugin->getVersion();
	if ($availableVersion < $versions[4]) {
	    $errors['errors'][] =
		$coreModule->translate(array('text' => 'The available version of plugin "%s" may '
			 . 'not be compatible with the imported version.', 'arg1' => $versions[1]));
	}

	$importVersion = array_map('intval', explode('.', $versions[2]));
	if (!GalleryUtilities::isCompatibleWithApi($importVersion, $this->_installedCoreVersion)) {
	    $errors['warnings'][] =
		$coreModule->translate(array('text' => 'The currently installed core API version '
			      . 'required by "%s" may not be compatible with the imported version.',
			      'arg1' => $versions[1]));
	}

	$importVersion = array_map('intval', explode('.', $versions[3]));
	if ($pluginType == 'module') {
	    if (!GalleryUtilities::isCompatibleWithApi($importVersion,
						       $this->_installedModuleVersion)) {
		$errors['warnings'][] =
		    $coreModule->translate(array('text' => 'The installed module API version'
		    	 . ' required by "%s" may not be compatible with the imported version.',
		    		'arg1' => $versions[1]));
	    }
	} else {
	    if (!GalleryUtilities::isCompatibleWithApi($importVersion,
						       $this->_installedThemeVersion)) {
		$errors['warnings'][] =
		    $coreModule->translate(array('text' => 'The installed theme API version '
				. 'required by "%s" is not compatible with the imported version.',
		    		'arg1' => $versions[1]));;
	    }
	}
    }

    /**
     * Imports a file in Gallery export format.
     *
     * This method will load an XML file, in the Gallery export format to the data base.  It will
     * restore the config.ini file and reset the versions.dat file.
     * @param string $fileName Name of the file containing file database backup to restore.
     * @param string $progressCallback Name of the routine to return call with progress reports
     * @return array object GalleryStatus
     *               array Array of GalleryStatus's containing errors encountered or null on success
     */
    function importToDb($fileName, $progressCallback) {
	global $gallery;
	$platform =& $gallery->getPlatform();

	/* Preallocate at least 1 minutes for the database import. */
	$gallery->guaranteeTimeLimit(60);

	$this->_callBack = array('progress' => 0, 'total' => 0, 'callBack' => $progressCallback);

	if ($platform->file_exists($fileName)) {
	    $fileSize = $platform->filesize($fileName);
	    $this->_callBack['total'] = ceil($fileSize / $this->_fileReadChunkSize);

	    /* Open the file */
	    if (!($handle = $platform->fopen($fileName, 'r'))) {
		return array(GalleryCoreApi::error(ERROR_BAD_PATH, __FILE__, __LINE__,
						 'Unable to open the backup file for input'), null);
	    }

	    $xmlParser = $this->_createParser();

	    /* Process the file until complete or errors occur. */
	    while (empty($this->_errors)
	    	   && $data = $platform->fread($handle, $this->_fileReadChunkSize)) {
	    	/*
	    	 * When the file was exported, the data and fields were encoded to remove any
	    	 * significant HTML characters (i.e $, <, >, ").  There is no special handling
	    	 * in our import process, as we are relying on the PHP xml parser to decode these
	    	 * special characters.
	    	 */
		if (!xml_parse($xmlParser, $data, $platform->feof($handle))) {
		    return array(GalleryCoreApi::error(ERROR_STORAGE_FAILURE, __FILE__, __LINE__,
					sprintf('XML error: %s at line %d',
						xml_error_string(xml_get_error_code($xmlParser)),
						xml_get_current_line_number($xmlParser))), null);
		}
		$this->updateStatus();
	    }

	    xml_parser_free($xmlParser);

	    call_user_func_array($progressCallback, array(1.0));
	} else {
	    return array(GalleryCoreApi::error(ERROR_BAD_PATH, __FILE__, __LINE__,
					       'Import file doesn\'t exist: ' . $fileName), null);
	}

	return array(null, empty($this->_errors) ? null : $this->_errors);
    }

    /**
     * Create an xml parser
     * @return object PHP XML parser object
     * @access private
     */
    function &_createParser() {
	$xmlParser = xml_parser_create('UTF-8');
	xml_set_object($xmlParser, $this);

	/* Initialize the XML callback functions */
	xml_set_element_handler($xmlParser, '_tagOpen', '_tagClose');
	xml_set_character_data_handler($xmlParser, '_tagCdata');

	return $xmlParser;
    }

    /**
     * XML Callback to process start elements
     * @access private
     */
    function _tagOpen(&$parser, $tag, $attributes) {
	switch ($tag) {
	    case 'EXPORT':
		$this->writeVersions($attributes['CORE-VERSION'], $attributes['GALLERY-VERSION']);
		$this->_callBack['total'] += $attributes['TABLES'];
		break;
	    case 'CONFIG':
		xml_set_object($parser, new GalleryConfigImport($this, $attributes));
		break;
	    case 'PLUGIN':
		xml_set_object($parser, new GalleryPluginImport($this, $attributes));
		break;
	}
    }

    /**
     * XML Callback to process CDATA elements
     * @access private
     */
    function _tagCdata(&$parser, $cdata) {
    }

    /**
     * XML Callback to process end elements
     * @access private
     */
    function _tagClose(&$parser, $tag) {
    }

    /**
     * Write a new copy of the versions.dat file based on the versions contained in the import file.
     * When writing, set Gallery into maintenance mode.
     * @param string $coreVersion The core API version number to write.
     * @param string $galleryVersion The Gallery API version number to write.
     * @return object GalleryStatus
     */
    function writeVersions($coreVersion, $galleryVersion) {
	global $gallery;
	$platform =& $gallery->getPlatform();

	$versionFile = $gallery->getConfig('data.gallery.version');

	$versionsData = implode("\n", array($coreVersion, $galleryVersion, 'maintenance-mode'));

	if (!$platform->atomicWrite($versionFile, $versionsData)) {
	    $gallery->debug('Error: Can\'t write to versions file');
	    return GalleryCoreApi::error(ERROR_PLATFORM_FAILURE, __FILE__, __LINE__,
							       'Can\'t write to the versions file');
	}

	return null;
    }
}

/**
 * Abstract Import Object. This class provides basic methods for importing Gallery information from
 * an exported Gallery file.
 */
class GalleryImportObject {
    /**
     * Defines the number of rows to be read before letting the user know that we are still working.
     */
    var $_rowChunkSize = 200;

    /**
     * Storage object.
     */
    var $_storage;

    /**
     * var object Parent
     */
    var $_parent;

    /**
     * var string current element
     */
    var $_currentElement;

    /**
     * This is a place holder for a list of errors that have occurred.
     */
    var $_errors;

    /**
     * This variable contains the call back information and contains the following keys
     * 'progress' current progress
     * 'total' total work involved
     * 'callback' progress bar notification callback
     */
    var $_callBack;

    /**
     * Constructor
     */
    function GalleryImportObject(&$parent=null) {
    	global $gallery;

	$this->_parent =& $parent;
    	$this->_storage =& $gallery->getStorage();
    }

    /**
     * XML Callback to process start elements
     * @access private
     */
    function _tagOpen(&$parser, $tag, $attributes) {
    }

    /**
     * XML Callback to process CDATA elements
     * @access private
     */
    function _tagCdata(&$parser, $cdata) {
    }

    /**
     * XML Callback to process end elements
     * @access private
     */
    function _tagClose(&$parser, $tag) {
    }

    /**
     * Stores an error message for later display.  Follows the parent change unitl a $_error
     * variable is found.
     * @param GalleryStatus $status A Gallery status object.
     */
    function setError($status) {
    	if (isset($this->_parent)) {
	    $this->_parent->setError($status);
    	} else {
	    $this->_errors[] = $status;
    	}
    }

    /**
     * Walks the tag chain to find the parent that has the callback information and then does the
     * callback.
     * @param integer $progress (optional) The amount to increase the progress bar by.
     * @param integer $total (optional) The amount to increase the total work units by.
     */
    function updateStatus($progress=1, $total=0) {
    	global $gallery;

    	if (isset($this->_parent)) {
	    $this->_parent->updateStatus($progress, $total);
    	} else {
    	    $this->_callBack['progress'] += $progress;
   	    $this->_callBack['total'] += $total;
	    $complete = $this->_callBack['progress'] / $this->_callBack['total'];
	    $callback = $this->_callBack['callBack'];
	    call_user_func_array($callback, array($complete));
	    $gallery->guaranteeTimeLimit(120);
    	}
    }
}

/**
 * GalleryConfigImport provides the functionality to import the config.php from an exported file
 */
class GalleryConfigImport extends GalleryImportObject {
    /**
     * Contains the contents of the config.php file included in the XML schema
     */
    var $_contents = '';

    function GalleryConfigImport(&$parent, $attributes=null) {
	parent::GalleryImportObject($parent);
	$this->_currentElement = 'CONFIG';
    }

    /**
     * XML Callback to process CDATA elements
     * @access private
     */
    function _tagCdata(&$parser, $cdata) {
	if ($this->_currentElement == 'CONFIG') {
	    $this->_contents .= $cdata;
	}
    }

    /**
     * XML Callback to process end elements
     * @access private
     */
    function _tagClose(&$parser, $tag) {
    	global $gallery;

	$this->_currentElement = '';

	if ($tag == 'CONFIG') {
	    $configFile = GALLERY_CONFIG_DIR . '/config.php';
	    $platform =& $gallery->getPlatform();

	    if (!$platform->file_put_contents($configFile, $this->_contents)) {
		$this->setError(GalleryCoreApi::error(ERROR_PLATFORM_FAILURE, __FILE__,
					__LINE__, 'Unable to write to config.php.'));
		return;
	    }

	    @include($configFile);

	    $gallery->setConfig('mode.maintenance', true);

	    $this->updateStatus(1, 1);

	    xml_set_object($parser, $this->_parent);
	}
    }
}

/**
 * GalleryPluginImport provides the functionality to import a module from an exported file.
 */
class GalleryPluginImport extends GalleryImportObject {
    /**
     * Variable to hold the module id
     */
    var $_id;

    function GalleryPluginImport($parent, $attributes=null) {
	parent::GalleryImportObject($parent);
	$this->_id = $attributes['ID'];
    }

    /**
     * XML Callback to process start elements
     * @access private
     */
    function _tagOpen(&$parser, $tag, $attributes) {
	$this->_currentElement = $tag;

	switch ($this->_currentElement) {
	    case 'SEQUENCE':
		$this->importSequence($attributes['NAME'], $attributes['SEQ']);
		break;
	    case 'TABLE':
		xml_set_object($parser, new GalleryTableImport($this, $attributes));
		break;
	}
    }

    /**
     * XML Callback to process end elements
     * @access private
     */
    function _tagClose(&$parser, $tag) {
	$this->_currentElement = '';

	if ($tag == 'PLUGIN') {
	    xml_set_object($parser, $this->_parent);
	}
    }

    function importSequence($name, $seqValue) {
	$extras =& $this->_storage->_getExtras();
    	$ret = $extras->dropSequence($name);
    	if ($ret) {
    	    $this->setError($ret);
    	    return null;
    	}

    	$ret = $extras->createSequence($name, $seqValue);
    	if ($ret) {
    	    $this->setError($ret);
    	    return null;
    	}

	return null;
    }
}

/**
 * GalleryTableImport provides the functionality to import a table definition from an exported file.
 */
class GalleryTableImport extends GalleryImportObject {
    /**
     * Variable to hold the table name
     */
    var $_name;

    /**
     * Holds the generated insert for this table
     */
    var $_currentSql = '';

    function GalleryTableImport($parent, $attributes=null) {
	parent::GalleryImportObject($parent);
	$this->_name = $attributes['NAME'];
    }

    /**
     * XML Callback to process start elements
     * @access private
     */
    function _tagOpen(&$parser, $tag, $attributes) {
    	global $gallery;
	$this->_currentElement = $tag;
    	/* Start with 2 minutes and we will increase it later. */
	$gallery->guaranteeTimeLimit(120);

	switch ($this->_currentElement) {
	    case 'CREATE-SQL':
		$this->_currentSql = '';
		break;
	    case 'DATA':
		xml_set_object($parser, new GalleryDataImport($this, $this->_name, $attributes));
		break;
	}
    }

    /**
     * XML Callback to process CDATA elements
     * @access private
     */
    function _tagCdata(&$parser, $cdata) {
	 if ($this->_currentElement == 'CREATE-SQL') {
	     $this->_currentSql .= $cdata;
	}
    }

    /**
     * XML Callback to process end elements
     * @access private
     */
    function _tagClose(&$parser, $tag) {
	$this->_currentElement = '';

	switch ($tag) {
	    case 'CREATE-SQL':
		$ret = $this->_dropTable();
		if ($ret) {
		    $this->setError($ret);
		    return null;
		}
		$extras =& $this->_storage->_getExtras();
		$ret = $extras->_executeSql($this->_currentSql);
		if ($ret) {
		    $this->setError($ret);
		    return null;
		}
		$ret = $this->_storage->commitTransaction();
		if ($ret) {
		    $this->setError($ret);
		}
		break;
	    case 'TABLE':
		$this->updateStatus();
		xml_set_object($parser, $this->_parent);
		break;
 	}
    }

    /**
     * Utility function to drop a table.
     */
    function _dropTable() {
	list ($table, $unused, $unused) = $this->_storage->_translateTableName($this->_name);

	$ret = $this->_storage->execute('DROP TABLE ' . $table);
	/*
	 * Don't check the return code. We will assume the table doesn't exist and just recreate it.
	 */
	return null;
    }
}

/**
 * GalleryDataImport provides the functionality to import a table data from an exported file.
 */
class GalleryDataImport extends GalleryImportObject {
    /**
     * Variable to hold the table name
     */
    var $_tableName;

    /**
     * Array of field names, in the order that the data was exported.
     */
    var $_fields = array();

    /**
     * Contains the data for each field in a row.
     */
    var $_rowData = array();

    /**
     * Temporary storage for the field data
     */
    var $_fieldData;

    /**
     * Row counter so we can provide feedback to the user
     */
    var $_rowCounter;

    /**
     * Holds the generated insert for this table
     */
    var $_currentSql = '';

    function GalleryDataImport($parent, $tableName, $attributes=null) {
	parent::GalleryImportObject($parent);

	list ($this->_tableName, $fill, $fill) = $this->_storage->_translateTableName($tableName);
	$this->_rowCounter = 0;
    }

    /**
     * XML Callback to process start elements
     * @access private
     */
    function _tagOpen(&$parser, $tag, $attributes) {
	$this->_currentElement = $tag;

	switch ($this->_currentElement) {
	    case 'FIELD':
		$this->_fields[] = $this->_storage->_translateColumnName($attributes['NAME']);
		break;
	    case 'ROW':
		if (empty($this->_currentSql)) {
		    $this->_currentSql = 'INSERT INTO ' . $this->_tableName . ' ('
				       . implode(', ', $this->_fields) . ') VALUES ('
				       . GalleryUtilities::makeMarkers(count($this->_fields)) . ')';
		}
		$this->_rowData = array();
		break;
	    case 'F':
		$this->_fieldData = '';
		break;
	    default:
	}
    }

    /**
     * XML Callback to process CDATA elements
     * @todo At some future date, decode the data from base64 encoded.  Only if a similiar change
     * 	     is done to GalleryDatabaseExport.
     * @access private
     */
    function _tagCdata(&$parser, $cdata) {
	switch ($this->_currentElement) {
	    case 'F':
		$this->_fieldData .= $cdata;
	    default:
	}
    }

    /**
     * XML Callback to process end elements
     * @access private
     */
    function _tagClose(&$parser, $tag) {
	$this->_currentElement = '';

	switch ($tag) {
	    case 'F':
		$this->_rowData[] = $this->_fieldData;
		break;
	    case 'ROW':
		$ret = $this->_storage->execute($this->_currentSql, $this->_rowData);
		if ($ret) {
		    $this->setError($ret);
		    return null;
		}
		$this->_rowCounter++;
		if ($this->_rowCounter >= $this->_rowChunkSize) {
		    $this->updateStatus(1, 1);
		    $this->_rowCounter = 0;
		}
		break;
	    case 'DATA':
		xml_set_object($parser, $this->_parent);
		break;
	    default:
	}
    }
}
?>
