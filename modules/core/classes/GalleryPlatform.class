<?php
/*
 * $RCSfile$
 *
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2003 Bharat Mediratta
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
/**
 * @version $Revision$ $Date$
 * @package GalleryCore
 * @author Bharat Mediratta <bharat@menalto.com>
 */

/**
 * A framework for doing platform specific tasks.
 * 
 * This is an abstract class that implements many basic tasks that are
 * different from platform to platform.  
 *
 * @package GalleryCore
 * @abstract
 * @access public
 */
class GalleryPlatform {

    /**
     * Copy a file 
     *
     * @param string the source file
     * @param string the destination file
     * @return bool TRUE if the copy succeeded, FALSE otherwise.
     * @access public
     */
    function copy($source, $dest) {
	global $gallery;
	if ($gallery->getDebug()) {
	    $gallery->debug("copy($source, $dest)");
	}
	
	$umask = umask(0133);
	if (is_uploaded_file($source)) {
	    $results = move_uploaded_file($source, $dest);
	} else {
	    $results = copy($source, $dest);
	}
	umask($umask);

	return $results;
    }

    /**
     * Move an uploaded file to a new location and return the new location.
     *
     * If the second filename is not provided, a new file is created in the
     * Gallery temporary directory.
     *
     * @return string the new file name, if the move was successful
     * @access public
     */
    function move_uploaded_file($filename, $newFilename=null) {
	global $gallery;
	if ($gallery->getDebug()) {
	    $gallery->debug("move_uploaded_file($filename, $newFilename)");
	}

	if (empty($newFilename)) {
	    $tmpDir = $gallery->getConfig('data.gallery.tmp');
	    $newFilename = tempnam($tmpDir, 'MUF_');
	    if ($newFilename == null) {
		return null;
	    }
	    if ($gallery->getDebug()) {
		$gallery->debug("chose new file name: $newFilename");
	    }
	}

	if (move_uploaded_file($filename, $newFilename)) {
	    return $newFilename;
	} else {
	    return null;
	}
    }

    /**
     * Does the given file exist?
     *
     * @param string full filesystem path to a file
     * @return bool TRUE if the file exists, FALSE otherwise
     * @access public
     */
    function file_exists($filename) {
	global $gallery;
	if ($gallery->getDebug()) {
	    $gallery->debug("file_exists($filename)");
	}

	return is_uploaded_file($filename) || file_exists($filename);
    }

    /**
     * Is the given path a symbolic link?
     *
     * @param string a filesystem path
     * @return bool TRUE if the file is a link, FALSE otherwise
     * @access public
     */
    function is_link($filename) {
	global $gallery;
	if ($gallery->getDebug()) {
	    $gallery->debug("is_link($filename)");
	}
	
	return is_link($filename);
    }

    /**
     * Is the given path a directory?
     *
     * @param string a filesystem path
     * @return bool TRUE if the path is a directory, FALSE otherwise
     * @access public
     */
    function is_dir($filename) {
	global $gallery;
	if ($gallery->getDebug()) {
	    $gallery->debug("is_dir($filename)");
	}
	
	return is_dir($filename);
    }

    /**
     * Is the given path a normal file?
     *
     * @param string a filesystem path 
     * @return bool TRUE if the path is a file, FALSE otherwise
     * @access public
     */
    function is_file($filename) {
	global $gallery;
	if ($gallery->getDebug()) {
	    $gallery->debug("is_file($filename)");
	}
	
	return @is_file($filename);
    }

    /**
     * Is the given path a writeable file
     *
     * @param string a filesystem path 
     * @return bool TRUE if the path is writeable, FALSE otherwise
     * @access public
     */
    function is_writeable($filename) {
	global $gallery;
	if ($gallery->getDebug()) {
	    $gallery->debug("is_writeable($filename)");
	}
	
	return is_writeable($filename);
    }

    /**
     * Is the given path a readable file
     *
     * @param string a filesystem path 
     * @return bool TRUE if the path is readable, FALSE otherwise
     * @access public
     */
    function is_readable($filename) {
	global $gallery;
	if ($gallery->getDebug()) {
	    $gallery->debug("is_readable($filename)");
	}
	
	return is_readable($filename);
    }

    /**
     * Is the given path an uploaded file
     *
     * @param string a filesystem path 
     * @return bool TRUE if the path is an uploaded file, FALSE otherwise
     * @access public
     */
    function is_uploaded_file($filename) {
	global $gallery;
	if ($gallery->getDebug()) {
	    $gallery->debug("is_uploaded_file($filename)");
	}
	
	return is_uploaded_file($filename);
    }

    /**
     * Is the given path an executable file?
     *
     * @param string a filesystem path 
     * @return bool TRUE if the path is an executable file, FALSE otherwise
     * @access public
     */
    function is_executable($filename) {
	global $gallery;
	if ($gallery->getDebug()) {
	    $gallery->debug("is_executable($filename)");
	}
	
	return is_executable($filename);
    }

    /**
     * How large is the given file?
     *
     * @param string full filesystem path to a file
     * @return int the size in bytes
     * @access public
     */
    function filesize($filename) {
	global $gallery;
	if ($gallery->getDebug()) {
	    $gallery->debug("filesize($filename)");
	}
	
	return filesize($filename);
    }

    /**
     * Return a file as an array
     *
     * @param string a file path or URL
     * @param int if this is set to 1, search the include path also
     * @return resource a file descriptor
     * @access public
     */
    function file($filename, $use_include_path=false) {
	global $gallery;
	if ($gallery->getDebug()) {
	    $gallery->debug("file($filename, $use_include_path)");
	}
	
	return file($filename, $use_include_path);
    }
    
    /**
     * Output a file
     *
     * @param string a file path or URL
     * @param int if this is set to 1, search the include path also
     * @return resource a file descriptor
     * @access public
     */
    function readfile($filename, $use_include_path=false) {
	global $gallery;
	if ($gallery->getDebug()) {
	    $gallery->debug("readfile($filename, $use_include_path)");
	}
	return readfile($filename, $use_include_path);
    }
    
    /**
     * Open a file or URL
     *
     * @param string a file path or URL
     * @param string a file mode
     * @param int if this is set to 1, search the include path also
     * @return resource a file descriptor
     * @access public
     */
    function fopen($filename, $mode, $use_include_path=0) {
	global $gallery;
	if ($gallery->getDebug()) {
	    $gallery->debug("fopen($filename, $mode, $use_include_path)");
	}
	
	return fopen($filename, $mode, $use_include_path);
    }

    /**
     * Open a file or URL
     *
     * @param string a file path
     * @return resource a directory descriptor
     * @access public
     */
    function opendir($path) {
	global $gallery;
	if ($gallery->getDebug()) {
	    $gallery->debug("opendir($path)");
	}
	
	return opendir($path);
    }

    /**
     * Rename a file/dir
     *
     * As a side bonus, create a backup of the original file.
     *
     * @param string original file/dir name
     * @param string new file/dir name
     * @return bool true on success, false on failure
     * @access public
     */
    function rename($oldname, $newname) {
	global $gallery;
	if ($gallery->getDebug()) {
	    $gallery->debug("rename($oldname, $newname)");
	}

	return rename($oldname, $newname);
    }

    /**
     * Get information about a file
     *
     * @param string file/dir name
     * @return array the statistics of the file
     * @access public
     */
    function stat($filename) {
	global $gallery;
	if ($gallery->getDebug()) {
	    $gallery->debug("stat($filename)");
	}
	
	return stat($filename);
    }

    /**
     * Get size information about an image
     *
     * @param string the image file name
     * @return array with 4 elements. Index 0 contains the
     * width of the image in pixels. Index 1 contains the height. Index 2 is a
     * flag indicating the type of the image: 1 = GIF, 2 = JPG, 3 = PNG, 4 =
     * SWF, 5 = PSD, 6 = BMP, 7 = TIFF(intel byte order), 8 = TIFF(motorola
     * byte order), 9 = JPC, 10 = JP2, 11 = JPX, 12 = JB2, 13 = SWC, 14 =
     * IFF. These values correspond to the IMAGETYPE constants that were added
     * in PHP 4.3. Index 3 is a text string with the correct height="yyy"
     * width="xxx" string that can be used directly in an IMG tag.
     */
    function getimagesize($filename) {
	global $gallery;
	if ($gallery->getDebug()) {
	    $gallery->debug("getimagesize($filename)");
	}
	return getimagesize($filename);
    }

    /**
     * Delete a file
     *
     * @param string file name
     * @return bool true on success, false on failure
     * @access public
     */
    function unlink($filename) {
	global $gallery;
	if ($gallery->getDebug()) {
	    $gallery->debug("unlink($filename)");
	}
	
	return unlink($filename);
    }

    /**
     * Delete a directory
     *
     * @param string directory name
     * @return bool true on success, false on failure
     * @access public
     */
    function rmdir($filename) {
	global $gallery;
	if ($gallery->getDebug()) {
	    $gallery->debug("rmdir($filename)");
	}
	
	return rmdir($filename);
    }

    /**
     * Delete a directory, and all its contents
     *
     * @param string directory name
     * @return bool true on success, false on failure
     * @access public
     */
    function recursiveRmdir($dirname) {
	global $gallery;
	if ($gallery->getDebug()) {
	    $gallery->debug("recursiveRmdir($dirname)");
	}

	if (!($fd = $this->opendir($dirname))) {
	    return false;
	}

	while (($filename = readdir($fd)) != false) {
	    if (!strcmp($filename, ".")) {
		continue;
	    }

	    if (!strcmp($filename, "..")) {
		continue;
	    }

	    $path = "$dirname/$filename";
	    
	    if ($this->is_dir($path)) {
		$ret = $this->recursiveRmdir($path);
	    } else {
		$ret = $this->unlink($path);
	    }
	    
	    if ($ret == false) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	}
	closedir($fd);

	return $this->rmdir($dirname);
    }

    /**
     * Create a new directory
     *
     * @param string a filesystem path
     * @param string permissions of the newly created directory
     * @return bool true on success, false on failure
     * @access public
     */
    function mkdir($path, $stringPerms='755') {
	global $gallery;

	/* Convert string permission representation to octal */
	$octalPerms = octdec($stringPerms);
	if ($gallery->getDebug()) {
	    $gallery->debug(sprintf("mkdir(%s, %o)", $path, $octalPerms));
	}
	
	$umask = umask(0);

	$results = mkdir($path, $octalPerms);
	umask($umask);
	return $results;
    }

    /**
     * Return true if the path component specified is composed of legal
     * characters.
     *
     * @param string the path component (must not contain path separators)
     * @return true if yes
     */
    function isLegalPathComponent($component) {
	$legalChars = $this->getLegalPathCharacters();
	if (strspn($component, $legalChars) == strlen($component)) {
	    return true;
	} else {
	    return false;
	}
    }

    /**
     * Legal characters on all systems: A-Z a-z 0-9 _ . -
     *
     * Specific platform implementations can override this.
     *
     * @return string a string composed of all legal path characters
     */
    function getLegalPathCharacters() {
	return "ABCDEFGHIJKLMNOPQRSTUVWXYZ" .
	    "abcdefghijklmnopqrstuvwxyz" .
	    "0123456789" .
	    " _.-";

	/*
	 * XXX: Keep the hyphen at the end of this string, else ereg()
	 * functions will complain if you use this in a bracket expression.
	 */
    }

    /**
     * Remove any illegal characters from the path component.
     */
    function legalizePathComponent($component) {
	$legal = $this->getLegalPathCharacters();

	/* Scrub out all the illegal characters */
	$component = ereg_replace("[^$legal]", "_", $component);

	/* Break it into filebase and extension */
	list ($fileBase, $extension) = GalleryUtilities::getFileNameComponents($component);
	
	/*
	 * Convert all dots to underscores in the fileBase.  This prevents
	 * malicious users from uploading files like 'foo.php.jpg' which will
	 * be treated like a JPEG by Gallery, but could be treated like a .php
	 * file by Apache opening a security hole.
	 */
	$fileBase = str_replace('.', '_', $fileBase);

	/*
	 * If we don't know exactly what type this file is, we have to assume
	 * that it's something malicious.  In that case, it might be a server
	 * side script of some kind and we don't want that to wind up in the
	 * albums directory in a pure state because it may open up a security
	 * hole on systems that have placed the gallery data directory inside
	 * the document root.  So mangle the extension to make sure that the
	 * webserver doesn't execute it.
	 */
	$tmp = GalleryUtilities::convertExtensionToMime($extension);
	if ($tmp == 'application/unknown' && !empty($extension)) {
	    $fileBase = $fileBase . '_' . $extension;
	    $extension = null;
	}

	/* Rebuild the baseName according to our transforms above */
	$baseName = $fileBase;
	if (!empty($extension)) {
	    $baseName .= '.' . $extension;
	}

	return $baseName;
    }
    
    /**
     * Execute a command and record the results and status.
     *
     * @param array(array('cmd', 'arg'), ...)
     * @param whether or not we should return error output
     * @return array(bool TRUE if the command succeeded, FALSE otherwise,
     *               string output from the command)
     * @access public
     */
    function exec($cmdArray, $returnErrorOutput=false) {
	/* This must be implemented in a platform specific way */
	assert(false);
    }

    /**
     * Return the filesystem specific directory separator
     *
     * @return string directory separator
     */
    function getDirectorySeparator() {
	/* This must be implemented in a platform specific way */
	assert(false);
    }

    /**
     * Return true if the path provided is allowed by the current open_basedir
     * configuration.
     *
     * @return true if the path is ok
     */
    function isRestrictedByOpenBaseDir($path) {
	/*
	 * This must be implemented in a platform specific way due to the fact
	 * that different PHP platforms use different separators in the basedir
	 * path, and since case sensitivity of path elements is not relevant on
	 * all platforms.
	 */
	assert(false);
    }
}
?>
