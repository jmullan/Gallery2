<?php
/*
 * $RCSfile: GalleryRepositoryUtilities.class,v $
 *
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2006 Bharat Mediratta
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
/**
 * @version $Revision: 1.2 $ $Date: 2006/01/10 04:39:21 $
 * @package GalleryCore
 * @author Jozef Selesi <selesi at gmail dot com>
 */

/**
 * Provides repository-related utility functions. Some
 * of them are also used by the repository tools.
 *
 * @package GalleryCore
 * @subpackage Helpers
 */
class GalleryRepositoryUtilities {

    /**
     * Extracts a timestamp from the specified string.
     *
     * The timestamp must be in one of the following formats:
     *  yyyy/mm/dd hh:mm:ss
     *  yyyy-mm-dd hh:mm[-|+]hhmm
     *
     * @param string to exract timestamp from
     * @return array object GalleryStatus a status code
     *               string timestamp
     */
    function extractTimestamp($string) {
	if (preg_match('/(\d{4})\/(\d{2})\/(\d{2}) (\d{2}):(\d{2}):(\d{2})/', $string, $date)) {
	    /* yyyy/mm/dd hh:mm:ss */
	    $date = $date[1].$date[2].$date[3].$date[4].$date[5].$date[6];
	} else if (preg_match('/(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2})([-|\+])(\d{2})(\d{2})/',
		$string, $parts)) {
	    /*
	     * yyyy-mm-dd hh:mm[-|+]hhhh
	     * We work around a bit to get an expected timestamp, since this format includes a
	     * timezone offset, which we have to add to or subtract from the datetime.
	     */
	    $timestamp = mktime($parts[4], $parts[5], 0, $parts[2], $parts[3], $parts[1]);
	    if ($parts[6] == '+') {
		$timestamp += 60 * 60 * $parts[7];
		$timestamp += 60 * $parts[8];
	    } else {
		$timestamp -= 60 * 60 * $parts[7];
		$timestamp -= 60 * $parts[8];
	    }
	    $date = date('YmdHis', $timestamp);
	} else {
	    return array(GalleryCoreApi::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__,
					      "No timestamp found in [$string]"),
			 null);
	}
	return array(null, $date);
    }

    /**
     * Extracts the revision number from a string generated by CVS' Id tag.
     *
     * The patterned searched for is:
     *  ,v [revision] [number]
     *
     * @param string to exract revision from
     * @return array object GalleryStatus a status code
     *               string revision
     */
    function extractRevision($string) {
	if (preg_match('/.*,v ([\d.]+) \d.*/U', $string, $revision)) {
	    $revision = $revision[1];
	} else {
	    return array(GalleryCoreApi::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__,
					      "No revision found in [$string]"),
			 null);
	}
	return array(null, $revision);
    }

    /**
     * Compares two specified versions and, optionally, build numbers (timestamps). Returns the
     * relation between the first and second specified versions.
     *
     * @param string first version (x[.y][.z][...])
     * @param string second version
     * @param int first build (yyyymmddhhmmss)
     * @param int second build
     * @return array object GalleryStatus a status code
     *		      string 'older', 'equal', 'newer'
     */
    function compareVersions($version1, $version2, $build1 = '', $build2 = '') {
	$relation = '';

	/* Compare versions if they're different. */
	if ($version1 != $version2) {
	    $relation = $this->compareRevisions($version1, $version2);
	}

	/* Compare builds if they're specified and if versions are identical. */
	if (!empty($build1) && !empty($build2) && empty($relation)) {
	    /* Get Unix timestamps for builds. */
	    if (!preg_match('/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/', $build1, $build1)) {
		return array(GalleryCoreApi::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__,
						  "Invalid build number [$build1]"),
			     null);
	    }
	    $build1 =
		mktime($build1[4], $build1[5], $build1[6], $build1[2], $build1[3], $build1[1]);
	    if (!preg_match('/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/', $build2, $build2)) {
		return array(GalleryCoreApi::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__,
						  "Invalid build number [$build2]"),
			     null);
	    }
	    $build2 =
		mktime($build2[4], $build2[5], $build2[6], $build2[2], $build2[3], $build2[1]);

	    if ($build1 != $build2) {
		$relation = $build1 > $build2 ? 'newer' : 'older';
	    }
	}

	/* If no differences have been found, versions/builds are equal. */
	if (empty($relation)) {
	    $relation = 'equal';
	}

	return array(null, $relation);
    }

    /**
     * Compares two specified revisions.
     *
     * @param first revision (x[.y][.z][...])
     * @param second revision
     * @return string 'equal', 'older' or 'newer'
     */
    function compareRevisions($revision1, $revision2) {
	if ($revision1 == $revision2) {
	    return 'equal';
	}

	$revision1 = explode('.', $revision1);
	$revision2 = explode('.', $revision2);

	$subRevisions = count($revision1) > count($revision2) ? count($revision1)
							      : count($revision2);
	for ($i = 0; $i < $subRevisions; $i ++) {
	    if (!isset($revision2[$i])) {
		$relation = 'newer';
		break;
	    }
	    if (!isset($revision1[$i])) {
		$relation = 'older';
		break;
	    }
	    if ($revision1[$i] != $revision2[$i]) {
		$relation = $revision1[$i] > $revision2[$i] ? 'newer' : 'older';
		break;
	    }
	}
	return $relation;
    }

    /**
     * Reads specified number of bytes from the file's beginning.
     *
     * @param string file path
     * @param int bytes to read
     * @return array object GalleryStatus a status code
     *               string first line from file
     */
    function getFirstBytesFromFile($path, $bytes) {
	global $gallery;
	$platform =& $gallery->getPlatform();

	if ($file = $platform->fopen($path, 'r')) {
	    $data = $platform->fread($file, $bytes);
	    $platform->fclose($file);
	} else {
	    return array(GalleryCoreApi::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__,
					      "Error reading file [$path]"),
			 '');
	}
	return array(null, $data);
    }

    /**
     * Reads the strings.raw revision of the specified plugin.
     *
     * @param string 'module' or 'theme'
     * @param string plugin ID
     * @return array object GalleryStatus a status code
     *		     string strings.raw timestamp
     */
    function getLanguageBaseRevision($pluginType, $pluginId) {
	global $gallery;

	/* Make sure that strings.raw exists where we expect it. */
	$platform =& $gallery->getPlatform();
	$pluginBaseDir = GalleryCoreApi::getPluginBaseDir($pluginType, $pluginId, true);
	$pluginLanguageBasePath =
	    sprintf('%s%ss/%s/po/strings.raw', $pluginBaseDir, $pluginType, $pluginId);
	if (!$platform->file_exists($pluginLanguageBasePath)) {
	    return array(GalleryCoreApi::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__,
					      "Strings.raw not found [$pluginLanguageBasePath]"),
			 null);
	}

	/* Get the strings.raw file's first line which contains the timestamp. */
	list ($ret, $line) = $this->getFirstBytesFromFile($pluginLanguageBasePath, 128);
	if ($ret) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	list ($ret, $revision) = $this->extractRevision($line);
	if ($ret) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	return array(null, $revision);
    }

    /**
     * Determines whether the specified plugin is available in the local Gallery.
     *
     * @param string 'module' or 'theme'
     * @param string plugin ID
     * @return array object GalleryStatus a status code
     *		     boolean availability
     */
    function isPluginAvailable($pluginType, $pluginId) {
	/* REVISIT: Cache plugin list/convert to hashtable for better performance? */
	list ($ret, $plugins) = GalleryCoreApi::getAllPluginIds($pluginType);
	if ($ret) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	$isAvailable = in_array($pluginId, $plugins);
	return array(null, $isAvailable);
    }

    /**
     * Checks plugin compatibility with a certain version of Gallery.
     *
     * Determines whether the specified plugin type's required APIs are compatible with specified
     * provided APIs. If provided APIs are omitted, currently installed API versions will be
     * used.
     *
     * @param string 'module' or 'theme'
     * @param array required core API version
     * @param array required theme/module API version
     * @param array provided core API versions ('core', 'module', 'theme' => array(Major, Minor))
     * @return boolean compatibility
     */
    function isPluginCompatible($pluginType, $requiredCoreApi, $requiredPluginApi,
	    $providedApis = null) {

	/*
	 * We must explicitly convert version numbers to integers because
	 * GalleryUtilities::isCompatibleWithApi only works with integers.
	 */
	$requiredCoreApi[0] = (int)$requiredCoreApi[0];
	$requiredCoreApi[1] = (int)$requiredCoreApi[1];
	$requiredPluginApi[0] = (int)$requiredPluginApi[0];
	$requiredPluginApi[1] = (int)$requiredPluginApi[1];

	/* If no provided core API versions were specified, get versions from installed core. */
	list ($providedCoreApi, $providedPluginApi) =
	    $this->getProvidedApis($pluginType, $providedApis);

	return (GalleryUtilities::isCompatibleWithApi($requiredCoreApi, $providedCoreApi)
	    && GalleryUtilities::isCompatibleWithApi($requiredPluginApi, $providedPluginApi));
    }

    /**
     * Returns the provided APIs relevant to the specified plugin type.
     *
     * If no provided APIs are specified, currently installed API versions will be used.
     *
     * @param string 'plugin' or 'theme'
     * @param array provided core API versions ('core', 'module', 'theme' => array(Major, Minor))
     * @return array array provided core API version
     *		     array provided plugin (based on its type) API version
     */
    function getProvidedApis($pluginType, $providedApis = null) {
	if (empty($providedApis)) {
	    $providedCoreApi = GalleryCoreApi::getApiVersion();
	    $providedPluginApi = $pluginType == 'module' ? GalleryModule::getApiVersion()
							 : GalleryTheme::getApiVersion();
	} else {
	    $providedCoreApi[0] = (int)$providedApis['core'][0];
	    $providedCoreApi[1] = (int)$providedApis['core'][1];
	    $providedPluginApi[0] = $pluginType == 'module' ? (int)$providedApis['module'][0]
							    : (int)$providedApis['theme'][0];
	    $providedPluginApi[1] = $pluginType == 'module' ? (int)$providedApis['module'][1]
							    : (int)$providedApis['theme'][1];
	}

	return array($providedCoreApi, $providedPluginApi);
    }

    /**
     * Gets version and build information about the installed packages of the specified plugin.
     *
     * @param string 'module' or 'theme'
     * @param string plugin ID
     * @return array object GalleryStatus a status code
     *		     array[$packageName] => array('version' => $version, 'build' => $build)
     */
    function getPluginPackages($pluginType, $pluginId) {
	global $gallery;

	if (empty($pluginType) || empty($pluginId)) {
	    return array(GalleryCoreApi::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__,
					 "Missing plugin type [$pluginType] and/or ID [$pluginId]"),
			 null);
	}

	$query = '
	    SELECT
	      [GalleryPluginPackageMap::packageName],
	      [GalleryPluginPackageMap::packageVersion],
	      [GalleryPluginPackageMap::packageBuild]
	    FROM
	      [GalleryPluginPackageMap]
	    WHERE
	      [GalleryPluginPackageMap::pluginType] = ?
	      AND
	      [GalleryPluginPackageMap::pluginId] = ?
	    ';

	list ($ret, $searchResults) = $gallery->search($query, array($pluginType, $pluginId));
	if ($ret) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	$data = array();
	while ($result = $searchResults->nextResult()) {
	    $data[$result[0]] = array('version' => $result[1], 'build' => $result[2]);
	}

	return array(null, $data);
    }

    /**
     * Returns the language description of the specified language-country code.
     *
     * e.g. en_US => English (US)
     *
     * @param string language code
     * @return array object GalleryStatus a status code
     *		     string language description
     */
    function getLanguageDescription($languageCode) {
	global $gallery;
	$translator =& $gallery->getTranslator();
	$supportedLanguages = $translator->getSupportedLanguages();

	if (!preg_match('/^(..)_(..)$/', $languageCode, $parts)) {
	    return array(GalleryCoreApi::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__,
					      "Invalid language code specified [$languageCode]"),
			 null);
	}
	$language = $parts[1];
	$country = $parts[2];

	if (!isset($supportedLanguages[$language][$country]['description'])) {
	    return array(GalleryCoreApi::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__,
					      "Language not supported [{$language}_{$country}]"),
			 null);
	}

	return array(null,
	$supportedLanguages[$language][$country]['description']);
    }

    /**
     * Returns the version of the specified plugin.
     *
     * @param string 'module' or 'theme'
     * @param string plugin ID
     * @return array object GalleryStatus a status code
     *		     string version
     */
    function getPluginVersion($pluginType, $pluginId) {
	list ($ret, $plugin) = GalleryCoreApi::loadPlugin($pluginType, $pluginId);
	if ($ret) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	return array(null, $plugin->getVersion());
    }

    /**
     * Downloads a file from the specified URL.
     *
     * It currently calls GalleryCoreApi::fetchWebPage to do all the work, but we'll
     * eventually write a simpler downloader that can report its progress to get more
     * responsive progress indication.
     *
     * @param string url to download from
     * @return array boolean file was successfully downloaded
     *		     string file contents
     */
    function downloadFile($url) {
	list ($successful, $contents, $response, $headers, $actualUrl) = 
	    GalleryCoreApi::fetchWebPage($url);
	if (empty($contents) || !$successful) {
	    return array(false, null);
	}
	return array(true, $contents);
    }
}
?>
