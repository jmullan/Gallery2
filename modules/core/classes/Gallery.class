<?php
/*
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2002 Bharat Mediratta
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

/**
 * Global storage container and utility class for Gallery
 *
 * This is a container for global information required for gallery
 * operation, such as configuration, session, user, etc.  
 *
 * @version $Id$
 * @package GalleryCore
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class Gallery {

    /*
     * ****************************************
     *                 Members
     * ****************************************
     */

    /**
     * The id of the root AlbumItem in the Gallery
     *
     * @var string $_rootAlbumItemId
     * @access private
     */
    var $_rootAlbumItemId;

    /**
     * The id of the active user
     *
     * @var int $_activeUserId
     * @access private
     */
    var $_activeUserId;

    /**
     * Storage for all configuration variables, set in config.php.
     * The values contained here can't be modified.  Well, they
     * can be modified but they can't be saved so it's not a good
     * idea.  
     *
     * @var array $_config
     * @access private
     */
    var $_config;

    /**
     * The current GalleryGraphics
     *
     * @var object GalleryGraphics $_graphics
     * @access private
     */
    var $_graphics;

    /**
     * Storage for all session variables.  Contains an instance
     * of the GalleryMap class.
     *
     * @var object GalleryMap $_session
     * @access private
     */
    var $_session;

    /**
     * The backend persistent store for the Gallery class
     *
     * @var object GalleryStorage $_storage
     * @access private
     */
    var $_storage;

    /**
     * Our lock object
     *
     * @var object GalleryLock $_lock
     * @access private
     */
    var $_lock;

    /**
     * An associative array mapping GalleryItem ids to unique GalleryItem
     * instances.
     *
     * @var array $_nucleusCache
     * @access private
     */
    var $_nucleusCache;
    
    /**
     * An instance of the GalleryPlatform class
     *
     * @var object GalleryPlatform $_platform
     * @access private
     */
    var $_platform;

    /**
     * The current debugging mode.  One of 'buffered', 'logged', 'immediate' or false
     * 
     * @var bool $_debug
     * @access private
     */
    var $_debug;
    
    /**
     * Where to send debug output (when the debugging mode is set to 'logged')
     * 
     * @var bool $_debugLogFile
     * @access private
     */
    var $_debugLogFile;
    
    /**
     * A place to temporarily store debug output when the debugging mode is set
     * to 'buffered'
     * 
     * @var bool $_debugBuffer
     * @access private
     */
    var $_debugBuffer;
    
    /*
     * ****************************************
     *                 Methods
     * ****************************************
     */

    /**
     * Constructor
     *
     */
    function Gallery() {
	$this->_nucleusCache = array();
    }

    /**
     * Return the id of the GalleryItem associated with the path provided
     *
     * Return the id associated with the given path. Example path:
     * "/birthdays/fred" .. this is the "fred" item in the "birthdays"
     * item.  It doesn't really matter what types of items these are, as
     * long as the path is legitimate.
     *
     * @access public
     * @param string the path to a GalleryItem
     * @return array object GalleryStatus a status code
     *               int the id of the GalleryItem (or null)
     */
    function getIdByPath($path) {
	list($ret, $storage) = $this->getStorage();
	if ($ret->isError()) {
	    return array($ret, null);
	}
	
	return $storage->getIdByPath($path);
    }

    /**
     * Add the GalleryNucleus to the cache.
     *
     * @access public
     * @param object GalleryNucleus a reference to the GalleryNucleus to cache
     * @return object GalleryStatus a status code
     */
    function updateCachedNucleus($nucleus) {

	/*
	 * We want to make sure that we don't have parallel versions of objects
	 * floating around and getting modified.  So do a little non OO magic
	 * here.  Tag a special serial number onto the object in the cache so
	 * that when we receive modifications to it later we can be sure that
	 * the user is always working with the latest copy of the object.
	 */
	$id = $nucleus->getId();

	/*
	 * The only way that the user can call updateCachedNucleus() when there
	 * isn't a nucleus already in the cache is the case where they got a
	 * nucleus, then called lockWorld() which flushes the cache.  In that
	 * case, they're dealing with an object that's out of date, so fail.
	 */
	if (!isset($this->_nucleusCache[$id])) {
	    return GalleryStatus::error(ERROR_OBSOLETE_DATA,
					__FILE__, __LINE__);
	}

	/*
	 * Make sure that the object we're caching is derived from the most
	 * current version that we've got in the cache.  If it *isn't* then 
	 * we've got multiple parallel versions of objects in memory getting
	 * modified concurrently (which will lead to database errors later).
	 * The serial number of the object we're updating must match the serial
	 * number of the version that's in the cache currently.
	 */
	$old = $this->_nucleusCache[$id];
	if ($old->_cacheSerial != $nucleus->_cacheSerial) {
	    return GalleryStatus::error(ERROR_OBSOLETE_DATA,
					__FILE__, __LINE__);
	}

	/*
	 * The object being updated matches the one in the cache, so go ahead
	 * and update the cached copy and bump the serial number.
	 */
	$nucleus->_cacheSerial++;
	$this->_nucleusCache[$id] = $nucleus;
	return GalleryStatus::success();
    }

    /**
     * Insert a new nucleus into the cache
     *
     * This blows away any copy of the same nucleus that is already in the
     * cache.
     *
     * @param object GalleryNucleus a reference to the GalleryNucleus to cache
     */
    function cacheNucleus(&$nucleus) {
	$id = $nucleus->getId();
	$nucleus->_cacheSerial = 0;
	$this->_nucleusCache[$id] =& $nucleus;
	return GalleryStatus::success();
    }

    /**
     * Commit any cached changes to the database
     *
     * @return object GalleryStatus a status code
     */
    function commitCache() {
	global $gallery;

	list($ret, $storage) = $gallery->getStorage();
	if ($ret->isError()) {
	    return $ret;
	}
	
	foreach (array_keys($this->_nucleusCache) as $key) {
	    $nucleus =& $this->_nucleusCache[$key];

	    if ($nucleus->testPersistentFlag(STORAGE_FLAG_MARKED_FOR_DELETION)) {
		if ($nucleus->testPersistentFlag(STORAGE_FLAG_NEWLY_CREATED)) {
		    /* Created AND deleted -- ignore it */
		}
		$ret = $storage->deleteNucleus($nucleus);
		if ($ret->isError()) {
		    return $ret;
		}
	    } else if ($nucleus->testPersistentFlag(STORAGE_FLAG_NEWLY_CREATED) ||
		       $nucleus->isModified()) {
		$ret = $storage->saveNucleus($nucleus);
		if ($ret->isError()) {
		    return $ret;
		}
	    }
	}

	/*
	 * Empty out the cache.  For some reason that I don't quite understand,
	 * if we don't do this then objects that have been saved don't get
	 * their flags updated correctly.  This is probably indicative of a
	 * deeper bug, but for now let's just take the easy way out and force
	 * objects to be reloaded, if they're still needed.
	 */
	$this->_nucleusCache = array();

	return GalleryStatus::success();
    }

    /**
     * Are there modified entries still in the cache? 
     *
     * @return bool true if yes
     */
    function isCacheUncommitted() {
	foreach (array_keys($this->_nucleusCache) as $key) {
	    $nucleus =& $this->_nucleusCache[$key];

	    if ($nucleus->testPersistentFlag(STORAGE_FLAG_MARKED_FOR_DELETION) ||
		    $nucleus->testPersistentFlag(STORAGE_FLAG_NEWLY_CREATED) ||
		    $nucleus->isModified()) {

		return true;
	    }
	}

	return false;
    }

    /**
     * Load the GalleryNucleus with the id specified
     *
     * Try to get this value from the cache.  If it's not in the cache, then
     * get it from the persistent store 
     *
     * @param int the id of the GalleryNucleus to load
     * @return array object GalleryStatus a status code, object GalleryNucleus
     */
    function loadNucleusById($id) {
	if (empty($id)) {
	    return array(GalleryStatus::error(ERROR_BAD_PARAMETER,
					      __FILE__, __LINE__),
			 null);
	}

	/* See if we already have a cached instance, use it if so */
	if (!empty($this->_nucleusCache[$id])) {
	    return array(GalleryStatus::success(),
			 $this->_nucleusCache[$id]);
	}

	list($ret, $nucleus) = $this->loadNucleusByIdNoCache($id);

	/* Add this item to the cache */
	$this->cacheNucleus($nucleus);
	
	return array($ret, $nucleus);
    }

    /**
     * Return the appropriate object directly from the persistent store
     *
     * Bypass the cache to read the object directly from the persistent store.
     * Save the object in the cache after loading.
     *
     * @param int the id of the GalleryNucleus object
     * @return array object GalleryStatus a status code, object GalleryNucleus
     * @access private
     */
    function loadNucleusByIdNoCache($id) {
	if (empty($id)) {
	    return array(GalleryStatus::error(ERROR_BAD_PARAMETER,
					      __FILE__, __LINE__),
			 null);
	}
	
	/* Load the nucleus from our persistent store */
	list($ret, $storage) = $this->getStorage();
	if ($ret->isError()) {
	    return array($ret, null);
	}

	list($ret, $nucleus) = $storage->loadNucleus($id);
	if ($ret->isError()) {
	    return array($ret, null);
	}

	/*
	 * The storage object caches data internally on loads.  The only way to
	 * preserve that data across lookups is to keep a copy of the storage
	 * object after calling loadNucleus() with it.
	 */
	$this->_storage = $storage;

	return array(GalleryStatus::success(), $nucleus);
    }

    /**
     * Delete a GalleryNucleus from the persistent store
     *
     * @param int the id of the nucleus
     * @return object GalleryStatus a status code
     */
    function deleteNucleusById($id) {
	if (empty($id)) {
	    return GalleryStatus::error(ERROR_BAD_PARAMETER,
					__FILE__, __LINE__);
	}

	list($ret, $nucleus) = $this->loadNucleusById($id);
	if ($ret->isError()) {
	    return $ret;
	}
	
	return $nucleus->delete();
    }

    /**
     * Search the persistent store for the target values matching the given criteria
     *
     * This is a flexible and powerful search mechanism.  You specify which
     * class members you wish to search for, how you want to search them, and
     * which class members you want returned.
     *
     * Right now we do a logical AND of all criteria.  Later on we should
     * extend this.
     *
     * Example criteria:
     * array(array('GalleryNucleus::parentId',
     *             'EXACT',
     *             $parentId),
     *       array('FileSystemNucleus::pathComponent',
     *             'EXACT',
     *             $path));
     *
     * Comparators can be 'EXACT' or 'CONTAINS'
     *
     * Example target:
     * array('GalleryNucleus::id')
     *
     * Example modifiers:
     * SEARCH_COUNT          -- return only the number of hits
     * SEARCH_LIMIT #        -- return only the first x hits
     * SEARCH_ORDER FileSystemNucleus::pathComponent SEARCH_DIRECTION_UP
     *                       -- sort by path compnent
     *
     * @access public
     * @param array the search criteria
     * @param array the target values (default GalleryNucleus::id)
     * @param array the modifiers
     * @return array object GalleryStatus a status code,
     *               array a list of target values
     */
    function search($criteria,
		    $target=array('GalleryNucleus::id'),
		    $modifiers=array()) {
	list($ret, $storage) = $this->getStorage();
	if ($ret->isError()) {
	    return $ret;
	}
	
	return $storage->search($criteria, $target, $modifiers);
    }

    /**
     * Return the id of the root GalleryItem
     *
     * The root GalleryItem should be an AlbumItem
     *
     * @access public
     * @return int the id of the root album
     */
    function getRootAlbumId() {
	return $this->_rootAlbumItemId;
    }

    /**
     * Set the id of the root GalleryItem
     *
     * The root GalleryItem should be an AlbumItem.
     *
     * @access public
     * @param int the id of the GalleryItem
     */
    function setRootAlbumId($id) {
	if (empty($id)) {
	    return GalleryStatus::error(ERROR_BAD_PARAMETER,
					__FILE__, __LINE__);
	}

	$this->_rootAlbumItemId = $id;
    }

    /**
     * Get the Id of the active user
     *
     * The active user is the user who is logged on in this 
     * session.
     * 
     * @access public
     * @return int the id of the current User.
     */
    function getActiveUserId() {
	return $this->_activeUserId;
    }

    /**
     * Set the id of the active user
     *
     * The active user is the user who is logged on in this 
     * session.
     * 
     * @param int the id of the current User.
     * @access public
     */
    function setActiveUserId($id) {
	assert('!empty($id)');
	$this->_activeUserId = $id;
    }

    /**
     * Get the image toolkit
     *
     * Return a the active GalleryGraphics
     * 
     * @access public
     * @return array object GalleryStatus a status code
     *               object GalleryGraphics the active image toolkit
     */
    function getGraphics() {
	if (empty($this->_graphics)) {
	    $type = $this->getConfig('graphics.type');
	    $config = $this->getConfig('graphics.config');
	    list($ret, $this->_graphics) =
		    GalleryGraphicsFactory::newInstance($type, $config);
	    if ($ret->isError()) {
		return $ret;
	    }
	}
	
	return array(GalleryStatus::success(), $this->_graphics);
    }

    /**
     * Store a value in the Gallery config table
     *
     * @param string the key name
     * @param mixed the value
     * @access public
     */
    function setConfig($key, $value) {
	assert('!empty($key)');
	$this->_config[$key] = $value;
    }

    /**
     * Get a value from the Gallery configuration settings
     *
     * @access public
     * @return mixed an arbitrary value
     */
    function getConfig($key) {
	assert('!empty($key)');
	return $this->_config[$key];
    }

    /**
     * Get the Gallery session object.
     *
     * Return a reference to the unique Gallery session object
     * (implemented as an instance of the GalleryMap class).  Any
     * changes made to this object will be saved in the session.
     * 
     * @access public
     * @return object GalleryMap the Gallery session map
     */
    function &getSession() {
	return $this->_session;
    }

    /**
     * Set the Gallery session object.
     *
     * Assign a reference to the unique Gallery session object
     * (implemented as an instance of the GalleryMap class).
     * 
     * @param object GalleryMap the Gallery session map
     * @access public
     */
    function setSession(&$session) {
	assert('!empty($session)');
	$this->_session =& $session;
    }

    /**
     * Get the Gallery platform object.
     *
     * Return a copy of the unique Gallery platform object.
     * 
     * @access public
     * @return array object GalleryStatus a status code
     *               object GalleryMap the Gallery platform map
     */
    function getPlatform() {
	if (empty($this->_platform)) {
	    list($ret, $platform) = GalleryPlatformFactory::newInstance('unix');
	    if ($ret->isError()) {
		return array($ret, null);
	    }
	    $this->_platform = $platform;
	}
	
	return array(GalleryStatus::success(), $this->_platform);
    }

    /**
     * Lock the entire Gallery
     *
     * Use the active locking mechanism to lock the entire Gallery.  Then,
     * traverse the tree and refresh any objects that we have in memory.  The
     * result of this call is that the entire tree is in sync with the
     * persistent store, and until unlock is called, no one else can
     * change it.
     *
     * Use register_shutdown_function() to register the unlock() method so
     * that we can be sure that we won't accidentally leave the world locked.
     * 
     * @access public
     * @param integer how long to wait for the lock before giving up
     * @return object GalleryStatus a status code
     */
    function lockWorld($timeout=10) {
	/*
	 * If we already have a lock, fail.
	 */
	if (!empty($this->_lock) && $this->_lock->isLocked()) {
	    return GalleryStatus::error(ERROR_ILLEGAL_LOCK,
					__FILE__, __LINE__);
	}

	/*
	 * Make and acquire a new lock.
	 */
	$this->_lock = new GalleryLock();
	return $this->_lock->acquire($timeout);

	/*
	 * Flush the nucleus cache, since everything inside it cannot
	 * be guaranteed to be up to date.
	 */
	$this->_nucleusCache = array();
    }

    /**
     * Release the lock
     *
     * @access public
     * @return object GalleryStatus a status code
     */
    function unlock() {
	if (!empty($this->_lock)) {

	    /* Check to see if we've committed everything */
	    if ($this->isCacheUncommitted()) {
		return GalleryStatus::error(ERROR_UNCOMMITTED_DATA,
					    __FILE__, __LINE__);
	    }
	    
	    $ret = $this->_lock->release();
	    if ($ret->isError()) {
		return $ret;
	    }
	}

	return GalleryStatus::success();
    }

    /**
     * Have we acquired a world lock?
     *
     * @return bool true if the world is locked
     */
    function isLocked() {
	if (empty($this->_lock)) {
	    return false;
	}

	return $this->_lock->isLocked();
    }

    /**
     * Return an instance of the GalleryStorage class
     *
     * @access public
     * @return array object GalleryStatus a status code
     *               object GalleryStorage a storage instance
     */
    function getStorage() {
	if (empty($this->_storage)) {
	    /* Set up our storage system */
	    $type = $this->getConfig('storage.type');
	    $config = $this->getConfig('storage.config');
	    
	    list($ret, $storage) =
		    GalleryStorageFactory::newInstance($type, $config);
	    if ($ret->isError()) {
		return array($ret, null);
	    }

	    $ret = $storage->init();
	    if ($ret->isError()) {
		return array($ret, null);
	    }

	    $this->_storage = $storage;
	}
	return array(GalleryStatus::success(), $this->_storage);
    }

    /**
     * Change the debugging state
     *
     * @param mixed one of 'buffered', 'logged', 'immediate' or false
     */
    function setDebug($debug) {
	$this->_debug = $debug;
	if (isset($this->_storage)) {
	    if ($this->_debug) {
		$this->_storage->setDebug(true);
	    } else {
		$this->_storage->setDebug(false);
	    }
	}
    }

    /**
     * Set the location of debugging output
     *
     * @param string a filename
     */
    function setDebugLogFile($debugLogFile) {
	$this->_debugLogFile = $debugLogFile;
    }

    /**
     * Get the debug state
     *
     * @return mixed the debug state
     */
    function getDebug() {
	return $this->_debug;
    }

    /**
     * Output a debug message
     *
     * @param string a message
     */
    function debug($msg) {
	if (empty($msg)) {
	    return;
	}
	
	if (!empty($this->_debug)) {
	    if (!strcmp($this->_debug, 'buffered')) {
		$this->_debugBuffer .= "$msg\n";
	    } else if (!strcmp($this->_debug, 'logged')) {
		if ($fd = fopen($this->_debugLogFile, 'a')) {
		    $date = date('Y-m-d H:i:s');
		    fwrite($fd, '$date [' . session_id() . '] $msg\n');
		    fclose($fd);
		}
	    } else if (!strcmp($this->_debug, 'immediate')) {
		print "$msg\n";
	    }
	}
    }

    /**
     * Get the string representation(s) of an error.
     *
     * An error is a set of bitflags, so we return an array of strings.
     * @param int the error code
     * @return array string names of the errors
     */
    function getErrorAsStrings($errorCode) {
	$codes = array();
	foreach (get_defined_constants() as $constantName => $constantValue) {
	    if (strpos($constantName, 'ERROR_') === 0) {
		if ($errorCode & $constantValue) {
		    $codes[] = $constantName;
		}
	    }
	}

	return $codes;
    }
}
?>
