<?php
/*
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2002 Bharat Mediratta
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

/**
 * Global storage container and utility class for Gallery
 *
 * This is a container for global information required for gallery
 * operation, such as configuration, session, user, etc.  
 *
 * @version $Id$
 * @package GalleryCore
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class Gallery {

    /*
     * ****************************************
     *                 Members
     * ****************************************
     */

    /**
     * The id of the active user
     *
     * @var int $_activeUserId
     * @access private
     */
    var $_activeUserId;

    /**
     * The active GalleryUser instance
     *
     * @var object GalleryUser $_activeUser
     * @access private
     */
    var $_activeUser;

    /**
     * Storage for all configuration variables, set in config.php.
     * The values contained here can't be modified.  Well, they
     * can be modified but they can't be saved so it's not a good
     * idea.  
     *
     * @var array $_config
     * @access private
     */
    var $_config;

    /**
     * The current debugging mode.  One of 'buffered', 'logged', 'immediate' or false
     * 
     * @var string $_debug
     * @access private
     */
    var $_debug;
    
    /**
     * Where to send debug output (when the debugging mode is set to 'logged')
     * 
     * @var bool $_debugLogFile
     * @access private
     */
    var $_debugLogFile;
    
    /**
     * A place to temporarily store debug output when the debugging mode is set
     * to 'buffered'
     * 
     * @var bool $_debugBuffer
     * @access private
     */
    var $_debugBuffer;

    /**
     * A cache of entities and searches that we've loaded
     *
     * @var array $_storageCache;
     * @access private;
     */
    var $_storageCache;

    /**
     * A registry of event listeners
     *
     * @var array $_eventListeners;
     * @access private;
     */
    var $_eventListeners;

    /**
     * The current GalleryGraphics
     *
     * @var object GalleryGraphics $_graphics
     * @access private
     */
    var $_graphics;

    /**
     * A list of all the locks that have been acquired during this request
     *
     * @var array $_locks
     * @access private
     */
    var $_locks;

    /**
     * Information about Gallery modules
     *
     * @var array
     * @access private
     */
    var $_modules;

    /**
     * An instance of the GalleryPlatform class
     *
     * @var object GalleryPlatform $_platform
     * @access private
     */
    var $_platform;

    /**
     * The current profiling mode.
     * 
     * @var bool $_profile
     * @access private
     */
    var $_profile;
    
    /**
     * A transitory registry used to share data between modules (eg, you can
     * register an implementation in the registry so that a factory can find
     * it).  You can only add to the registry, you can't delete.
     *
     * @var arrayobject GalleryRegistry $_registry
     * @access private
     */
    var $_registry;

    /**
     * Storage for all session variables.  
     *
     * @var object GallerySession $_session
     * @access private
     */
    var $_session;

    /**
     * A pointer to the Smarty template engine
     *
     * @var object Smarty $_smarty
     * @access private
     */
    var $_smarty;
    
    /**
     * The backend persistent store for the Gallery class
     *
     * @var object GalleryStorage $_storage
     * @access private
     */
    var $_storage;

    /**
     * Instance of the GalleryTranslator class
     *
     * @var array $_translator
     * @access private
     */
    var $_translator;

    /**
     * The time at which we should cease whatever operation we're doing
     *
     * @var int $_timeLimit
     * @access private
     */
    var $_timeLimit;

    /*
     * ****************************************
     *                 Methods
     * ****************************************
     */

    /**
     * Constructor
     *
     */
    function Gallery() {
	$this->reset();
	$this->_registry = array();
	$this->_boundDomains = array();
	$this->_eventListeners = array();
	    
	/* Set up a shutdown function to release any hanging locks. */
	register_shutdown_function(array(&$this, '_releaseHangingLocks'));
    }

    /**
     * Reset persistent information
     *
     * This should only be called if we remove and re-install the
     * GalleryStorage instance.
     */
    function reset() {
	$this->_modules = array();
	$this->_locks = array();
	$this->_storage = null;
	$this->_storageCache['loadEntitiesById'] = array();
    }

    /**
     * Return the id of the GalleryItem associated with the path provided
     *
     * Return the id associated with the given path. Example path:
     * "/birthdays/fred" .. this is the "fred" item in the "birthdays"
     * item.  It doesn't really matter what types of items these are, as
     * long as the path is legitimate.
     *
     * @access public
     * @param string the path to a GalleryItem
     * @return array object GalleryStatus a status code
     *               int the id of the GalleryItem (or null)
     */
    function getIdByPath($path) {
	$reply =& $this->getStorage();
	$ret = $reply[0];
	$storage =& $reply[1];
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	/*
	 * XXX: do this in applogic, not in the storage class.
	 */
    }

    /**
     * Load the GalleryEntities with the ids specified
     *
     * @param mixed the ids (or id) of the GalleryEntities to load
     * @return array object GalleryStatus a status code,
     *               mixed one GalleryEntity or an array of GalleryEntities
     */
    function loadEntitiesById($id) {
	GalleryProfiler::start('Gallery::loadEntitiesById');
	
	if (empty($id)) {
	    return array(GalleryStatus::error(ERROR_BAD_PARAMETER,
					      __FILE__, __LINE__),
			 null);
	}

	/* Check for cache hits on single entity lookups */
	if (!is_array($id)) {
	    if (isset($this->_storageCache['loadEntitiesById'][$id])) {
		$entities = $this->_storageCache['loadEntitiesById'][$id];
	    }
	}

	if (!isset($entities)) {

	    /* Get a reference to our storage object */
	    $reply =& $this->getStorage();
	    $ret = $reply[0];
	    $storage =& $reply[1];
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }

	    /* Load the entities from our persistent store */
	    list ($ret, $entities) = $storage->loadEntities($id);
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }

	    if (!is_array($id)) {
		$this->_storageCache['loadEntitiesById'][$id] = $entities;
	    }
	}
	GalleryProfiler::stop('Gallery::loadEntitiesById');
	
	return array(GalleryStatus::success(), $entities);
    }

    /**
     * Delete the entity with the given id 
     *
     * @param int the id of a GalleryEntity to delete
     * @return object GalleryStatus a status code 
     */
    function deleteEntityById($id) {
	if (empty($id)) {
	    return array(GalleryStatus::error(ERROR_BAD_PARAMETER,
					      __FILE__, __LINE__),
			 null);
	}

	$lockIds = array();

	if (is_subclass_of($this, 'GalleryChildEntity')) {
	    list ($ret, $lockIds[]) = $this->acquireReadLockParents($id);
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	    
	    if ($lockIds[0] == null) {
		/*
		 * No lock was acquired - only in the case where I have no
		 * parents
		 */
		unset($lockIds[0]);
	    }
	}

	/* Don't write lock it if it's already locked somewhere else */
	if (!$this->isWriteLocked($id)) {
	    list ($ret, $lockIds[]) = $this->acquireWriteLock($id);
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	}
	
	list ($ret, $entity) = $this->loadEntitiesById($id);
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}
	
	$ret = $entity->delete();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}
	
	$ret = $this->releaseLocks($lockIds);
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * @see GalleryStorage::search()
     */
    function search($query, $data=array()) {

	GalleryProfiler::start('Gallery::search');

	/*
	 * XXX: can't cache the results of the $storage->search() call,
	 * since the results are actually a GallerySearchResultSet which is an
	 * active pointer back into the database.
	 */

	$reply =& $this->getStorage();
	$ret = $reply[0];
	$storage =& $reply[1];
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}
	    
	list ($ret, $results) = $storage->search($query, $data);
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	GalleryProfiler::stop('Gallery::search');
	return array(GalleryStatus::success(), $results);
    }

    /**
     * Get the Id of the active user
     *
     * The active user is the user who is logged on in this 
     * session.
     * 
     * @access public
     * @return int the id of the current User.
     */
    function getActiveUserId() {
	return $this->_activeUserId;
    }

    /**
     * Set the id of the active user
     *
     * The active user is the user who is logged on in this 
     * session.
     * 
     * @param int the id of the current User.
     * @access public
     */
    function setActiveUserId($id) {
	assert('!empty($id)');
	$this->_activeUserId = $id;
    }

    /**
     * Get the active user
     *
     * Cache the results of the first call and return that same value each
     * time.
     *
     * @return array object GalleryStatus a status code
     *               object GalleryUser the active user
     */
    function getActiveUser() {
	if (empty($this->_activeUser)) {
	    list ($ret, $user) = $this->loadEntitiesById($this->getActiveUserId());
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }

	    $this->_activeUser = $user;
	}

	return array(GalleryStatus::success(), $this->_activeUser);
    }

    /**
     * Get the image toolkit
     *
     * Return a the active GalleryGraphics
     * 
     * @access public
     * @return array object GalleryStatus a status code
     *               object GalleryGraphics the active image toolkit
     */
    function getGraphics() {

	/*
	 * Create the graphics object on demand.
	 */
	if (empty($this->_graphics)) {
	    list($ret, $type) = $this->getModuleParameter('core', 'graphics.type');
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	    
	    /* Load the factory class */
	    require_once(dirname(__FILE__) . '/GalleryGraphicsFactory.class');

	    list($ret, $this->_graphics) =
		GalleryGraphicsFactory::newInstance($type);
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	}
	
	return array(GalleryStatus::success(), $this->_graphics);
    }

    /**
     * Store a value in the Gallery config table
     *
     * @param string the key name
     * @param mixed the value
     * @access public
     */
    function setConfig($key, $value) {
	assert('!empty($key)');
	$this->_config[$key] = $value;
    }

    /**
     * Get a value from the Gallery configuration settings
     *
     * @access public
     * @return mixed an arbitrary value
     */
    function getConfig($key) {
	assert('!empty($key)');
	return $this->_config[$key];
    }

    /**
     * Get the Gallery session object.
     *
     * Return a reference to the unique Gallery session object.  Any changes
     * made to this object will be saved in the session.
     * 
     * @access public
     * @return array object GalleryStatus a status code
     *               object GallerySession a session instance
     */
    function &getSession() {
	GalleryProfiler::start('Gallery::getSession');
	
	if (empty($this->_session)) {
	    /* XXX: make this data driven from $gallery->_config */
	    $session = new GallerySession();
	    $ret = $session->init();
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }

	    /*
	     * Write out our session when we're done.  By doing this as a shutdown
	     * function, it will fire after the results have been sent to the
	     * browser.  This gives a slight performance increase on systems that
	     * have idle cycles, but denies us effective debugging and error
	     * handling.
	     */
	    $this->_session =& $session;
	    register_shutdown_function(array(&$this->_session, '_shutdown'));
	}

	GalleryProfiler::stop('Gallery::getSession');
	return array(GalleryStatus::success(), &$this->_session);
    }

    /**
     * Get a value from the session data
     *
     * @param string the key
     * @return array object GalleryStatus a status code
     *               string the value
     */
    function getSessionValue($key) {
	$reply =& $this->getSession();
	if ($reply[0]->isError()) {
	    return array($reply[0]->wrap(__FILE__, __LINE__), null);
	}

	list ($ret, $value) = $reply[1]->get($key);
	if ($ret->isError()) {
	    return array($reply[0]->wrap(__FILE__, __LINE__), null);
	}

	return array(GalleryStatus::success(), $value);
    }

    /**
     * Store a value in the session
     *
     * @param string the key
     * @param string the value
     * @return object GalleryStatus a status code
     */
    function putSessionValue($key, $value) {
	$reply =& $this->getSession();
	if ($reply[0]->isError()) {
	    return $reply[0]->wrap(__FILE__, __LINE__);
	}

	$ret = $reply[1]->put($key, $value);
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * Clean and reinitialize a session
     *
     * @return object GalleryStatus a status code
     */
    function resetSession() {
	$reply =& $this->getSession();
	if ($reply[0]->isError()) {
	    return $reply[0]->wrap(__FILE__, __LINE__);
	}

	$ret = $reply[1]->reset();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * Get the Gallery platform object.
     *
     * Return a copy of the unique Gallery platform object.
     * 
     * @access public
     * @return array object GalleryPlatform the Gallery platform object
     */
    function getPlatform() {
	if (!isset($this->_platform)) {

	    /* Load the factory class */
	    require_once(dirname(__FILE__) . '/GalleryPlatformFactory.class');

	    $platformType = $this->getConfig('platform.type');
	    $this->_platform = GalleryPlatformFactory::newInstance($platformType);
	}
	
	return $this->_platform;
    }

    /**
     * Read Lock one or more objects
     *
     * @access public
     * @param array ids to lock
     * @param integer how long to wait for the lock before giving up
     * @return array object GalleryStatus a status code
     *               int the lock id
     */
    function acquireReadLock($ids, $timeout=10) {

	GalleryProfiler::start('Gallery::acquireReadLock');

	$reply =& $this->getStorage();
	$ret = $reply[0];
	$storage =& $reply[1];
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}
	
	list ($ret, $lock) =
	    $storage->acquireReadLock($ids, $timeout);
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	$lockId = $lock->getId();
	$this->_locks[$lockId] = $lock;

	GalleryProfiler::stop('Gallery::acquireReadLock');

	return array($ret->wrap(__FILE__, __LINE__), $lockId);
    }

    /**
     * Acquire read locks on all the parents of this id.  This is useful when
     * we're going to do a filesystem related operation and we want to make
     * sure that the tree does not change out from underneath us.
     *
     * @access public
     * @param integer an id to lock
     * @param integer how long to wait for the lock before giving up
     * @return array object GalleryStatus a status code
     *               object GalleryLock a lock
     */
    function acquireReadLockParents($id, $timeout=10) {
	global $gallery;

	$reply =& $this->getStorage();
	$ret = $reply[0];
	$storage =& $reply[1];
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	/* Get the parent entity id */
	list ($ret, $searchResults) = 
	    $gallery->search(array('select' => '[GalleryChildEntity::parentId]',
				   'where' => ('[GalleryChildEntity::id] = ? ')),
			     array($id));
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}
	
	if ($searchResults->resultCount() == 0) {
	    /* This should never happen! */
	    return array(GalleryStatus::error(ERROR_MISSING_OBJECT,
					      __FILE__, __LINE__));
	}
	
	/* Extract the parent id */
	while ($result = $searchResults->nextResult()) {
	    $parentId = $result[0];
	}
	
	if ($parentId == null) {
	    
	    /* No parent -- we're at the root */
	    return array(GalleryStatus::success(), null);
	}
	
	/* Don't both read locking if we already have a read or write lock. */
	if (!($this->isWriteLocked($parentId) || $this->isReadLocked($parentId))) {
	    
	    /* Read lock the parent */
	    list ($ret, $lock1) = $this->acquireReadLock($parentId, $timeout);
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	}
	
	/* Then lock all ancestors of the parent */
	list ($ret, $lock2) = $this->acquireReadLockParents($parentId, $timeout);
	if ($ret->isError()) {
	    $this->releaseLocks($lock1);
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	/* Merge the locks down to a single lock. */
	if (empty($lock1) && empty($lock2)) {
	    $lockId = null;
	} else if (empty($lock1) && !empty($lock2)) {
	    $lockId = $lock2;
	} else if (!empty($lock1) && empty($lock2)) {
	    $lockId = $lock1;
	} else {
	    $this->_locks[$lock1]->merge($this->_locks[$lock2]);
	    unset($this->_locks[$lock2]);
	    $lockId = $lock1;
	}

	return array(GalleryStatus::success(), $lockId);
    }

    /**
     * Return true if the given id is read locked
     *
     * @access public
     * @param int an entity id
     * @return boolean true if the entity is read locked
     */
    function isReadLocked($id) {
	foreach (array_keys($this->_locks) as $lockId) {
	    $lock =& $this->_locks[$lockId];

	    if ($lock->getLockType() != LOCK_READ) {
		continue;
	    }

	    $ids = $lock->getEntityIds();
	    if (in_array($id, $ids)) {
		return true;
	    }
	}

	return false;
    }

    /**
     * Write lock one or more objects
     *
     * @access public
     * @param array ids to lock
     * @param integer how long to wait for the lock before giving up
     * @return array object GalleryStatus a status code
     *               int the lock id
     */
    function acquireWriteLock($ids, $timeout=10) {

	$reply =& $this->getStorage();
	$ret = $reply[0];
	$storage =& $reply[1];
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	list ($ret, $lock) =
	    $storage->acquireWriteLock($ids, $timeout);

	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	$lockId = $lock->getId();
	$this->_locks[$lockId] = $lock;
	return array($ret, $lockId);
    }

    /**
     * Return true if the given id is write locked
     *
     * @access public
     * @param int an entity id
     * @return boolean true if the entity is write locked
     */
    function isWriteLocked($id) {

	foreach (array_keys($this->_locks) as $lockId) {
	    $lock =& $this->_locks[$lockId];

	    if ($lock->getLockType() != LOCK_WRITE) {
		continue;
	    }

	    $ids = $lock->getEntityIds();
	    if (in_array($id, $ids)) {
		return true;
	    }
	}

	return false;
    }

    /**
     * Release the given lock(s)
     *
     * @param array a list of lock ids, or a single lock id
     * @return object GalleryStatus a status code
     */
    function releaseLocks($lockIds) {

	if (!is_array($lockIds)) {
	    $lockIds = array($lockIds);
	}

	/* Check all parameters before starting to release locks */
	foreach ($lockIds as $lockId) {
	    if (!isset($this->_locks[$lockId])) {
		return GalleryStatus::error(ERROR_BAD_PARAMETER,
					    __FILE__, __LINE__);
	    }
	}

	/* Now release all locks */
	foreach ($lockIds as $lockId) {
	    $ret = $this->_locks[$lockId]->release();
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	    unset($this->_locks[$lockId]);
	}

	return GalleryStatus::success();
    }

    /**
     * Release any hanging locks.
     *
     * This should only be invoked as a register_shutdown callback.
     *
     * @access private
     */
    function _releaseHangingLocks() {
	foreach ($this->_locks as $lock) {
	    if ($lock->isLocked()) {
		/* Bitch at the developer! */
		$this->debug("Lock id " . $lock->getId() . " was left hanging!");
		$lock->release();
	    }
	}
    }

    /**
     * Return a new, uninitialized storage instance.  
     *
     * This is useful when we want to do operations on the whole of the storage
     * container (like in the case of DatabaseStorage when we want to drop or
     * create the database).
     *
     * @access public
     * @return array object GalleryStatus a status code
     *               object GalleryStorage a storage instance
     */
    function getUninitializedStorage() {
	$type = $this->getConfig('storage.type');
	$config = $this->getConfig('storage.config');
	
	/* Load the factory class */
	require_once(dirname(__FILE__) . '/GalleryStorageFactory.class');

	list ($ret, $storage) =
	    GalleryStorageFactory::newInstance($type, $config);

	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	return array(GalleryStatus::success(), $storage);
    }
    
    /**
     * Return an instance of the GalleryStorage class
     *
     * @access public
     * @return array object GalleryStatus a status code
     *               object GalleryStorage a storage instance
     */
    function &getStorage() {
	GalleryProfiler::start('Gallery::getStorage');
	
	if (empty($this->_storage)) {
	    list($ret, $storage) = $this->getUninitializedStorage();
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }

	    $ret = $storage->init();
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }

	    $this->_storage = $storage;
	}

	GalleryProfiler::stop('Gallery::getStorage');
	return array(GalleryStatus::success(), &$this->_storage);
    }

    /**
     * Register a template adapter.
     *
     * @param object GalleryTemplateAdapter 
     */
    function setTemplateAdapter($templateAdapter) {
	$this->_templateAdapter = $templateAdapter;
    }

    /**
     * Return the registered template adapter.
     *
     * @return object GalleryTemplateAdapter 
     */
    function &getTemplateAdapter() {
	return $this->_templateAdapter;
    }

    /**
     * Return a properly configured instance of Smarty
     *
     * Create and configure one, if it does not exist.
     *
     * @param string optional compile directory
     * @return array object GalleryStatus a status code
     *               object Smarty
     */
    function getSmarty() {

	GalleryProfiler::start('Gallery::getSmarty');
	if (empty($this->_smarty)) {
	    /*
	     * Load and configure Smarty.
	     */
	    require_once($this->_config['code.smarty.base'] . 'Smarty.class.php');

	    if ($this->isProfiling()) {
		require_once(dirname(__FILE__) . '/GalleryProfilingSmarty.class');
		$this->_smarty = new GalleryProfilingSmarty();
	    } else {
		$this->_smarty = new Smarty();
	    }

	    /* Compiled templates go here */
	    $this->_smarty->compile_dir = $this->getConfig('data.smarty.templates_c');
	    
	    /*
	     * Disable use of subdirs so that we avoid conflicts with
	     * open_basedir and safe_mode
	     */
	    $this->_smarty->use_sub_dirs = false;
	    $this->_smarty->short_template_c_names = true;

	    if ($this->getDebug()) {
		$this->_smarty->debugging = true;
	    }

	    /* Set up core Smarty hooks */
	    foreach (array('Url', 'Text', 'Date', 'Style',
			   ) as $method) {
		$this->_smarty->register_function('gallery' . $method, 'galleryTemplateCallback');
	    }
	    
	    foreach (array('ThinFrame', 'LightFrame', 'HeavyFrame', 'ThreeDFrame',
			   'SmallestFont', 'SmallerFont', 'SmallFont',
			   'BigFont', 'BiggerFont', 'BiggestFont',
			   'SuccessFontColor', 'WarningFontColor', 'ErrorFontColor',
			   'Highlight1', 'Highlight2',
			   'Form', 'Input', 'Select', 'TextArea') as $method) {
		$this->_smarty->register_block('gallery' . $method, 'galleryTemplateCallback');
	    }
	}

	GalleryProfiler::stop('Gallery::getSmarty');
	
	return array(GalleryStatus::success(), $this->_smarty);
    }

    /**
     * Get the status of all modules
     *
     * @return array object GalleryStatus as status code
     *                      array string module names
     */
    function getModuleStatus() {
	GalleryProfiler::start('Gallery::getModuleStatus');

	if (!isset($this->_modules['_status'])) {
	    list ($ret, $modules) = GalleryModuleMap::fetchModuleList();
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }

	    $platform = $this->getPlatform();

	    /* Scan modules directory for installed modules */
	    $modulesDir = $this->getConfig('code.gallery.modules');
	    if ($dir = $platform->opendir($modulesDir)) {
		while ($moduleName = readdir($dir)) {
		    if ($moduleName{0} == '.') {
			continue;
		    }

		    $path = $modulesDir . $moduleName . '/module.inc';
		    if ($platform->file_exists($path)) {
			$modules[$moduleName]['installed'] = 1;
		    }
		}
		closedir($dir);
	    }

	    /* Find and remove modules that are active, but not installed */
	    foreach ($modules as $moduleName => $moduleStatus) {
		if (!isset($moduleStatus['installed'])) {
		    $this->debug("Module $moduleName no longer installed");
		    unset($modules[$moduleName]);
		}
	    }

	    /* Force the core module's status */
	    $modules['core'] = array('active' => 1, 'installed' => 1);

	    $this->_modules['_status'] = $modules;
	}

	GalleryProfiler::stop('Gallery::getModuleStatus');
	
	return array(GalleryStatus::success(),
		     $this->_modules['_status']);
    }

    /**
     * Set the core module instance in the modules table.
     *
     * The core module can't be loaded from inside Gallery with the
     * loadModule() call for chicken-and-egg reasons, so we have to be able to
     * set it here.
     *
     * @param object GalleryModule a module
     */
    function setCoreModule($instance) {
	$this->_modules['core']['instance'] = $instance;
    }

    /**
     * Load and initialize the given module
     *
     * @param string the module name
     * @return array object GalleryStatus a status code
     *               object GalleryModule the module
     */
    function loadModule($moduleName) {
	GalleryProfiler::start('Gallery::loadModule');

	if (!isset($this->_modules[$moduleName]['instance'])) {

	    /* Figure out where the module lives */
	    $galleryBase = $this->getConfig('code.gallery.modules');
	    $moduleFile = $galleryBase . $moduleName . '/module.inc';

	    $platform = $this->getPlatform();

	    if (!$platform->file_exists($moduleFile)) {
		$this->debug('Missing file: ' . $moduleFile);
		return array(GalleryStatus::error(ERROR_BAD_MODULE,
						  __FILE__, __LINE__),
			     null);
	    }

	    /* Load it */
	    require_once($moduleFile);

	    /* Try to instantiate it */
	    $moduleClass = $moduleName . 'Module';
	    if (!class_exists($moduleClass)) {
		return array(GalleryStatus::error(ERROR_BAD_MODULE,
						  __FILE__, __LINE__),
			     null);
	    }
	    $module = new $moduleClass();

	    /* Initialize it */
	    $ret = $module->init();
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }

	    /* Store it in our table */
	    $this->_modules[$moduleName]['instance'] = $module;
	}

	GalleryProfiler::stop('Gallery::loadModule');
	return array(GalleryStatus::success(),
		     $this->_modules[$moduleName]['instance']);
    }

    /**
     * Get the list of all available modules
     *
     * @return array object GalleryStatus a status code
     *               string module names
     */
    function getAllModuleNames() {
	$modulesDir = $this->getConfig('code.gallery.modules');

	$platform = $this->getPlatform();
	
	if ($dir = $platform->opendir($modulesDir)) {
	    while (($file = readdir($dir)) != false) {
		$path = $modulesDir . $file;
		if (preg_match('/^(\.|CVS)/', $file)) {
		    continue;
		}
		
		if ($platform->is_dir($path)) {
		    $moduleNames[] = $file;
		}
	    }
	    closedir($dir);
	}

	return array(GalleryStatus::success(), $moduleNames);
    }

    /**
     * Retrieve all the parameters for a module
     *
     * @param string the module name
     * @return array object GalleryStatus a status code
     *               string a value
     */
    function getAllModuleParameters($moduleName) {
	if (!isset($this->_modules[$moduleName]['parameters'])) {
	    list ($ret, $this->_modules[$moduleName]['parameters']) =
		GalleryModuleParameterMap::fetchAllParameters($moduleName);
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	}

	return array(GalleryStatus::success(),
		     $this->_modules[$moduleName]['parameters']);
    }

    /**
     * Retrieve a module parameter
     *
     * @param string the module name
     * @param string the parameter name
     * @return array object GalleryStatus a status code
     *               string a value
     */
    function getModuleParameter($moduleName, $parameterName) {
	if (empty($moduleName) || empty($parameterName)) {
	    return array(GalleryStatus::error(ERROR_BAD_PARAMETER,
					      __FILE__, __LINE__),
			 null);
	}
	
	/* Load all parameters for the module, if necessary */
	list ($ret, $params) = $this->getAllModuleParameters($moduleName);
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}
	
	/* Return the value, or null if the param doesn't exist */
	if (!isset($params[$parameterName])) {
	    return array(GalleryStatus::success(), null);
	} else {
	    return array(GalleryStatus::success(), $params[$parameterName]);
	}
    }

    /**
     * Set a module parameter
     *
     * @param string the module name
     * @param string the parameter name
     * @param string the value
     * @return object GalleryStatus a status code
     */
    function setModuleParameter($moduleName, $parameterName, $parameterValue) {
	if (empty($moduleName) || empty($parameterName)) {
	    return GalleryStatus::error(ERROR_BAD_PARAMETER,
					__FILE__, __LINE__);
	}

	/*
	 * Figure out if this is an insert or an update.  It's an insert if
	 * we don't have an existing parameter by that name.  Otherwise, it's
	 * an update.
	 */
	if (!isset($this->_modules[$moduleName]['parameters'])) {
	    list ($ret, $this->_modules[$moduleName]['parameters']) =
		GalleryModuleParameterMap::fetchAllParameters($moduleName);
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	}

	if (!isset($this->_modules[$moduleName]['parameters'][$parameterName])) {
	    $ret = GalleryModuleParameterMap::addParameter($moduleName,
							   $parameterName,
							   $parameterValue);
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	} else {
	    $ret = GalleryModuleParameterMap::updateParameter($moduleName,
							      $parameterName,
							      $parameterValue);
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	}

	/* Update our local cache */
	$this->_modules[$moduleName]['parameters'][$parameterName] = $parameterValue;

	return GalleryStatus::success();
    }

    /**
     * Return a reference to the GalleryTranslator instance
     *
     * Create and initialize new instance if necessary.
     *
     * @return object GalleryTranslator
     */
    function &getTranslator() {
	if (empty($this->_translator)) {

	    /* Load the translator class */
	    require_once(dirname(__FILE__) . '/GalleryTranslator.class');
	    
	    $this->_translator = new GalleryTranslator();

	    list ($ret, $activeUser) = $this->getActiveUser();
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }

	    $ret = $this->_translator->init($activeUser->getLanguage());
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	}

	return array(GalleryStatus::success(), &$this->_translator);
    }

    /**
     * Add any number of new entries to the registry
     *
     * Note:  the key value of the registry is case insensitive!
     *
     * @param string the key
     * @param mixed the value, ...
     */
    function addRegistry($key, $value) {
	$count = func_num_args();
	$key = strtolower(func_get_arg(0));
	for ($i = 1; $i < $count; $i++) {
	    $this->_registry[$key][] = func_get_arg($i);
	}
    }

    /**
     * Return the registry values associated with the given key
     *
     * @param string the key
     * @return mixed the value
     */
    function lookupRegistry($key) {
	$key = strtolower($key);
	if (empty($this->_registry[$key])) {
	    return array();
	}
	return $this->_registry[$key];
    }

    /**
     * Create a new GalleryEntity of the given type
     *
     * Look up the location of the entity's class definition from the registry,
     * then load that specific file and instantiate the class
     *
     * @return array object GalleryStatus a status code
     *               object a GalleryEntity
     */
    function newEntity($className) {
	list ($filename) = $this->lookupRegistry('GalleryEntity.' . $className);

	if (empty($filename)) {
	    return array(GalleryStatus::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__),
			 null);
	}

	require_once($filename);
	if (!class_exists($className)){
	    return array(GalleryStatus::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__),
			 null);
	}
    
	return array(GalleryStatus::success(), new $className);
    }

    /**
     * Set the maximum amount of time we should contine to work
     *
     * @param int a time interval in seconds
     */
    function setTimeLimit($limit) {
	set_time_limit($limit);
	$now = time();
	$this->_timeLimit = $now + $limit;
	// $this->debug("[$now] Set time limit to " . $this->_timeLimit);
    }

    /**
     * Guarantee that we have at least this many more seconds to work
     *
     * After this function completes, we will be guaranteed to have at least
     * this much more time to work.
     *
     * @param int a time interval in seconds
     */
    function guaranteeTimeLimit($limit) {
	$now = time();
	if (empty($this->_timeLimit) || ($this->_timeLimit - $now < 5)) {
	    $this->debug("[$now] can't guarantee $limit -- extending!");
	    $this->setTimeLimit($limit);
	}
    }

    /**
     * Change the profiling state
     *
     * @param bool
     */
    function setProfile($profile=null) {
	$this->_profile = $profile ? true : false;
    }

    /**
     * Get the profiling state
     *
     * @return bool
     */
    function isProfiling() {
	return $this->_profile;
    }

    /**
     * Change the debugging state
     *
     * @param mixed one of 'buffered', 'logged', 'immediate' or false
     */
    function setDebug($debug) {
	$this->_debug = $debug;
	if (isset($this->_storage)) {
	    if ($this->_debug) {
		$this->_storage->setDebug(true);
	    } else {
		$this->_storage->setDebug(false);
	    }
	}
    }

    /**
     * Set the location of debugging output
     *
     * @param string a filename
     */
    function setDebugLogFile($debugLogFile) {
	$this->_debugLogFile = $debugLogFile;
    }

    /**
     * Get the debug state
     *
     * @return mixed the debug state
     */
    function getDebug() {
	return $this->_debug;
    }

    /**
     * Get any buffered debug output
     *
     * @return string the debug state
     */
    function getDebugBuffer() {
	return $this->_debugBuffer;
    }

    /**
     * Clear any buffered debug output
     */
    function clearDebugBuffer() {
	$this->_debugBuffer = '';
    }

    /**
     * Output a debug message
     *
     * @param string a message
     */
    function debug($msg) {
	if (empty($msg)) {
	    return;
	}

	if (!empty($this->_debug)) {
	    if (!strcmp($this->_debug, 'buffered')) {
		$this->_debugBuffer .= wordwrap("$msg\n");
	    } else if (!strcmp($this->_debug, 'logged')) {
		if ($fd = fopen($this->_debugLogFile, 'a')) {
		    $date = date('Y-m-d H:i:s');
		    fwrite($fd, '$date [' . session_id() . '] $msg\n');
		    fclose($fd);
		}
	    } else if (!strcmp($this->_debug, 'immediate')) {
		print "$msg\n";
	    }
	}
    }

    /**
     * Output a print_r style debug message
     *
     * @param mixed any object or value
     */
    function debug_r($object) {
	if (!empty($this->_debug)) {
	    ob_start();
	    print_r($object);
	    $buf = ob_get_contents();
	    ob_end_clean();
	    
	    $this->debug($buf);
	}
    }

    /**
     * Get the string representation(s) of an error.
     *
     * An error is a set of bitflags, so we return an array of strings.
     * @param int the error code
     * @return array string names of the errors
     */
    function getErrorAsStrings($errorCode) {
	$codes = array();
	foreach (get_defined_constants() as $constantName => $constantValue) {
	    if (strpos($constantName, 'ERROR_') === 0) {
		if ($errorCode & $constantValue) {
		    $codes[] = $constantName;
		}
	    }
	}

	return $codes;
    }

    /**
     * Register an event listener
     *
     * @param string the name of the event (eg "GalleryEntity::save")
     * @param object a GalleryEventListener instance
     */
    function registerEventListener($eventName, $listener) {
	if (empty($this->_eventListeners[$eventName])) {
	    $this->_eventListeners[$eventName] = array();
	}

	$this->_eventListeners[$eventName][] = $listener;
    }

    /**
     * Deliver an event to anybody listening
     *
     * @param string the name of the event (eg "GalleryEntity::save")
     * @param object a GalleryEvent
     * @return object GalleryStatus a status code
     */
    function postEvent($event) {
	if (!empty($this->_eventListeners[$event->getEventName()])) {
	    foreach ($this->_eventListeners[$event->getEventName()] as $listener) {
		$ret = $listener->handleEvent( $event);
		if ($ret->isError()) {
		    return $ret->wrap(__FILE__, __LINE__);
		}
	    }
	}

	return GalleryStatus::success();
    }

}
?>
