<?php
/*
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2002 Bharat Mediratta
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

/**
 * Global storage container and utility class for Gallery
 *
 * This is a container for global information required for gallery
 * operation, such as configuration, session, user, etc.  
 *
 * @version $Id$
 * @package GalleryCore
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class Gallery {

    /*
     * ****************************************
     *                 Members
     * ****************************************
     */

    /**
     * The id of the root AlbumItem in the Gallery
     *
     * @var string $_rootAlbumItemId
     * @access private
     */
    var $_rootAlbumItemId;

    /**
     * The id of the active user
     *
     * @var int $_activeUserId
     * @access private
     */
    var $_activeUserId;

    /**
     * Storage for all configuration variables, set in config.php.
     * The values contained here can't be modified.  Well, they
     * can be modified but they can't be saved so it's not a good
     * idea.  
     *
     * @var array $_config
     * @access private
     */
    var $_config;

    /**
     * The current GalleryGraphics
     *
     * @var object GalleryGraphics $_graphics
     * @access private
     */
    var $_graphics;

    /**
     * Storage for all session variables.  
     *
     * @var array $_session
     * @access private
     */
    var $_session;

    /**
     * The backend persistent store for the Gallery class
     *
     * @var object GalleryStorage $_storage
     * @access private
     */
    var $_storage;

    /**
     * An instance of the GalleryPlatform class
     *
     * @var object GalleryPlatform $_platform
     * @access private
     */
    var $_platform;

    /**
     * The current debugging mode.  One of 'buffered', 'logged', 'immediate' or false
     * 
     * @var bool $_debug
     * @access private
     */
    var $_debug;
    
    /**
     * Where to send debug output (when the debugging mode is set to 'logged')
     * 
     * @var bool $_debugLogFile
     * @access private
     */
    var $_debugLogFile;
    
    /**
     * A place to temporarily store debug output when the debugging mode is set
     * to 'buffered'
     * 
     * @var bool $_debugBuffer
     * @access private
     */
    var $_debugBuffer;

    /**
     * The time at which we should cease whatever operation we're doing
     *
     * @var int $_timeLimit
     * @access private
     */
    var $_timeLimit;

    /**
     * A list of all the locks that have been acquired during this request
     *
     * @var array $_locks
     * @access private
     */
    var $_locks;
    
    /*
     * ****************************************
     *                 Methods
     * ****************************************
     */

    /**
     * Constructor
     *
     */
    function Gallery() {
	$this->_locks = array();

	/* Set up a shutdown function to release any hanging locks. */
	register_shutdown_function(array($this, '_releaseHangingLocks'));
    }

    /**
     * Return the id of the GalleryItem associated with the path provided
     *
     * Return the id associated with the given path. Example path:
     * "/birthdays/fred" .. this is the "fred" item in the "birthdays"
     * item.  It doesn't really matter what types of items these are, as
     * long as the path is legitimate.
     *
     * @access public
     * @param string the path to a GalleryItem
     * @return array object GalleryStatus a status code
     *               int the id of the GalleryItem (or null)
     */
    function getIdByPath($path) {
	list($ret, $storage) = $this->getStorage();
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	/*
	 * XXX: do this in applogic, not in the storage class.
	 */
    }

    /**
     * Load the GalleryEntity with the id specified
     *
     * @param int the id of the GalleryEntity to load
     * @return array object GalleryStatus a status code, object GalleryEntity
     */
    function loadEntityById($id) {
	if (empty($id)) {
	    return array(GalleryStatus::error(ERROR_BAD_PARAMETER,
					      __FILE__, __LINE__),
			 null);
	}

	/* Load the entity from our persistent store */
	list($ret, $storage) = $this->getStorage();
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	return $storage->loadEntity($id);
    }

    /**
     * Delete the entity with the given id 
     *
     * @param int the id of a GalleryEntity to delete
     * @return object GalleryStatus a status code 
     */
    function deleteEntityById($id) {
	if (empty($id)) {
	    return array(GalleryStatus::error(ERROR_BAD_PARAMETER,
					      __FILE__, __LINE__),
			 null);
	}

	list ($ret, $lockId) = $this->acquireWriteLock($id);
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}
	
	list ($ret, $entity) = $this->loadEntityById($id);
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}
	
	$ret = $entity->delete();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}
	
	$ret = $this->releaseLocks($lockId);
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	return GalleryStatus::success();
    }

    /**
     * @see GalleryStorage::search()
     */
    function search($query, $data=array()) {
	list($ret, $storage) = $this->getStorage();
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}
	
	return $storage->search($query, $data);
    }

    /**
     * Return the id of the root GalleryItem
     *
     * The root GalleryItem should be an AlbumItem
     *
     * @access public
     * @return int the id of the root album
     */
    function getRootAlbumId() {
	return $this->_rootAlbumItemId;
    }

    /**
     * Set the id of the root GalleryItem
     *
     * The root GalleryItem should be an AlbumItem.
     *
     * @access public
     * @param int the id of the GalleryItem
     */
    function setRootAlbumId($id) {
	if (empty($id)) {
	    return GalleryStatus::error(ERROR_BAD_PARAMETER,
					__FILE__, __LINE__);
	}

	$this->_rootAlbumItemId = $id;
    }

    /**
     * Get the Id of the active user
     *
     * The active user is the user who is logged on in this 
     * session.
     * 
     * @access public
     * @return int the id of the current User.
     */
    function getActiveUserId() {
	return $this->_activeUserId;
    }

    /**
     * Set the id of the active user
     *
     * The active user is the user who is logged on in this 
     * session.
     * 
     * @param int the id of the current User.
     * @access public
     */
    function setActiveUserId($id) {
	assert('!empty($id)');
	$this->_activeUserId = $id;
    }

    /**
     * Get the image toolkit
     *
     * Return a the active GalleryGraphics
     * 
     * @access public
     * @return array object GalleryStatus a status code
     *               object GalleryGraphics the active image toolkit
     */
    function getGraphics() {

	/*
	 * Create the graphics object on demand.
	 */
	if (empty($this->_graphics)) {
	    $type = $this->getConfig('graphics.type');
	    $config = $this->getConfig('graphics.config');
	    list($ret, $this->_graphics) =
		    GalleryGraphicsFactory::newInstance($type, $config);
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	}
	
	return array(GalleryStatus::success(), $this->_graphics);
    }

    /**
     * Store a value in the Gallery config table
     *
     * @param string the key name
     * @param mixed the value
     * @access public
     */
    function setConfig($key, $value) {
	assert('!empty($key)');
	$this->_config[$key] = $value;
    }

    /**
     * Get a value from the Gallery configuration settings
     *
     * @access public
     * @return mixed an arbitrary value
     */
    function getConfig($key) {
	assert('!empty($key)');
	return $this->_config[$key];
    }

    /**
     * Get the Gallery session object.
     *
     * Return a reference to the unique Gallery session object.  Any changes
     * made to this object will be saved in the session.
     * 
     * @access public
     * @return array session information
     */
    function &getSession() {
	return $this->_session;
    }

    /**
     * Get the Gallery platform object.
     *
     * Return a copy of the unique Gallery platform object.
     * 
     * @access public
     * @return array object GalleryStatus a status code
     *               object GalleryPlatform the Gallery platform object
     */
    function getPlatform() {
	if (empty($this->_platform)) {
	    list($ret, $platform) = GalleryPlatformFactory::newInstance('unix');
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	    $this->_platform = $platform;
	}
	
	return array(GalleryStatus::success(), $this->_platform);
    }

    /**
     * Read Lock one or more objects
     *
     * @access public
     * @param array ids to lock
     * @param integer how long to wait for the lock before giving up
     * @return array object GalleryStatus a status code
     *               int the lock id
     */
    function acquireReadLock($ids, $timeout=10) {
	list ($ret, $storage) = $this->getStorage();
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}
	
	list ($ret, $lock) =
	    $storage->acquireReadLock($ids, $timeout);
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	$lockId = $lock->getId();
	$this->_locks[$lockId] = $lock;
	return array($ret, $lockId);
    }

    /**
     * Acquire read locks on all the parents of this id.  This is useful when
     * we're going to do a filesystem related operation and we want to make
     * sure that the tree does not change out from underneath us.
     *
     * @access public
     * @param integer an id to lock
     * @param integer how long to wait for the lock before giving up
     * @return array object GalleryStatus a status code
     *               object GalleryLock a lock
     */
    function acquireReadLockParents($id, $timeout=10) {
	global $gallery;

	$lock = null;
	$current = $id;
	while (true) {
	    list ($ret, $searchResults) = 
		$gallery->search(array('select' => '[GalleryChildEntity::parentId]',
				       'where' => ('[GalleryChildEntity::id] = ? ')),
				 array($current));
	    if ($ret->isError()) {
		if (isset($lock)) {
		    $lock->release();
		    return array($ret->wrap(__FILE__, __LINE__), null);
		}
	    }

	    if ($searchResults->resultCount() == 0) {
		/* This should never happen! */
		return array(GalleryStatus::error(ERROR_MISSING_OBJECT,
						  __FILE__, __LINE__));
	    }

	    /* Extract the parent id */
	    while ($result = $searchResults->nextResult()) {
		$current = $result[0];
	    }

	    if ($current == null) {

		/* No parent -- we're at the root */
		if ($lock == null) {
		    $lock = new GalleryLock();
		}
		break;
	    }

	    /* Lock the parent */
	    list ($ret, $newLock) = $this->acquireReadLock($current, $timeout);
	    if ($ret->isError()) {
		if (isset($lock)) {
		    $lock->release();
		    return $ret->wrap(__FILE__, __LINE__);
		}
	    }

	    /* Merge the locks together. */
	    if (isset($lock)) {
		$ret = $lock->merge($newLock);
		if ($ret->isError()) {
		    $lock->release();
		    $newLock->release();
		}
	    } else {
		$lock = $newLock;
	    }
	    
	    /* Then lock all ancestors of the parent */
	    list ($ret, $newLock) = $this->acquireReadLockParents($current, $timeout);
	    if ($ret->isError()) {
		if (isset($lock)) {
		    $lock->release();
		    return $ret->wrap(__FILE__, __LINE__);
		}
	    }

	    /* Merge the locks together. */
	    $ret = $lock->merge($newLock);
	    if ($ret->isError()) {
		$lock->release();
		$newLock->release();
	    }
	}

	$lockId = $lock->getId();
	$this->_locks[$lockId] = $lock;
	return array(GalleryStatus::success(), $lockId);
    }

    /**
     * Return true if the given id is read locked
     *
     * @access public
     * @param int an entity id
     * @return boolean true if the entity is read locked
     */
    function isReadLocked($id) {
	foreach (array_keys($this->_locks) as $lockId) {
	    $lock =& $this->_locks[$lockId];

	    if ($lock->getLockType() != LOCK_READ) {
		continue;
	    }

	    $ids = $lock->getEntityIds();
	    if (in_array($id, $ids)) {
		return true;
	    }
	}

	return false;
    }

    /**
     * Write lock one or more objects
     *
     * @access public
     * @param array ids to lock
     * @param integer how long to wait for the lock before giving up
     * @return array object GalleryStatus a status code
     *               int the lock id
     */
    function acquireWriteLock($ids, $timeout=10) {
	list ($ret, $storage) = $this->getStorage();
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	list ($ret, $lock) =
	    $storage->acquireWriteLock($ids, $timeout);

	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	$lockId = $lock->getId();
	$this->_locks[$lockId] = $lock;
	return array($ret, $lockId);
    }

    /**
     * Return true if the given id is write locked
     *
     * @access public
     * @param int an entity id
     * @return boolean true if the entity is write locked
     */
    function isWriteLocked($id) {

	foreach (array_keys($this->_locks) as $lockId) {
	    $lock =& $this->_locks[$lockId];

	    if ($lock->getLockType() != LOCK_WRITE) {
		continue;
	    }

	    $ids = $lock->getEntityIds();
	    if (in_array($id, $ids)) {
		return true;
	    }
	}

	return false;
    }

    /**
     * Release the given lock(s)
     *
     * @param array a list of lock ids, or a single lock id
     * @return object GalleryStatus a status code
     */
    function releaseLocks($lockIds) {
	if (!is_array($lockIds)) {
	    $lockIds = array($lockIds);
	}

	/* Check all parameters before starting to release locks */
	foreach ($lockIds as $lockId) {
	    if (!isset($this->_locks[$lockId])) {
		return GalleryStatus::error(ERROR_BAD_PARAMETER,
					    __FILE__, __LINE__);
	    }
	}

	/* Now release all locks */
	foreach ($lockIds as $lockId) {
	    $ret = $this->_locks[$lockId]->release();
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	    unset($this->_locks[$lockId]);
	}

	return GalleryStatus::success();
    }

    /**
     * Release any hanging locks.
     *
     * This should only be invoked as a register_shutdown callback.
     *
     * @access private
     */
    function _releaseHangingLocks() {
	foreach ($this->_locks as $lock) {
	    if ($lock->isLocked()) {
		/* Bitch at the developer! */
		$this->debug("Lock id " . $lock->getId() . " was left hanging!");
		$lock->release();
	    }
	}
    }

    /**
     * Return an instance of the GalleryStorage class
     *
     * @access public
     * @return array object GalleryStatus a status code
     *               object GalleryStorage a storage instance
     */
    function getStorage() {
	if (empty($this->_storage)) {
	    /* Set up our storage system */
	    $type = $this->getConfig('storage.type');
	    $config = $this->getConfig('storage.config');
	    
	    list($ret, $storage) =
		    GalleryStorageFactory::newInstance($type, $config);
	    if ($ret->isError()) {
		return array($ret, null);
	    }

	    $ret = $storage->init();
	    if ($ret->isError()) {
		return array($ret, null);
	    }

	    $this->_storage = $storage;
	}
	return array(GalleryStatus::success(), $this->_storage);
    }

    /**
     * Set the maximum amount of time we should contine to work
     *
     * @param int a time interval in seconds
     */
    function setTimeLimit($limit) {
	set_time_limit($limit);
	$now = time();
	$this->_timeLimit = $now + $limit;
	$this->debug("[$now] Set time limit to " . $this->_timeLimit);
    }

    /**
     * Guarantee that we have at least this many more seconds to work
     *
     * After this function completes, we will be guaranteed to have at least
     * this much more time to work.
     *
     * @param int a time interval in seconds
     */
    function guaranteeTimeLimit($limit) {
	$now = time();
	if (empty($this->_timeLimit) || ($this->_timeLimit - $now < 5)) {
	    $this->debug("[$now] can't guarantee $limit -- extending!");
	    $this->setTimeLimit($limit);
	}
    }

    /**
     * Change the debugging state
     *
     * @param mixed one of 'buffered', 'logged', 'immediate' or false
     */
    function setDebug($debug) {
	$this->_debug = $debug;
	if (isset($this->_storage)) {
	    if ($this->_debug) {
		$this->_storage->setDebug(true);
	    } else {
		$this->_storage->setDebug(false);
	    }
	}
    }

    /**
     * Set the location of debugging output
     *
     * @param string a filename
     */
    function setDebugLogFile($debugLogFile) {
	$this->_debugLogFile = $debugLogFile;
    }

    /**
     * Get the debug state
     *
     * @return mixed the debug state
     */
    function getDebug() {
	return $this->_debug;
    }

    /**
     * Output a debug message
     *
     * @param string a message
     */
    function debug($msg) {
	if (empty($msg)) {
	    return;
	}
	
	if (!empty($this->_debug)) {
	    if (!strcmp($this->_debug, 'buffered')) {
		$this->_debugBuffer .= "$msg\n";
	    } else if (!strcmp($this->_debug, 'logged')) {
		if ($fd = fopen($this->_debugLogFile, 'a')) {
		    $date = date('Y-m-d H:i:s');
		    fwrite($fd, '$date [' . session_id() . '] $msg\n');
		    fclose($fd);
		}
	    } else if (!strcmp($this->_debug, 'immediate')) {
		print "$msg\n";
	    }
	}
    }

    /**
     * Get the string representation(s) of an error.
     *
     * An error is a set of bitflags, so we return an array of strings.
     * @param int the error code
     * @return array string names of the errors
     */
    function getErrorAsStrings($errorCode) {
	$codes = array();
	foreach (get_defined_constants() as $constantName => $constantValue) {
	    if (strpos($constantName, 'ERROR_') === 0) {
		if ($errorCode & $constantValue) {
		    $codes[] = $constantName;
		}
	    }
	}

	return $codes;
    }
}
?>
