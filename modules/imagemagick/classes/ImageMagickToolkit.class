<?php
/*
 * $RCSfile$
 *
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2004 Bharat Mediratta
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
/**
 * @version $Revision$ $Date$
 * @package ImageMagick
 * @author Vallimar <vallimar@sexorcisto.net>
 * @author Bharat Mediratta <bharat@menalto.com>
 */

/**
 * Load required classes
 */
GalleryCoreApi::relativeRequireOnce('/modules/core/classes/GalleryToolkit.class');
GalleryCoreApi::requireOnce(dirname(__FILE__) . '/ImageMagickToolkitHelper.class');

/**
 * A ImageMagick version of GalleryToolkit
 *
 * This class implements the GalleryToolkit API using ImageMagick.
 *
 * @package ImageMagick
 * @subpackage Classes
 */
class ImageMagickToolkit extends GalleryToolkit {
    /*
     * ****************************************
     *                 Methods
     * ****************************************
     */

    /**
     * @see GalleryToolkit::getProperty()
     */
    function getProperty($mimeType, $propertyName, $sourceFilename) {

	switch($propertyName) {
	case 'dimensions':
	    list ($ret, $width, $height) = $this->_getImageDimensions($mimeType, $sourceFilename);
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	    $results = array((int)$width, (int)$height);
	    break;

	case 'page-count':
	    list ($ret, $count) = $this->_getPageCount($sourceFilename);
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null);
	    }
	    $results = array($count);
	    break;

	default:
	    return array(GalleryStatus::error(ERROR_UNIMPLEMENTED, __FILE__, __LINE__),
			 null);
	}

	return array(GalleryStatus::success(), $results);
    }

    /**
     * @see GalleryToolkit::performOperation()
     */
    function performOperation($mimeType, $operationName, $sourceFilename,
			      $destFilename, $parameters, $context=array()) {
	global $gallery;
	static $convertOps = array('thumbnail', 'scale', 'resize', 'rotate',
				   'crop', 'convert-to-image/jpeg', 'select-page');

	/* Check context for any operations that have been queued up.. */
	if (isset($context['imagemagick.transform'])) {
	    $transform = $context['imagemagick.transform'];
	    $outputMimeType = $context['imagemagick.mime'];
	    unset($context['imagemagick.transform']);
	    unset($context['imagemagick.mime']);
	} else {
	    $transform = array();
	    $outputMimeType = $mimeType;
	}
	if (isset($context['width'])) {
	    $width = $context['width'];
	    $height = $context['height'];
	}

	/* Use context look-ahead to see if we can queue up parameters to use later.. */
	$queueIt = in_array($operationName, $convertOps)
	    && isset($context['next.toolkit']) && $context['next.toolkit'] == $this
	    && in_array($context['next.operation'], $convertOps);

	if (!isset($width) &&
		($queueIt || in_array($operationName, array('thumbnail', 'crop', 'composite')))) {
	    list ($ret, $width, $height) = $this->_getImageDimensions($mimeType, $sourceFilename);
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null, null);
	    }
	}

	switch($operationName) {
	case 'thumbnail':
	    $cmd = 'convert';
	    /* Strip metadata to make derivative files smaller.. */
	    list ($ret, $removeMetaDataSwitch) =
		GalleryCoreApi::getPluginParameter('module', 'imagemagick', 'removeMetaDataSwitch');
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null, null);
	    }
	    if (!empty($removeMetaDataSwitch)) {
		$transform = array_merge($transform, explode('|', $removeMetaDataSwitch));
	    }
	    /* Don't enlarge images for a thumbnail */
	    if ($width > $parameters[0] || $height > $parameters[0]) {
		$transform = array_merge($transform, array(
					'-size', $parameters[0] . 'x' . $parameters[0],
					'-geometry', $parameters[0] . 'x' . $parameters[0]));
		list ($width, $height) =
		    GalleryUtilities::scaleDimensionsToFit($width, $height, $parameters[0]);
	    }
	    break;

	case 'scale':
	    $cmd = 'convert';
	    $transform = array_merge($transform,
			       array('-size', $parameters[0] . 'x' . $parameters[0],
				     '-geometry', $parameters[0] . 'x' . $parameters[0]));
	    if (isset($width)) {
		list ($width, $height) =
		    GalleryUtilities::scaleDimensionsToFit($width, $height, $parameters[0]);
	    }
	    break;

	case 'resize':
	    $cmd = 'convert';
	    $transform = array_merge($transform,
			       array('-size', $parameters[0] . 'x' . $parameters[1],
				     '-geometry', $parameters[0] . 'x' . $parameters[1]));
	    if (isset($width)) {
		list ($width, $height) = GalleryUtilities::scaleDimensionsToFit(
					 $width, $height, $parameters[0], $parameters[1]);
	    }
	    break;

	case 'rotate':
	    $cmd = 'convert';
	    $transform = array_merge($transform, array('-rotate', (string)$parameters[0]));
	    if (isset($width) && ($parameters[0] == 90 || $parameters[0] == -90)) {
		$tmp = $width;
		$width = $height;
		$height = $tmp;
	    }
	    break;

	case 'crop':
	    /* source dimensions are required to convert from percentages to pixels  */
	    $pixelX = round($parameters[0] / 100 * $width);
	    $pixelY = round($parameters[1] / 100 * $height);
	    $width = round($parameters[2] / 100 * $width);
	    $height = round($parameters[3] / 100 * $height);

	    $cmd = 'convert';
	    $transform = array_merge($transform,
			       array('-crop', sprintf('%sx%s+%s+%s',
					      $width, $height, $pixelX, $pixelY)));
	    break;

	case 'convert-to-image/jpeg':
	    $cmd = 'convert';
	    $outputMimeType = 'image/jpeg';
	    break;

	case 'select-page':
	    $cmd = 'convert';
	    $transform['page'] = $parameters[0];
	    break;

	case 'composite':
	    list ($ret, $cmd) =
		GalleryCoreApi::getPluginParameter('module', 'imagemagick', 'compositeCmd');
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null, null);
	    }
	    if (empty($cmd)) {
		$cmd = 'composite';
	    }
	    $compositeOverlayPath = $parameters[0];
	    $compositeOverlayMimeType = $parameters[1];
	    $compositeWidth = $parameters[2];
	    $compositeHeight = $parameters[3];
	    $compositeAlignmentType = $parameters[4];
	    $compositeAlignX = $parameters[5];
	    $compositeAlignY = $parameters[6];

	    switch ($compositeAlignmentType) {
	    case 'top-left': // Top - Left
	        $compositeAlignX = 0;
	        $compositeAlignY = 0;
	        break;

	    case 'top': // Top
	        $compositeAlignX = 50;
	        $compositeAlignY = 0;
	        break;

	    case 'top-right': // Top - Right
	        $compositeAlignX = 100;
	        $compositeAlignY = 0;
	        break;

	    case 'left': // Left
	        $compositeAlignX = 0;
	        $compositeAlignY = 50;
	        break;

	    case 'center': // Center
	        $compositeAlignX = 50;
	        $compositeAlignY = 50;
	        break;

	    case 'right': // Right
	        $compositeAlignX = 100;
	        $compositeAlignY = 50;
	        break;

	    case 'bottom-left': // Bottom - Left
	        $compositeAlignX = 0;
	        $compositeAlignY = 100;
	        break;

	    case 'bottom': // Bottom
	        $compositeAlignX = 50;
	        $compositeAlignY = 100;
	        break;

	    case 'bottom-right': // Bottom Right
	        $compositeAlignX = 100;
	        $compositeAlignY = 100;
	        break;

	    case 'manual': // Manual placement
		// Use the alignments we received
		break;

	    default:
		return array(GalleryStatus::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__,
				    "Unknown composite alignment type: $compositeAlignmentType"),
			     null, null);
	    }

	    // Convert from percentages to pixels
	    $compositeAlignX = (int)($compositeAlignX / 100 * $width);
	    $compositeAlignY = (int)($compositeAlignY / 100 * $height);

	    // Clip to our bounding box
	    $compositeAlignX = max(0, $compositeAlignX);
	    $compositeAlignX = min($compositeAlignX, $width - $compositeWidth);
	    $compositeAlignY = max(0, $compositeAlignY);
	    $compositeAlignY = min($compositeAlignY, $height - $compositeHeight);

	    $dataDir = $gallery->getConfig('data.gallery.base');
	    $transform = array('-geometry', '+' . $compositeAlignX . '+' . $compositeAlignY,
			       $dataDir . $compositeOverlayPath);
	    break;

	default:
	    return array(GalleryStatus::error(ERROR_UNSUPPORTED_OPERATION, __FILE__, __LINE__,
					      "$operationName $mimeType"), null, null);
	}

	if (isset($width)) {
	    $context['width'] = $width;
	    $context['height'] = $height;
	}

	if ($queueIt) {
	    $context['imagemagick.transform'] = $transform;
	    $context['imagemagick.mime'] = $outputMimeType;

	    if ($sourceFilename != $destFilename) {
		$platform = $gallery->getPlatform();
		if (!$platform->copy($sourceFilename, $destFilename)) {
		    return array(GalleryStatus::error(ERROR_PLATFORM_FAILURE, __FILE__, __LINE__),
				 null, null);
		}
	    }
	    return array(GalleryStatus::success(), $outputMimeType, $context);
	}

	if ($outputMimeType == $mimeType && empty($transform)) {
	    /* Just copy the source to the destination */
	    if ($sourceFilename != $destFilename) {
		$platform = $gallery->getPlatform();
		if (!$platform->copy($sourceFilename, $destFilename)) {
		    return array(GalleryStatus::error(ERROR_PLATFORM_FAILURE, __FILE__, __LINE__),
				 null, null);
		}
	    }
	} else {
	    $ret = $this->_transformImage($mimeType, $cmd, $transform,
					  $sourceFilename, $destFilename, $outputMimeType);
	    if ($ret->isError()) {
		return array($ret->wrap(__FILE__, __LINE__), null, null);
	    }
	}

	return array(GalleryStatus::success(), $outputMimeType, $context);
    }

    /**
     * @see GalleryGraphics::getImageDimensions()
     */
    function _getImageDimensions($mimeType, $filename) {
	global $gallery;

	/*
	 * Run it through PHP first, it's faster and more portable.  If it runs
	 * afoul of open_basedir it'll return false and we can try ImageMagick.
	 */
	$platform = $gallery->getPlatform();
	$results = $platform->getimagesize($filename);
	if (($results != false) &&
	    (($results[0] > 1) && ($results[1] > 1))) {
	    return array(GalleryStatus::success(), $results[0], $results[1]);
	}

	list ($ret, $cmd) = ImageMagickToolkitHelper::getCommand('identify');
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), 0, 0);
	}

	$oldCwd = $platform->getcwd();
	$platform->chdir($gallery->getConfig('data.gallery.tmp'));
	list ($success, $output) = $platform->exec(array(array_merge($cmd, array($filename))));
	if (!$success) {
	    $platform->chdir($oldCwd);
	    return array(GalleryStatus::error(ERROR_TOOLKIT_FAILURE, __FILE__, __LINE__), 0, 0);
	}
	$platform->chdir($oldCwd);

	foreach ($output as $line) {
	    if (ereg('([0-9]+)x([0-9]+)', $line, $regs)) {
		return array(GalleryStatus::success(), $regs[1], $regs[2]);
	    }
	}

	return array(GalleryStatus::error(ERROR_TOOLKIT_FAILURE, __FILE__, __LINE__), null, null);
    }

    /**
     * Call 'identify' and count the pages
     */
    function _getPageCount($filename) {
	global $gallery;
	$platform = $gallery->getPlatform();

	list ($ret, $cmd) = ImageMagickToolkitHelper::getCommand('identify');
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	$oldCwd = $platform->getcwd();
	$platform->chdir($gallery->getConfig('data.gallery.tmp'));
	list ($success, $output) = $platform->exec(array(array_merge($cmd, array($filename))));
	$platform->chdir($oldCwd);
	if (!$success) {
	    return array(GalleryStatus::error(ERROR_TOOLKIT_FAILURE, __FILE__, __LINE__), null);
	}

	$count = 0;
	$match = '/' . preg_quote(basename($filename)) . '[[ =]/';
	foreach ($output as $line) {
	    if (preg_match($match, $line)) {
		$count++;
	    }
	}

	return array(GalleryStatus::success(), $count);
    }

    /**
     * Do the given transform on the source image
     *
     * @param string the command to execute
     * @param string the path to a source file
     * @param string the path to a destination file
     * @return object GalleryStatus a status code
     */
    function _transformImage($mimeType, $cmd, $args, $sourceFilename, $destFilename, $outputMimeType) {
	global $gallery;

	/* Get a temp file name and figure out our convert-from-pnm command */
	$tmpDir = $gallery->getConfig('data.gallery.tmp');
	$platform = $gallery->getPlatform();
	$tmpFilename = $platform->tempnam($tmpDir, 'imgk_');
	if (empty($tmpFilename)) {
	    /* This can happen if the $tmpDir path is bad */
	    return GalleryStatus::error(ERROR_BAD_PATH, __FILE__, __LINE__);
	}

	list ($ret, $command) = ImageMagickToolkitHelper::getCommand($cmd);
	if ($ret->isError()) {
	    @$platform->unlink($tmpFilename);
	    return $ret->wrap(__FILE__, __LINE__);
	}
	list ($ret, $jpegQuality) =
		GalleryCoreApi::getPluginParameter('module', 'imagemagick', 'jpegQuality');
	if ($ret->isError()) {
	    @$platform->unlink($tmpFilename);
	    return $ret->wrap(__FILE__, __LINE__);
	}

	switch ($outputMimeType) {
	case 'image/png'  :
	case 'image/jpeg' :
	    $command[] = '-quality';
	    $command[] = $jpegQuality;
	    break;
	}

	switch ($mimeType) {
	case 'image/tiff':
	case 'application/pdf':
	case 'application/postscript':
	    /* TIFF can be multi-scened, PDF can be multi-paged;
	     * make sure ImageMagick grabs the first scene/page,
	     * unless a specific one is requested */
	    $page = 0;
	    if (isset($args['page'])) {
		$page = $args['page'] - 1;
		unset($args['page']);
	    }
	    $sourceFilename .= '[' . $page . ']';
	    break;
	}

	/*
	 * Prepare our command.  If one of the arguments is %s, then put the source file path there, else put
	 * it at the end.
	 */
	if (!empty($args)) {
	    $command = array_merge($command, $args);
	}
	$replaced = false;
	for ($i = 0; $i < sizeof($command); $i++) {
	    if ($command[$i] == '%s') {
		$command[$i] = $sourceFilename;
		$replaced = true;
	    }
	}
	if (!$replaced) {
	    $command[] = $sourceFilename;
	}

	if ($mimeType == $outputMimeType) {
	    $command[] = $tmpFilename;
	} else {
	    switch($outputMimeType) {
	    case 'image/jpeg':
		$command[] = sprintf("jpeg:%s", $tmpFilename);
		break;

	    default:
		/* Don't know this type! */
		@$platform->unlink($tmpFilename);
		return GalleryStatus::error(ERROR_TOOLKIT_FAILURE, __FILE__, __LINE__,
					    "Can't convert to unknown mime type: $outputMimeType");
	    }
	}

	$oldCwd = $platform->getcwd();
	$platform->chdir($gallery->getConfig('data.gallery.tmp'));
	list ($success, $output) = $platform->exec(array($command));
	if (!$success) {
	    @$platform->unlink($tmpFilename);
	    $platform->chdir($oldCwd);
	    return GalleryStatus::error(ERROR_TOOLKIT_FAILURE, __FILE__, __LINE__);
	}
	$platform->chdir($oldCwd);

	$success = $platform->rename($tmpFilename, $destFilename);
	if (!$success) {
	    @$platform->unlink($tmpFilename);
	    return GalleryStatus::error(ERROR_PLATFORM_FAILURE,
					__FILE__, __LINE__,
					"Failed renaming $tmpFilename -> $destFilename");
	} else {
	    return GalleryStatus::success();
	}
    }

    /**
     * Return the full path to the ImageMagick command
     *
     * @access private
     * @param string an ImageMagick command (eg. "convert")
     */
    function _imageMagickCmd($cmd) {
	global $gallery;

	$platform = $gallery->getPlatform();
	list ($ret, $imageMagickPath) =
		GalleryCoreApi::getPluginParameter('module', 'imagemagick', 'path');
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	return $imageMagickPath . $cmd;
    }
}
?>
