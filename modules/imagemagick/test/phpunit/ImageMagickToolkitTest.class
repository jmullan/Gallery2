<?php
/*
 * $RCSfile$
 *
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2004 Bharat Mediratta
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
/**
 * @version $Revision$ $Date$
 * @package ImageMagick
 * @subpackage PHPUnit
 * @author Bharat Mediratta <bharat@menalto.com>
 */

/**
 * Required classes
 */
require_once(dirname(__FILE__) . '/../../classes/ImageMagickToolkitHelper.class');
require_once(dirname(__FILE__) . '/../../classes/ImageMagickToolkit.class');

/**
 * Test ImageMagickToolkit functionality
 *
 * @package ImageMagick
 * @subpackage PHPUnit
 */
class ImageMagickToolkitTest extends GalleryTestCase {

    /*
     * The array with environment information, from ImEnvironments.inc
     */
    var $_environments = array();

    /*
     * The current environment array item we are processing
     */
    var $_currentEnvironment = array();

    /*
     * Information about files in our pseudo-platform.
     * Better would be to store the files information in the Platform, but
     * since Gallery::getPlatform() will return a copy of the platform, we
     * cannot keep them there.
     */
    var $_files = array();

    function ImageMagickToolkitTest($methodName) {
	$this->GalleryTestCase($methodName);

	/* Load our environments */
	include(dirname(__FILE__) . '/ImEnvironments.inc');
	$this->_environments = $imEnvironment;
    }

    /**
     * 
     */
    function setUp() {
	global $gallery;
	
	parent::setUp();
	
	$gallery->_platform =& new ImageMagickToolkitTestPlatform($gallery->getPlatform(), $this->_files);
	
	$this->_save = array();
	foreach (array('path', 'jpegQuality', 'compositeCmd', 'binary', 'removeMetaDataSwitch') as $key) {
	    list ($ret, $this->_save[$key]) = GalleryCoreApi::getPluginParameter('module', 'imagemagick', $key);
	    if ($ret->isError()) {
		print $ret->getAsHtml();
		return $ret->wrap(__FILE__, __LINE__);
	    }
	}
	
	/* Reset to the defaults -- tearDown will undo this */
	foreach (array('jpegQuality' => 75) as $key => $value) {
	    $ret = GalleryCoreApi::setPluginParameter('module', 'imagemagick', $key, $value);
	    if ($ret->isError()) {
		print $ret->getAsHtml();
		return $this->failWithStatus($ret->wrap(__FILE__, __LINE__));
	    }
	}
	
	/* Get a toolkit to work with */
	$this->_toolkit =& new ImageMagickToolkit();
    }

    /**
     *
     */
    function tearDown() {
	global $gallery;
	
	foreach ($this->_save as $key => $value) {
	    $ret = GalleryCoreApi::setPluginParameter('module', 'imagemagick', $key, $value);
	    if ($ret->isError()) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	}
	
	parent::tearDown();
    }

    /**
     * Prepare to emulate a different version of IM/GM
     *
     * @param array the array item of the environment
     * @access private
     */
    function _setEnvironment($environment) {
	global $gallery;
	
	$environment['path'] = '/' . $environment['name'] . $environment['version'] . '/';
	
	$ret = GalleryCoreApi::setPluginParameter('module', 'imagemagick', 'path', $environment['path']);
	if ($ret->isError()) {
	    print $ret->getAsHtml();
	    return $this->failWithStatus($ret->wrap(__FILE__, __LINE__));
	}
	
	$this->_currentEnvironment = $environment;
	$gallery->_platform->setEnvironment($environment);
	
	$ret = ImageMagickToolkitHelper::savePlatformParameters();
	if ($ret->isError()) {
	    print $ret->getAsHtml();
	    return $this->failWithStatus($ret->wrap(__FILE__, __LINE__));
	}
	
	return true;
    }

    /**
     * Helper to test a certain operation
     * 
     * @param string
     * @param string
     * @param string filename
     * @param string filename
     * @param array indexed array
     * @param array assoc-array with paramName=>paramValue
     * 
     * @access private
     * @return object GalleryStatus
     */
    function _testOperation($mimeType, $operation, $src, $dst, $params, $namedParams) {
	list ($ret, $outputMimeType) =
	    $this->_toolkit->performOperation($mimeType, $operation,
					      $src, $dst, $params);
	if ($ret->isError()) {
	    return $ret->wrap(__FILE__, __LINE__);
	}
	
	if ($mimeType == 'image/tiff' || $mimeType == 'application/pdf') {
	    $src = $src . '[0]';
	}
	
	$search = array('|%src%|', '|%dst%|');
	$replace = array($src, $dst);
	foreach ($namedParams as $key => $value) {
	    $search[] = sprintf('|%%%s%%|', $key);
	    $replace[] = $value;
	}
	$expected = $this->_currentEnvironment['operations'][$operation];
	foreach (array_keys($expected) as $key) {
	    $expected[$key] = preg_replace($search, $replace, $expected[$key]);
	}
	
	if ($outputMimeType == 'image/jpeg' || $outputMimeType == 'image/png') {
	    foreach (array_keys($expected) as $key) {
		$expected[$key] = array_merge(array('-quality', '75'), $expected[$key]);
	    }
	} 
	
	global $_ImPlatformFiles;
	$this->assertEquals($expected, $this->_files[$dst]['operation'], $this->_currentEnvironment['path']);

	return GalleryStatus::success();
    }

    function testPerformOperations() {
	global $gallery;
	foreach ($this->_environments as $environment) {
	    $this->_setEnvironment($environment);

	    $ret = $this->_testOperation('image/gif', 'thumbnail',
					 'test[1000x1000].gif', 'output.gif',
					 array(100, 100),
					 array('width' => 100, 'height' => 100));
	    if ($ret->isError()) {
		return $this->failWithStatus($ret->wrap(__FILE__, __LINE__));
	    }

	    $ret = $this->_testOperation('image/jpeg', 'thumbnail',
					 'test[1000x1000].jpg', 'output.jpg',
					 array(100, 100),
					 array('width' => 100, 'height' => 100));
	    if ($ret->isError()) {
		return $this->failWithStatus($ret->wrap(__FILE__, __LINE__));
	    }

	    $ret = $this->_testOperation('image/tiff', 'rotate',
					 'test.tiff', 'output.tiff',
					 array(90), array('angle' => 90));
	    if ($ret->isError()) {
		return $this->failWithStatus($ret->wrap(__FILE__, __LINE__));
	    }

	    $ret = $this->_testOperation('image/bmp', 'rotate',
					 'test.bmp', 'output.bmp',
					 array(180), array('angle' => 180));
	    if ($ret->isError()) {
		return $this->failWithStatus($ret->wrap(__FILE__, __LINE__));
	    }

	    $ret = $this->_testOperation('image/png', 'crop',
					 'test[640x480].png', 'output.png',
					 array('24.667', '23.5', '51.375', '52'),
					 array('width' => '329', 'height' => '250', 'x' => '158', 'y' => '113')
				    );
	    if ($ret->isError()) {
		return $this->failWithStatus($ret->wrap(__FILE__, __LINE__));
	    }

	    // Test a basic composite operation (top right corner)
	    $ret = $this->_testOperation('image/png', 'composite',
					  'test.png',   // composite
					  'output.png', // composited
					  array('image.gif', // image
						'image/gif', // mimeType
						50, 50, // image width, height
						0, 0,   // image alignment x, y
						3),     // alignment type
					  array('image' => 'image.gif',
						'width' => '50',
						'height' => '50',
						'x' => '0',
						'y' => '0'));
	    if ($ret->isError()) {
		return $this->failWithStatus($ret->wrap(__FILE__, __LINE__));
	    }

	    // Test another composite with out of range params that should get corrected
	    $ret = $this->_testOperation('image/png', 'composite',
					  'test.png',   // composite
					  'output.png', // composited
					  array('image.gif', // image
						'image/gif', // mimeType
						50, 50, // image width, height
						151, 151,   // image alignment x, y
						3),     // alignment type
					  array('image' => 'image.gif',
						'width' => '50',
						'height' => '50',
						'x' => '0',
						'y' => '0'));
	    if ($ret->isError()) {
		return $this->failWithStatus($ret->wrap(__FILE__, __LINE__));
	    }

	    list ($ret, $mimeType) =
		$this->_toolkit->performOperation('image/png', 'BOGUS',
						  'BOGUS',
						  'BOGUS',
						  array('BOGUS'));

	    $this->assert($ret->getErrorCode() & ERROR_UNIMPLEMENTED);
	}
    }

    function testGetProperties() {
	foreach ($this->_environments as $environment) {
	    $this->_setEnvironment($environment);

	    list ($ret, $results) =
		$this->_toolkit->getProperty('image/gif', 'dimensions', 'test[10x20].gif');
	    if ($ret->isError()) {
		return $this->failWithStatus($ret->wrap(__FILE__, __LINE__));
	    }
	    $this->assertEquals(array(10, 20), $results);

	    list ($ret, $results) =
		$this->_toolkit->getProperty('image/gif', 'BOGUS', 'BOGUS');
	    $this->assert($ret->getErrorCode() & ERROR_UNIMPLEMENTED);
	}
    }

    function testMergeOperations() {
	list ($success, $operation, $args) =
	    $this->_toolkit->mergeOperations('crop', array(1, 2, 3, 4), 'crop', array(3, 4, 5, 6));
	$this->assert($success);
	$this->assertEquals('crop', $operation);
	$this->assertEquals(array(3, 4, 5, 6), $args);

	list ($success, $operation, $args) =
	    $this->_toolkit->mergeOperations('resize', array(1, 2), 'resize', array(3, 4));
	$this->assert($success);
	$this->assertEquals('resize', $operation);
	$this->assertEquals(array(3, 4), $args);

	list ($success, $operation, $args) =
	    $this->_toolkit->mergeOperations('thumbnail', array(1, 2), 'resize', array(3, 4));
	$this->assert($success);
	$this->assertEquals('resize', $operation);
	$this->assertEquals(array(3, 4), $args);

	list ($success, $operation, $args) =
	    $this->_toolkit->mergeOperations('thumbnail', array(1, 2), 'thumbnail', array(3, 4));
	$this->assert($success);
	$this->assertEquals('thumbnail', $operation);
	$this->assertEquals(array(3, 4), $args);

	list ($success, $operation, $args) =
	    $this->_toolkit->mergeOperations('scale', array(1, 2), 'thumbnail', array(3, 4));
	$this->assert($success);
	$this->assertEquals('thumbnail', $operation);
	$this->assertEquals(array(3, 4), $args);

	list ($success, $operation, $args) =
	    $this->_toolkit->mergeOperations('rotate', array(90), 'rotate', array(90));
	$this->assert($success);
	$this->assertEquals('rotate', $operation);
	$this->assertEquals(array(180), $args);

	list ($success, $operation, $args) =
	    $this->_toolkit->mergeOperations('rotate', array(90), 'rotate', array(-90));
	$this->assert($success);
	$this->assertEquals(null, $operation);
	$this->assertEquals(null, $args);

	list ($success, $operation, $args) =
	    $this->_toolkit->mergeOperations('rotate', array(270), 'rotate', array(180));
	$this->assert($success);
	$this->assertEquals('rotate', $operation);
	$this->assertEquals(array(90), $args);

	list ($success, $operation, $args) =
	    $this->_toolkit->mergeOperations('rotate', array(90), 'rotate', array(-180));
	$this->assert($success);
	$this->assertEquals('rotate', $operation);
	$this->assertEquals(array(-90), $args);

	list ($success, $operation, $args) =
	    $this->_toolkit->mergeOperations('rotate', array(90), 'rotate', array(180));
	$this->assert($success);
	$this->assertEquals('rotate', $operation);
	$this->assertEquals(array(-90), $args);

	list ($success, $operation, $args) =
	    $this->_toolkit->mergeOperations('rotate', array(270), 'rotate', array(90));
	$this->assert($success);
	$this->assertEquals(null, $operation);
	$this->assertEquals(null, $args);

	list ($success, $operation, $args) =
	    $this->_toolkit->mergeOperations('crop', array(1, 2, 3, 4), 'thumbnail', array(3, 4));
	$this->assert(!$success);
    }

    function testDiscoverMimeTypes() {
	foreach ($this->_environments as $environment) {
	    $this->_setEnvironment($environment);

	    list ($ret, $results) = ImageMagickToolkitHelper::discoverMimeTypes($this->_currentEnvironment['path']);
	    if ($ret->isError()) {
		return $this->failWithStatus($ret->wrap(__FILE__, __LINE__));
	    }
	    $this->assertEquals($environment['mimeTypes'], $results);
	}
    }

    function testGetOperationsAndProperties() {
	foreach ($this->_environments as $environment) {
	    $this->_setEnvironment($environment);

	    list ($ret, $results) = ImageMagickToolkitHelper::getOperationsAndProperties();
	    if ($ret->isError()) {
		return $this->failWithStatus($ret->wrap(__FILE__, __LINE__));
	    }
	    $wantToConvert = array('image/tiff', 'image/svg+xml', 'application/pdf');
	    $canConvert = array_intersect($wantToConvert, $environment['mimeTypes']);

	    $this->assertEquals(array(
		'convert-to-image/jpeg' => array(
			'params' => array(),
			'description' => 'Convert to a JPEG',
			'mimeTypes' => $canConvert,
			'outputMimeType' => 'image/jpeg'
		),
		'scale' => array(
			'params' => array(
				array(
					'type' => 'int',
					'description' => 'target size'
				)
			),
			'description' => 'Scale the image to the target size',
			'mimeTypes' => $environment['mimeTypes'],
		),
		'thumbnail' => array(
			'params' => array(
				array(
					'type' => 'int',
					'description' => 'target size'
				)
			),
			'description' => 'Scale the image to the target size',
			'mimeTypes' => $environment['mimeTypes'],
		),
		'resize' => array(
			'params' => array(
				array(
					'type' => 'int',
					'description' => 'target width'
				),
				array(
					'type' => 'int',
					'description' => 'target height'
				)
			),
			'description' => 'Resize the image to the target dimensions',
			'mimeTypes' => $environment['mimeTypes'],
		),
		'rotate' => array(
			'params' => array(
				array(
					'type' => 'int',
					'description' => 'rotation degrees'
				)
			),
			'description' => 'Rotate the image',
			'mimeTypes' => $environment['mimeTypes'],
		),
		'crop' => array(
			'params' => array(
				array(
					'type' => 'float',
					'description' => 'left edge %'
				),
				array(
					'type' => 'float',
					'description' => 'top edge %'
				),
				array(
					'type' => 'float',
					'description' => 'width %'
				),
				array(
					'type' => 'float',
					'description' => 'height %'
				)
			),
			'description' => 'Crop the image',
			'mimeTypes' => $environment['mimeTypes'],
		),
		'composite' => array(
			'params' => array(
				array(
					'type' => 'string',
					'description' => 'overlay path'
				),
				array(
					'type' => 'string',
					'description' => 'overlay mime type'),
				array(
					'type' => 'int',
					'description' => 'overlay width'),
				array(
					'type' => 'int',
					'description' => 'overlay height'),
				array(
					'type' => 'int',
					'description' => 'alignment location x'),
				array(
					'type' => 'int',
					'description' => 'alignment location y'),
				array(
					'type' => 'int',
					'description' => 'alignment type'
				)
			),
			'description' => 'Composite the image',
			'mimeTypes' => $environment['mimeTypes'],
		),
	    ), $results['operations']);

	    $this->assertEquals(array(
		'dimensions' => array(
			'type' => 'int,int',
			'description' => 'Get the width and height of the image',
			'mimeTypes' => $environment['mimeTypes'],
		)
	    ), $results['properties']);
	}
    }

    function testBinaries() {
	foreach ($this->_environments as $environment) {
	    $this->_setEnvironment($environment);

	    list ($ret, $results) = ImageMagickToolkitHelper::testBinaries($this->_currentEnvironment['path']);
	    if ($ret->isError()) {
		return $this->failWithStatus($ret->wrap(__FILE__, __LINE__));
	    }
	    
	    $wanted = array('identify', 'convert', 'combine', 'composite');
	    $expected = array();
	    foreach ($wanted as $binary) {
		if (in_array($binary, $this->_currentEnvironment['binaries'])) {
		    $expected[] = array('name' => $binary, 'success' => true);
		}
	    }
	    
	    $this->assertEquals($expected, $results);
	}

	list ($ret, $results) = ImageMagickToolkitHelper::testBinaries('/bogusPath');
	$this->assert($ret->getErrorCode() & ERROR_BAD_PATH);
    }
}

/**
 * Test platform
 *
 * @package ImageMagick
 * @subpackage PHPUnit
 */
class ImageMagickToolkitTestPlatform {

    var $_environment = array();
    var $_files;

    function ImageMagickToolkitTestPlatform($originalPlatform, &$files) {
	$this->_platform = $originalPlatform;
	$this->_files =& $files;
    }

    function setEnvironment($environment) {
	$this->_environment = $environment;
    }

    function exec($cmd) {
	global $gallery;
	global $_ImPlatformFiles;
	list ($ret, $imageMagickPath) = GalleryCoreApi::getPluginParameter('module', 'imagemagick', 'path');
	if ($ret->isError()) {
	    return array($ret->wrap(__FILE__, __LINE__), null);
	}

	$firstCmd = $cmd[0];
	if ($this->_environment['binary'] != '') {
	    if (basename($firstCmd[0]) != $this->_environment['binary']) {
		return array(0, array('unprepared for exec()'));
	    }
	    array_shift($firstCmd);
	}

	$output = array();
	$status = false;

	$binary = array_shift($firstCmd);
	$binary = basename($binary);
	if ($binary == 'identify') {
	    $file = array_shift($firstCmd);
	    $file = basename($file);
	    if (isset($this->_environment['identify'][$file])) {
		$output = split("\n", $this->_environment['identify'][$file]);
	    } else {
		$output = split("\n", $this->_environment['identify']['UNKNOWN']);
	    }
	    $status = true;
	} elseif (($binary == 'convert' && in_array('convert', $this->_environment['binaries']))
			|| ($binary == 'composite' && in_array('composite', $this->_environment['binaries']))
			|| ($binary == 'combine' && in_array('combine', $this->_environment['binaries'])) ) {
	    $params = array_slice($firstCmd, 0);
	    $src = basename($firstCmd[count($firstCmd) - 2]);
	    $dst = basename($firstCmd[count($firstCmd) - 1]);
	    if (preg_match('#(.*):(.*)$#', $dst, $matches)) {
		// Format 'jpeg:filename.jpg'
		$dst = $matches[2];
	    }
	    if ($src == 'testProfile.jpg') {
		// ImageMagickToolkitHelper is testing our removeMetaDataSwitch
		$params = array_slice($firstCmd, 0, count($firstCmd) - 2);
		if ($this->_environment['removeMetaDataSwitch'] == $params) {
		    $this->_files[$dst] = array('size' => 50000);
		} else {
		    $this->_files[$dst] = array('size' => 0);
		}
		$output = array();
		$status = true;
	    } else {
		/* Remember how we converted from $src to $dst, so we can compare it later
		 * with what we really wanted
		 */
		$this->_files[$dst] = array('operation' => array($binary => $params));
		$output = array();
		$status = true;
	    }
	}

	if ($status) {
	    return array(1, $output);
	}
	echo $this->_environment['path'] . ": ERROR exec()ing:<pre>";
	print_r($cmd);
	echo "</pre>\n";
	return array(0, array('unprepared for exec()'));
    }

    function rename($oldName, $newName) {
	global $_ImPlatformFiles;
	$oldBase = basename($oldName);
	$newBase = basename($newName);
	if (isset($this->_files[$oldBase])) {
	    $this->_files[$newBase] = $this->_files[$oldBase];
	    if (isset($this->_files[$newBase]['operation'])) {
		foreach (array_keys($this->_files[$newBase]['operation']) as $operation) {
		    $count = count($this->_files[$newBase]['operation'][$operation]);
		    $this->_files[$newBase]['operation'][$operation][$count - 1] = $newName;
		}
	    }
	    unset($this->_files[$oldBase]);
	    return true;
	}
	echo $this->_environment['path'] . ": rename($oldName, $newName)<br>\n";
	return false;
    }

    function isRestrictedByOpenBasedir($path) {
	//echo $this->_environment['path'] . ": isRestrictedByOpenBasedir($path)<br>\n";
	return false;
    }

    function file_exists($path) {
	if ($path == $this->_environment['path']) {
	    return true;
	}
	$dirName = dirname($path) . '/';
	$baseName = basename($path);
	if ($dirName == $this->_environment['path']) {
	    if ($this->_environment['binary'] != '' && $baseName == $this->_environment['binary']) {
		return true;
	    }
	    if ($this->_environment['binary'] == ''
		    && in_array($baseName, $this->_environment['binaries']) ) {
		return true;
	    }
	}
	//echo $this->_environment['path'] . ": file_exists($path)<br>\n";
	return false;
    }
    
    function is_dir($path) {
	if ($path == $this->_environment['path']) {
	    return true;
	}
	echo $this->_environment['path'] . ": is_dir($path)<br>\n";
	return false;
    }

    function is_executable($file) {
	$dirName = dirname($file) . '/';
	$baseName = basename($file);
	if ($dirName == $this->_environment['path']) {
	    if ($this->_environment['binary'] != '' && $baseName == $this->_environment['binary']) {
		return true;
	    }
	    if ($this->_environment['binary'] == ''
		    && in_array($baseName, $this->_environment['binaries']) ) {
		return true;
	    }
	}

	echo $this->_environment['path'] . ": is_executable($file)<br>\n";
	return false;	
    }

    function copy($file1, $file2) {
	echo $this->_environment['path'] . ": copy($file1, $file2)<br>\n";
    }

    function filesize($file) {
	global $_ImPlatformFiles;
	$basename = basename($file);
	if ($basename == 'testProfile.jpg') {
	    return 100000;
	}
	if (isset($this->_files[$basename]['size'])) {
	    return $this->_files[$basename]['size'];
	}
	echo $this->_environment['path'] . ": filesize($file)<br>\n";
	return 0;
    }

    function tempnam($dir, $prefix) {
	$fileName = $dir . $prefix . md5(rand());
	//echo $this->_environment['path'] . ": tempnam($dir, $prefix) = $fileName<br>\n";
	return $fileName;
    }

    function unlink($path) {
	global $_ImPlatformFiles;
	$baseName = basename($path);
	if (isset($this->_files[$baseName])) {
	    unset($this->_files[$baseName]);
	    return true;
	}
	echo $this->_environment['path'] . ": unlink($path)<br>\n";
	return false;
    }

    function getimagesize($path) {
	$basename = basename($path);
	if (preg_match('#\[(\d+)x(\d+)\]#', $basename, $matches)) {
	    return array($matches[1], $matches[2], 1, sprintf('height="%d" width="%d"', $matches[1], $matches[2]));
	}
	//echo $this->_environment['path'] . ": getimagesize($path)<br>\n";
	return false;
    }

    function getDirectorySeparator() {
	return $this->_platform->getDirectorySeparator();
    }

    function realpath($path) {
	return $this->_platform->realpath($path);
    }
}

?>
